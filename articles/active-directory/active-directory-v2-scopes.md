<properties
    pageTitle="アプリ モデル v2.0 のスコープ、アクセス許可、および同意 | Microsoft Azure"
    description="スコープ、アクセス許可、同意など、Azure AD v2.0 アプリ モデルでの承認の説明。"
    services="active-directory"
    documentationCenter=""
    authors="dstrockis"
    manager="mbaldwin"
    editor=""/>

<tags
    ms.service="active-directory"
    ms.workload="identity"
    ms.tgt_pltfrm="na"
    ms.devlang="na"
    ms.topic="article"
    ms.date="12/09/2015"
    ms.author="dastrock"/>


# アプリ モデル v2.0 プレビュー: スコープ、アクセス許可、および同意

Azure AD と統合されるアプリでは、アプリがどのようにデータにアクセスできるかをユーザーが制御できるようにする、特定の承認モデルが使用されます。 アプリ モデル v2.0 では、この承認モデルの実装が更新され、アプリが Azure AD とやり取りする方法が変わりました。 このトピックでは、スコープ、アクセス許可、同意など、この承認モデルの基本的な概念について説明します。
> [AZURE.NOTE]
    この情報は、v2.0 アプリ モデルのパブリック プレビューに関するものです。 一般的に使用できる Azure AD と統合する方法については、サービスを参照してください、 [Azure Active Directory 開発者ガイド 』](active-directory-developers-guide.md)します。

## スコープとアクセス許可

アプリケーション モデルのバージョン 2.0 を実装して、 [OAuth 2.0](active-directory-v2-protocols.md) 、サード パーティ アプリケーションで、ユーザーに代わって web ホストのリソースにアクセスできるようにする方法は、承認のプロトコルです。 Azure AD と統合される、Web でホストされるすべてのリソースは、リソース識別子、つまり**アプリ ID URI** を持ちます。 Microsoft の Web でホストされるリソースには、次のようなものがあります。

- Office 365 には、メール API が統合されます `https://outlook.office.com`。
- Azure リソース マネージャー API: `https://management.azure.com`
- Azure AD Graph API で: `https://graph.windows.net`

Azure AD と統合されたサード パーティのリソースも同様です。 これらのリソースのいずれでも、機能をより小さいまとまりに分割するために使用できるアクセス許可のセットを定義できます。 たとえば、Office 365 統合メール API では、次のような基本的なアクセス許可が定義されています。

- ユーザーのメールボックスの読み取り
- ユーザーのメールボックスの書き込み
- ユーザーとしてのメールの送信

これらのアクセス許可を定義することで、リソースはデータを外部にどのように公開するかをきめ細かく制御できます。 サード パーティのアプリは、エンド ユーザーにこれらのアクセス許可を要求します。アプリがユーザーに代わって動作するには、エンド ユーザーがアクセス許可を承認する必要があります。 リソースの機能を細かいアクセス許可セットにまとめることによって、サード パーティ アプリは、機能を実行するために必要な特定のアクセス許可のみを要求するように構築できます。 また、アプリが正確にはどのようにデータを使用するかをエンド ユーザーに知らせ、アプリが悪意のある動作をしないことを確信できるようにすることもできます。

Azure AD と OAuth では、これらのアクセス許可は**スコープ**と呼ばれます。 **oAuth2Permissions** と呼ばれる場合もあります。 スコープは、Azure AD では文字列値として表されます。 Office 365 統合メール API の例では、各アクセス許可のスコープ値は次のとおりです。

- ユーザーのメールボックスを読み取る: `Mail.Read`
- ユーザーのメールボックスへの書き込み: `Mail.ReadWrite`
- ユーザーとしてメールを送信します `Mail.Send`。

アプリは、以下に示すように、v2.0 エンドポイントへの要求でスコープを指定することによって、これらのアクセス許可を要求できます。

## 同意

[OpenID Connect または OAuth 2.0](active-directory-v2-protocols.md) 承認を要求と、アプリを使用して必要なアクセス許可を要求できます、 `スコープ` クエリ パラメーターです。 たとえば、ユーザーがアプリにサインインするときに、アプリは次のような要求を送信します (読みやすくするために、改行を入れています)。

```
GET https://login.microsoftonline.com/common/oauth2/v2.0/authorize?
client_id=2d4d11a2-f814-46a7-890a-274a72a7309e
&response_type=code
&redirect_uri=http%3A%2F%2Flocalhost%2Fmyapp%2F
&response_mode=query
&scope=
https%3A%2F%2Foutlook.office.com%2Fmail.read%20
https%3A%2F%2Foutlook.office.com%2Fmail.send
&state=12345
```

`スコープ` パラメーターは、アプリケーションが要求スコープのスペースで区切られた一覧。 個々のスコープは、リソースの識別子 (アプリ ID URI) にスコープ値を追加することによって示されます。 上の要求では、ユーザーのメールボックスを読み取り、ユーザーとしてメールを送信するためのアクセス許可をアプリが必要としていることが示されています。

ユーザーが資格情報を入力すると、v2.0 エンドポイントが**ユーザーの同意**の一致するレコードを確認します。 要求されたアクセス許可にユーザーがまだ同意したことがない場合、v2.0 エンドポイントは要求されたアクセス許可を付与するようにユーザーに求めます。

![職場アカウントの同意のスクリーン ショット](../media/active-directory-v2-flows/work_account_consent.png)

ユーザーがアクセス許可を承認すると、同意が記録され、ユーザーが以降のサインインで再度同意しなくても済むようになります。

## 増分同意

アプリは、初期サインインまたはサインアップで、必要なすべてのアクセス許可をユーザーに要求する必要はありません。 要求ごとにスコープを指定できるため、アプリは "増分同意" を実行し、ユーザーに同意を求める最適なタイミングを選択できます。 アプリがすべてのアクセス許可を一度に求めない一般的な理由として、次のようなものがあります。

- アプリが多くのアクセス許可を必要とする。 アプリがさまざまなリソースにアクセスし、各リソースで多様な機能を実行すると、アプリが必要とするアクセス許可の一覧は、すぐに長くなってしまいます。 従来は、アクセス許可の長い一覧のためにユーザーがアプリへのサインアップをためらったりして、導入数を低下させていました。 このように一度にすべてのアクセス許可を求めるのでなく、初期サインインでは一部のアクセス許可だけを求め、その後、ユーザーが高度な機能をしようとしたときに追加のアクセス許可を求めるようにすることができます。
- アプリがしだいに成長する。 ほぼすべてのアプリが、最初は少ない機能だけを持ち、しだいに成長して、新しい機能が組み込まれていきます。 増分同意では、アプリを簡単に変更でき、新しいアクセス許可をユーザーにスムーズに要求できます。 承認要求で追加のスコープを送信するようにコードを更新するだけです。
- 管理者のみのアクセス許可である。一部のリソースでは、組織の管理者**だけ**が同意または承認できるアクセス許可が定義されます。たとえば、Azure AD Graph API の定義、 `Directory.Write` などに、アプリを作成、更新、およびユーザーとグループ、amognst を削除できるアクセス許可。このアクセス許可に、高い特権を持つ管理者の承認が必要な理由は明白です。増分同意を使用すると、アプリは管理者の承認なしでどのユーザーでもサインアップできる、機能の基本セットを公開できます。ただし、高い特権が必要な操作をユーザーが実行しようとしたら、管理者のみのアクセス許可を求め、アプリのその部分にアクセスする前に管理者がサインアップすることを要求できます。

## アクセス許可の使用

ユーザーがアプリのアクセス許可に同意したら、アプリは一定範囲でリソースにアクセスするためのアプリのアクセス許可を表すアクセス トークンを取得できます。 特定のアクセス トークンは、1 つのリソースだけで使用できますが、その内部には、そのリソースに関してアプリに付与されたすべてのアクセス許可がエンコードされます。 アクセス トークンを取得するために、アプリは v2.0 トークン エンドポイントへの次のような要求を作成できます。

```
POST common/v2.0/oauth2/token HTTP/1.1
Host: https://login.microsoftonline.com
Content-Type: application/json

{
    "grant_type": "authorization_code",
    "client_id": "2d4d11a2-f814-46a7-890a-274a72a7309e",
    "scope": "https://outlook.office.com/mail.read https://outlook.office.com/mail.send",
    "code": "AwABAAAAvPM1KaPlrEqdFSBzjqfTGBCmLdgfSTLEMPGYuNHSUYBrq..."
    "client_secret": "zc53fwe80980293klaj9823"  // NOTE: Only required for web apps
}
```

結果として得られるアクセス トークンは、リソースへの HTTP 要求で使用され、アプリが特定のタスクを実行するための適切なアクセス許可を持っていることをリソースに示します。

OAuth 2.0 プロトコル、およびアクセス トークンを取得する方法の詳細については、次を参照してください。、 [アプリ モデル バージョン 2.0 プロトコル リファレンス](active-directory-v2-protocols.md)します。

## OpenId と Offline_Access

アプリケーション モデルのバージョン 2.0 が 2 つの明確に定義されたスコープの特定のリソースに適用されない `openid` と `offline_access`します。

#### OpenId

サインインを使用してアプリを実行する場合 [OpenID Connect](active-directory-v2-protocols.md#openid-connect-sign-in-flow), 、それを要求する必要があります、 `openid` スコープ。  `Openid` 「サインイン」のアクセス許可と作業アカウント同意画面および「プロフィールの表示し、アプリケーションと Microsoft アカウントを使用してサービスへの接続」のアクセス許可と、個人用 Microsoft アカウント同意画面スコープが表示されます。 このアクセス許可により、アプリは OpenID Connect ユーザー情報エンドポイントにアクセスできるようになるので、ユーザー承認が必要です。  `Openid` スコープこともできますバージョン 2.0 トークン エンドポイントで、アプリのさまざまなコンポーネント間の HTTP 呼び出しの保護に使用できる id_tokens を取得します。

#### Offline_Access

`Offline_access` スコープでは、アプリがリソースへのアクセスをユーザーの代理として一定の時間。 このスコープは、職場アカウントの同意画面には、"いつでもデータにアクセス" アクセス許可として表示されます。 個人用 Microsoft アカウントの同意画面には、"いつでも情報にアクセス" アクセス許可として表示されます。 ユーザーを承認するときに、 `offline_access` スコープ、バージョン 2.0 トークン エンドポイントから更新トークンを受信するアプリケーションが有効になります。 更新トークンは有効期間が長いので、古いアクセス トークンの有効期限が切れたときに、アプリは新しいアクセス トークンを取得できます。

アプリを要求しない場合、 `offline_access` スコープ、refresh_tokens を受け取ることはありません。 つまり、authorization_code でを使用するときに、 [OAuth 2.0 承認コード フロー](active-directory-v2-protocols.md#oauth2-authorization-code-flow), 、だけを受信するバックアップから、access_token、 `トークン/` エンドポイント。 その access_token は、短時間 (通常は 1 時間) 有効ですが、最終的には期限が切れます。 バックアップを作成する時点で、アプリがユーザーをリダイレクトする必要がある at、 `承認/` エンドポイントを新しい authorization_code を取得します。 このリダイレクト中に、アプリの種類によっては、ユーザーが資格情報を再入力したり、アクセス許可に再同意したりする必要がある場合もあります。

取得および更新トークンを使用する方法の詳細についてを参照してください、 [アプリ モデル バージョン 2.0 プロトコル リファレンス](active-directory-v2-protocols.md)します。





