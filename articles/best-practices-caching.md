<properties
   pageTitle="キャッシュに関するガイダンス | Microsoft Azure"
   description="キャッシュによるパフォーマンスとスケーラビリティの向上に関するガイダンス。"
   services=""
   documentationCenter="na"
   authors="dragon119"
   manager="masimms"
   editor=""
   tags=""/>

<tags
   ms.service="best-practice"
   ms.devlang="na"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="na"
   ms.date="04/28/2015"
   ms.author="masashin"/>


# キャッシュに関するガイダンス

![](media/best-practices-caching/pnp-logo.png)

キャッシュは、パフォーマンスを向上させることを目的とする一般的な手法と
アクセスされるデータを一時的に頻繁にコピーすることによってシステムのスケーラビリティ
アプリケーションの近くに配置されている高速ストレージです。 場合はこの高速なデータ ストレージ
近くにあるキャッシュし、元のソースよりもアプリケーション
使用してクライアント アプリケーションの応答時間が大幅に向上します。
データより迅速にします。 キャッシュは、クライアントが繰り返しインスタンスしたときに最も効果的です
同じデータを読み取り、データが比較的静的な場合に特にと
元のデータ ストア キャッシュの速度を基準とした低速で、
高レベルの競合の対象か、遠く離れたときのネットワーク待機時間
低速であるへのアクセスが発生することができます。

## 分散アプリケーションでのキャッシュ

分散アプリケーションは、通常の一方または両方に実装します
データをキャッシュする場合は、次の方法を確認します。

- プライベート キャッシュを使用する (アプリケーションまたはサービスのインスタンスが実行されているコンピュータ上でデータがローカルに保持されている場合)。
- 共有キャッシュ (複数のプロセスやマシンがアクセス可能な共通ソースとして機能します) を使用する。

どちらの場合も、キャッシュすることも (提供するプロセスを実行したクライアント側
ユーザー インターフェイス、web ブラウザやデスクトップ アプリケーションなど、システムの)
サーバ側 (ビジネス サービスを提供するプロセスによって
リモートで実行)。

### プライベート キャッシュ

キャッシュの最も基本的な種類は、アドレスに保持されている、メモリ内ストアです。
1 つのプロセスの領域で実行されるコードから直接アクセスして
このプロセスでは。 この種類のキャッシュが非常に迅速にアクセスするには、
少量を格納するための非常に効果的な戦略を提供します。
キャッシュのサイズと静的データを制限する通常です、
プロセスをホストしているコンピューターで使用可能なメモリの量。 Visual Studio が
詳細については、メモリ内に物理的に指定されていないをキャッシュする必要があります。
ローカル ファイル システムにキャッシュされたデータを記述することができます。 これにより、します。
必ずしももデータがメモリ内に保持されているが、必要がありますへのアクセスに時間がかかります
高速化、ネットワーク経由でデータを取得するよりも信頼性も高くしてあります。

このモデルを使用するアプリケーションの複数のインスタンスがある場合
同時に実行すると、各アプリケーション インスタンスがそれ自体
データのコピーを保持している独立したキャッシュします。

キャッシュの一部を元のデータのスナップショットとして考えないでください。
過去にポイントします。 このデータが静的でない場合です
複数のアプリケーション インスタンスのさまざまなバージョンを保持する、
キャッシュ内のデータ。 これらの操作で実行される同じクエリではこのため、
図 1 に示すように、インスタンスは、異なる結果を返すことができます。

![アプリケーションの複数のインスタンスにおけるメモリ内キャッシュの使用](media/best-practices-caching/Figure1.png)

_Figure 1: application_ の異なるインスタンスにおけるメモリ内キャッシュの使用

### Shared Caching

データの場合、問題の解決に役立つ共有キャッシュを使用します。
メモリ内キャッシュが発生する可能性が、キャッシュごとに異なります。 共有
複数のアプリケーション インスタンスが同じを閲覧できるようにキャッシュ
別の場所にキャッシュを配置することにより、キャッシュされたデータの表示
図 2 に示すように、通常の別のサービスの一部としてホストされます。

![共有キャッシュの使用](media/best-practices-caching/Figure2.png)

_Figure 2: 共有キャッシュの使用

共有のキャッシュ方法を使用する重要な利点は、
スケーラビリティを提供することをおします。 共有キャッシュ サービスの多くは
サーバーのクラスターを使用して実装し、ソフトウェアを活用します。
クラスターにデータを透過的に分散します。 この
アプリケーション インスタンスは、キャッシュ サービスに要求を送信するだけで
基になるインフラストラクチャが判断して、
クラスター内のキャッシュされたデータの場所です。 簡単に拡張できます、
サーバーを追加してキャッシュします。

共有キャッシュの短所のアプローチは、キャッシュ
不要になった保持されているローカルで各ために、アクセスに時間がかかります
アプリケーション インスタンスと、別の実装要件
キャッシュ サービスでは、複雑さをソリューションに追加することがあります。

## キャッシュの使用に関する注意点

次のセクションでさらに詳しく際の考慮事項について説明します。
デザインとキャッシュを使用します。

### データをキャッシュする必要がある時期

キャッシュによって、パフォーマンス、スケーラビリティ、および可用性が大幅に向上します。 多くのデータ
ある、大きい方に、このデータにアクセスする必要があるユーザーの数が多い
待機時間と処理に関連付けられている競合を減らすことでキャッシュの利点
大量の同時要求元のデータを格納します。 たとえば、データベース
限られた数の同時接続ですが共有からのデータの取得をサポートする場合があります。
基になるデータベースではなく、キャッシュを使用すると、このデータにアクセスするクライアント アプリケーション
場合でも、利用可能な接続の数が現在破棄されました。 また場合は、
データベースが利用不可になると、クライアント アプリケーションを使用して続行できる場合があります、
データは、キャッシュ内に保持します。

多くの場合、つまり変更頻度の低い読み取られるデータをキャッシュする必要があります。
(データは、書き込み操作と比べて読み取り操作の大部分があります。) ただし、
重要な情報の権限のあるストアとしてキャッシュを使用する必要があります。必要があります。
すべての変更が失われる、アプリケーションが余裕に常に保存されるようにします。
永続的なデータ ストアです。 この方法でキャッシュを利用できない場合、アプリケーションことができます。
まだデータ ストアを使用して、操作を続行し、重要な失われません
作成します。

### データとキャッシュの作成方法の種類

キャッシュを効果的に使用するキーがあることを最も適切なデータを指定します。
キャッシュ、および適切なタイミングでキャッシュします。 キャッシュにデータを追加することがあります。
必要に応じて、初めてアプリケーションに必要なように、アプリケーションによって取得されます。
ストアおよびそれ以降のアクセスを満足することができます、データから 1 回だけのデータをフェッチします。
キャッシュを使用します。

代わりに、キャッシュが部分的または完全にデータを設定する、事前に
通常アプリケーションを起動 (シード処理と呼ばれるアプローチ) です。 ただし、ことがあります。
このアプローチを適用できるように大きなキャッシュのシード処理を実装することをお勧めはできません。
実行しているアプリケーションの起動時に、元のデータ ストアの急激な高負荷です。

多くの場合、使用パターンの分析が、決定に役立ちますするかどうか完全または部分的に。
キャッシュするデータを選択して、キャッシュを事前に設定します。 たとえば、
静的なユーザー プロファイル データをキャッシュをシードすると便利でしょう
アプリケーションを定期的に (たとえば毎日) を使用しているお客様には
1 週間に 1 回だけのアプリケーションを使用しているお客様です。

通常、キャッシュは、不変または変化するデータに対応します。
頻度の低い。 例として、製品と価格などの参照情報
e コマース アプリケーション、またはコストがかかる共有静的リソース内の情報
構築します。 このデータの一部またはすべてをアプリケーションでキャッシュに読み込むことができます。
リソースに対する負荷を最小限に抑えると、パフォーマンスを向上させるために起動します。 場合もあります。
バック グラウンド プロセスでは適切な定期的に更新する参照データ
最新の状態、またはキャッシュを更新することを確認するキャッシュの参照と
データ変更されます。

キャッシュが変わることで、動的なデータの有用度が低くするいくつかの例外があります。
このに関する考慮事項 (これの後半で非常に動的なデータをキャッシュする」を参照してください。
ガイダンスの詳細) です。 変更すると、元のデータ定期的に、いずれか
キャッシュされた情報をすぐに古くなるや管理のオーバーヘッド
元のデータ ストアと同期して、キャッシュの有効性を軽減します。
キャッシュします。 完全なデータを含めるキャッシュがいないことに注意してください、
エンティティ。 たとえば、データ項目は、銀行などの複数値を持つオブジェクトを表します
顧客名、アドレス、および口座残高が、これらの要素のいくつかの可能性があります。
静的 (名前と住所) 中に他のユーザー (口座残高) など
さらに動的な場合があります。 このような場合、静的なをキャッシュすると便利かもしれません
データの一部のみを取得または計算)、残りの情報
必要な場合です。

パフォーマンス テストと使用状況の分析の実行を決定するかどうか
キャッシュ、または、両方の組み合わせの事前入力またはオンデマンドの読み込み
適しています。 揮発性の組み合わせに基づいて決定する必要があり、
データの使用状況パターンです。 キャッシュの使用率とパフォーマンスを分析します。
特にアプリケーションが大きな負荷が発生する必要があります。
拡張性の高い。 たとえば、拡張性の高いシナリオでことは有効に
ピーク時に、データ ストアへの負荷を減らすためにキャッシュをシードします。

キャッシュもを使用できます、アプリケーションが格納される計算を繰り返し行われないようにするには
実行中です。 操作は、データの変換または複雑な計算を実行する場合
キャッシュ内に操作の結果を保存できます。 場合は、同じ計算
必要なその後、アプリケーションからの結果を取り出すだけで済みます
キャッシュです。

アプリケーションがキャッシュに保持されているデータを変更できますが、する必要がある、
いつでも消える可能性の一時的なデータ ストアとしてキャッシュします。 保存しません。
貴重なデータはキャッシュのみでは、情報を管理することを確認してください。
元データ ストアにもします。 これにより、キャッシュになります
使用できない場合、最小化するデータを失う可能性。

### 非常に動的なデータのキャッシュ

永続的なデータ ストアで迅速に変更を適用できる情報を格納します。
システムのオーバーヘッドが発生します。 たとえば、継続的に報告するデバイス
ステータスがまたはの測定値。 これをキャッシュにないアプリケーションを選択した場合
データをキャッシュされた情報ほぼは常に、古くなったし、単位
同じ検討を格納して、この情報を取得する場合は true にする可能性があります。
データ ストアです。保存し、このデータをフェッチにかかる時間を持つことが
変更します。 次のような場合では、動的に格納する利点を検討してください。
永続的なデータ ストアではなく、キャッシュに直接情報です。 また、
関係ありませんし、データの重要性が低いとを監査する必要のないです。
場合は、不定期の変更は失われます。

### キャッシュ内でのデータの有効期限の管理

ほとんどの場合、キャッシュに保持されているデータは、元のデータに保持されるデータのコピー
保存します。 原因と、キャッシュされて後に、元のデータ ストア内のデータは変更されます。
キャッシュされたデータ古いものになります。 多くのキャッシュ システムでは、構成、
キャッシュ データを期限切れ期間を短縮するデータは古くなる可能性があります。

キャッシュされたデータの有効期限が切れたときに、キャッシュから削除され、アプリケーションにする必要があります。
(さらすことに、新しく取得した元のデータ ストアからデータを取得します。
情報をキャッシュに戻します)。 既定の有効期限ポリシーを設定するときにします。
キャッシュを構成します。 多くのキャッシュ サービスで、有効期限を決定することも
個々 のオブジェクトを保存するときにプログラムを使用して、キャッシュの期間
(一部のキャッシュを有効にすると、絶対値として、有効期間を指定または
ない場合はキャッシュから削除する項目を原因となったスライド式の値として
指定した時間内にアクセスします。 この設定は、キャッシュ全体をオーバーライドします。
指定したオブジェクトについては、有効期限ポリシーです。
> [AZURE.NOTE] キャッシュの有効期限とキャッシュに含まれるオブジェクトを慎重に検討してください。 有効期限を短くしすぎると、オブジェクトはすぐに期限切れになり、キャッシュを使用するメリットが損なわれます。 有効期限を長くしすぎると、データが古くなる危険性があります。

データの維持が許可された場合、キャッシュがいっぱいにこともできます。
長時間にわたって常駐します。 ここでは、いずれかを要求に新しい項目を追加します
キャッシュと呼ばれるプロセスで、強制的に削除するいくつかの項目が発生する可能性があります。
削除します。 キャッシュ サービスが通常に最も最近使った (LRU) 上のデータを削除します。
単位ですが、通常このポリシーを無効にして項目を防止
削除されます。 ただし、このアプローチを採用している場合、リスク、キャッシュを超える、
メモリが、使用可能なアプリケーションをしようとしている項目を追加するには
キャッシュには、例外で失敗します。

キャッシュの実装方法によっては、追加の削除ポリシーを使用できます。 それは、
通常、最近使用ポリシーが含まれます (予想される、
データは必要ありませんもう一度)、(最も古いデータは最初に先出しポリシー
削除されると最初に)、またはトリガーされたイベントに基づく明示的な削除 (など、
データの変更)。

### クライアント側キャッシュ内のデータの無効化

クライアント側のキャッシュに保持されるデータは一般の外部であると見なされます
クライアントにデータを提供するサービスの持ちますサービス
クライアントからの情報を追加または削除を強制的に変更できません、
クライアント側キャッシュです。 つまり、使用するクライアントの可能性があります。
(たとえば、有効期限ポリシーが正しく構成されてキャッシュ
キャッシュされた古くなった情報を使用して引き続き適切に実装)
ローカルで元のデータ ソース内の情報が変更された時期です。

HTTP 経由でデータを提供する web アプリケーションを構築する場合
接続、web クライアントに暗黙的に強制できます (ブラウザーなど、または
web プロキシ)、リソースが更新された場合に、最新の情報を取得するには
そのリソースの URI を変更します。 Web クライアントは通常、URI を使用します。
クライアント側キャッシュ内のキーとしては、リソースの URI を変更するため
により、web クライアントのすべての以前にキャッシュされたバージョンを無視するが、
リソースと、新しいバージョンの代わりにフェッチします。

## キャッシュ内での同時実行の管理

複数のインスタンスで共有するキャッシュは、多くの場合、
想定しています。 各アプリケーション インスタンスの読み取りし、データを変更することができます。
キャッシュです。 その結果、同じ同時実行の問題で発生します。
共有データ ストアは、キャッシュに適用もできます。 状況
アプリケーションがキャッシュに保持されているデータを変更する必要があることがあります。
アプリケーションの 1 つのインスタンスからの更新ができることを確認する必要があります。
別のインスタンスによって行われた変更を無条件に上書きしません。

データとの競合が発生する可能性の性質によっては
同時実行制御の 2 つの方法のいずれかを採用することができます。

- __オプティミスティック同時実行制御。__アプリケーションは、キャッシュ内のデータを更新する直前に、取得後にそのデータが変更されたかどうかを確認します。 データが同じままの場合、変更できます。 それ以外の場合、アプリケーションはこのデータを更新するかどうかを決定する必要があります (この決定の基準になるビジネス ロジックはアプリケーションごとに異なります)。 この方法は、更新が頻繁に行われる状況、または競合が発生する可能性がない状況に適しています。
- __ペシミスティック同時実行制御。__アプリケーションは、キャッシュ内のデータを取得するときにそのデータをロックして、他のインスタンスがそのデータを変更できないようにします。 このプロセスによって競合は起きなくなりますが、同じデータを処理する必要がある他のインスタンスもブロックされる可能性があります。 ペシミスティック同時実行制御は、ソリューションのスケーラビリティに影響をあたえる可能性があるため、一時的な操作にのみ使用するようにする必要があります。 この方法は、競合が発生する可能性が高い状況、特にアプリケーションがキャッシュ内の複数の項目を更新するため、こうした変更が矛盾なく適用されるようにする必要がある場合に適しています。

### 高可用性とスケーラビリティの実装およびパフォーマンスの向上

キャッシュには、データのプライマリ リポジトリがすることはできません。これは、ロールです。
元のデータ ストア、キャッシュが作成されます。 この
永続性を確保するため、元のデータ ストアは、
データです。

可用性に重要な依存関係を導入しないように注意します。
ソリューションの共有キャッシュ サービスです。 アプリケーションにする必要があります。
機能している場合は引き続き、共有キャッシュを提供するサービス
使用できません。アプリケーションのハングもしないで待機中に失敗
キャッシュ サービスを再開します。 そのため、アプリケーションがある必要があります。
キャッシュ サービスの可用性を検出し、切り替えの準備
元のデータを格納、キャッシュがアクセスできない場合。 この
[サーキット ブレーカーのパターン](http://msdn.microsoft.com/library/dn589784.aspx) はこのシナリオを処理するために役立ちます。 この
キャッシュを復旧して、サービスを提供する 1 回になります
使用可能なキャッシュを再設定できるデータには、フォームが読み込まれるとき、
次のように、戦略、元のデータ ストア、 [キャッシュア サイド パターン](http://msdn.microsoft.com/library/dn589799.aspx)します。

ただし、代替で元のデータ ストアにキャッシュがある場合
一時的な使用でのようなスケーラビリティに影響システム
元のデータ ストアを復元中に、データ ストア
タイムアウトになり、データの要求による混乱でしたし、
失敗した接続します。 考慮すべき方法します。
アプリケーションの各インスタンスにローカルなプライベート キャッシュを実装します。
共有と共にキャッシュされるすべてのアプリケーション インスタンス
アクセスします。 最初に確認できますアプリケーションでは、項目を取得するときに
ローカル キャッシュ、共有キャッシュし、最後に、元の
データ ストアです。 ローカル キャッシュの設定は、データを使用して、
共有キャッシュまたは共有キャッシュが使用できない場合は、データベース。
この方法をローカルを防ぐために慎重に構成が必要です。
キャッシュが共有キャッシュと比較して古くなります。
共有キャッシュにアクセスできない場合は、バッファーとして機能します。 図 3
この構造を示しています。

![共有キャッシュとローカルなプライベート キャッシュの併用](media/best-practices-caching/Caching3.png)
_Figure 3: 共有キャッシュとローカルなプライベート キャッシュを使用します。

いくつか有効期間が比較的長いデータを保持する大規模なキャッシュをサポートするために
キャッシュ サービスを実装する高可用性オプションを提供します。
自動フェールオーバー キャッシュが使用できなくなった場合。 このアプローチ
通常は、主に格納されているキャッシュされたデータをレプリケートします。
キャッシュ サーバーをセカンダリ キャッシュ サーバーへの切り替えを
プライマリ サーバーが失敗した場合、セカンダリ サーバーまたは接続が
失われました。 複数への書き込みに関連付けられている待機時間を減らす
プライマリ上のキャッシュにデータが書き込まれたときの宛先
サーバー、セカンダリ サーバーへのレプリケーションが発生します。
非同期的にします。 このアプローチを可能性です。
キャッシュされた情報が、障害発生時に失われる可能性がありますが、
このデータの大部分べき小さな全体と比較して
キャッシュのサイズ。

共有キャッシュのサイズが大きい場合にパーティションと便利なあります、
競合の可能性を低減するノード間でデータをキャッシュし、
スケーラビリティが向上します。 多くの共有キャッシュをサポートする機能
動的に追加 (および削除) のノード間でデータを再調整と
パーティションです。 この方法は、クラスタ リングが含まれる、
ノードのコレクションとしてクライアント アプリケーションに表示される、
シームレスな単一のキャッシュが内部的には、データが分散しています。
次のいくつかのノード間で分散戦略の定義済み
均等に負荷を分散するとします。  [データ パーティション分割のガイダンス資料](http://msdn.microsoft.com/library/dn589795.aspx)
web サイトは、microsoft に関する詳細を提供します。
パーティション分割戦略です。

クラスタ リングもかまいませんさらに、キャッシュの可用性場合は、
ノードに失敗すると、キャッシュの残りの部分はアクセスできます。
クラスタ リングは、レプリケーションと組み合わせて使用は、多くの場合
およびフェールオーバーします。各ノードをレプリケートして、レプリカ
すぐに、ノードが失敗した場合をオンラインにします。

多くの読み取りし、書き込み操作が 1 つのデータが含まれる可能性があります。
値またはオブジェクト。 ただし、ある可能性がある。 場合があります。
格納または大量のデータを迅速に取得するために必要なです。
たとえば、キャッシュをシード書き込む可能性数百または
何千もの項目をキャッシュしたり、アプリケーションが必要になります。
関連項目の数が多いとしてキャッシュから取得します。
同じ要求の一部です。 多くの大規模なキャッシュのバッチを提供します。
これらの目的で、クライアント アプリケーションを有効にするための操作
膨大な量の 1 つの要求にアイテムをパッケージ化し、
多数の実行に伴うオーバーヘッドの削減
小さな要求します。

## キャッシュおよび最終的な整合性

キャッシュア サイド パターンは、アプリケーションのインスタンスに依存します
キャッシュ最新へのアクセスを設定して
データの一貫性のあるバージョンです。 実装する、システム内
(レプリケートされたデータ ストア) などの最終的な一貫性このことがあります。
当てはまるとは限りません。 アプリケーションの 1 つのインスタンスを変更します。
データは、項目し、その項目のキャッシュされたバージョンが無効にします。 もう 1 つ
アプリケーションのインスタンスからこの項目を読み取ろうとする可能性があります。
キャッシュからデータを読み取るようにキャッシュ ミスの原因であり、
データは、格納し、キャッシュに追加します。 ただし、データを格納している場合
他のレプリカと完全に同期されていない、
アプリケーション インスタンスが読み取り、キャッシュから、
古い値。

データの一貫性の処理の詳細については、次を参照してください、。
Microsoft web サイト上のデータ整合性のガイダンスのページです。

### キャッシュされたデータの保護

キャッシュ サービスに関係なく使用すると、考慮する必要があります。
承認されていないからキャッシュに保持されるデータを保護する方法
アクセスします。 次の 2 つの主な懸念事項があります。

- キャッシュ内のデータのプライバシー。
- キャッシュ間のデータのプライバシーの流れと、
  キャッシュを使用するアプリケーションです。

キャッシュ内のデータを保護するのにはキャッシュ サービスを実装可能性があります。
認証メカニズムを必要とするアプリケーション
自身を識別および認証スキーム
id が、キャッシュ内のデータにアクセスできるように指定し、
これらの id がある操作 (読み取りと書き込み)
実行を許可します。 伴うオーバーヘッドを削減するには
id が与えられた後、データの読み書き
id を使用すると、キャッシュへの読み取りアクセスの書き込み/
キャッシュ内のデータです。 アクセスを制限する必要がある場合
キャッシュされたデータのサブセットを実行できます。

- (別のキャッシュを使用して、キャッシュをパーティション分割する.
  サーバー) の id にアクセスのみを許可し、
  パーティションを使用するには許可されている必要がありますか
- 異なるキーを使用して各サブセット内のデータを暗号化します。
  のみ提供される暗号化キーの id を
  各サブセットへのアクセスが必要です。 クライアント アプリケーション
  すべてのキャッシュにデータを取得できない可能性があります。
  そこにデータを復号化できるが、
  キーがあります。

データを保護するには、フロー、キャッシュに出入りします。
ネットワークによって提供されるセキュリティ機能に依存しています。
インフラストラクチャに接続するクライアント アプリケーションで使用される、
キャッシュします。 オンサイト サーバーを使用して、キャッシュが実装された場合
クライアント アプリケーションをホストする同じ組織内で
ネットワーク自体の分離しないする必要があります。
追加の手順を実行します。 キャッシュがリモートである場合、
(このようなパブリック ネットワーク経由で TCP または HTTP 接続が必要です。
インターネット上の) としては、SSL の実装を検討してください。

## Microsoft Azure でのキャッシュの実装に関する考慮事項

Azure は、Azure Redis Cache を提供します。 これは、実装
open のソースの Redis Cache でのサービスとして実行される、
Azure データ センターです。 可能なキャッシュ サービスを提供します。
あらゆる Azure アプリケーションからのアクセスをするかどうか、アプリケーション
クラウド サービス、web サイト、または内部として実装します。
Azure の仮想マシン。 クライアントでキャッシュを共有できます。
適切なアクセス キーがあるアプリケーション。

Redis は高パフォーマンスのキャッシュ ソリューションを提供します。
可用性、スケーラビリティ、およびセキュリティ 通常実行されます。
サービスとしては、1 つまたは複数の専用コンピューターに分散し、
メモリ内に可能な限り多くの情報を保存しようとしています。
高速アクセスを確認します。 このアーキテクチャの目的は、提供するには
低遅延と高いスループットを減らすために、
低速な I/O 操作を実行します。

Azure Redis cache は、多くのさまざまなとの互換性
クライアント アプリケーションで使用される Api です。 既に存在する場合
既にオンプレミスで実行して、Redis を使用するアプリケーション、
Azure Redis キャッシュのキャッシュへのクイック移行パスを提供します。
で、クラウドになります。
> [AZURE.NOTE] Azure では、Managed Cache Service も提供します。 この
  サービスは Microsoft AppFabric Cache エンジンに基づいています。 その方法は
  共有できる分散キャッシュを作成することができます。
  疎結合アプリケーション。 キャッシュがホストされています。
  高パフォーマンス サーバーが、Azure データ センターで実行されています。
  ただし、このオプションは推奨されなく、のみ
  組み込まれている既存のアプリケーションをサポートするために提供されます。
  これを使用します。 すべての新しい開発 Azure Redis を使用してください。
  代わりにキャッシュします。
>
> さらに、Azure はロール内キャッシュをサポートします。 この機能
  クラウド サービスに固有のキャッシュを作成できます。
  キャッシュは、web またはワーカー ロールのインスタンスでホストし、
  同じの一部として動作しているロールによってのみアクセスできます。
  (デプロイメント ユニットは、一連のクラウド サービスの展開ユニット
  特定のクラウド サービスとしてデプロイされたロール インスタンスの
  リージョン)。 キャッシュがクラスター化されているとのすべてのインスタンス、
  キャッシュをホストする同じデプロイメント ユニット内のロール
  同じキャッシュ クラスターの一部になります。 既存のアプリケーション
  ロール内キャッシュを使用するためには続行できますが、
  Azure Redis Cache に移行すると、複数のメリットをもたらします可能性があります。
  詳細については、Azure Redis Cache を使用するかどうか
  または、ロール内キャッシュ、ページを参照してください
  [どの Azure Cache を利用に最適な?](http://msdn.microsoft.com/library/azure/dn766201.aspx) 、Microsoft web サイトです。


### Redis の機能

Redis はより単純なキャッシュ サーバーです。分散型メモリ内の提供します。
多くの一般的なシナリオをサポートする広範なコマンド セットを持つデータベース
ユース ケースのセクションで説明した Redis これで後でのキャッシュ
ドキュメントを参照してください。 このセクションでは、Redis を主な機能の一部をまとめたもの
提供します。

### メモリ内データベースとしての Redis

Redis は、読み取りと書き込みの両方をサポートします。 (一時的なデータ ストアとみなす必要がある) 多くのキャッシュとは異なり、書き込み内容は、ローカルのスナップショット ファイルまたは追加専用のログ ファイルに定期的に保存することで、システムの故障から保護することができます。 すべての書き込みは非同期であり、クライアントによるデータの読み取りと書き込みをブロックしません。 Redis の実行を開始すると、スナップショットまたはログ ファイルからデータを読み取り、そのデータを使用してメモリ内キャッシュを構築します。 詳細については、次を参照してください。 [Redis の永続化](http://redis.io/topics/persistence) Redis web サイトです。
> [AZURE.NOTE] Redis では、イベント内のすべての書き込みが保存されることは保証されません。
  重大なエラーが、最悪の事態にはいくつかの秒数が失われることのみ必要があります。
  分のデータです。 キャッシュとして機能するものではありませんに注意してください、
  権限のあるデータ ソース、およびそのアプリケーションの役割は、します。
  正常に保存は、重要なデータ キャッシュを使用して、
  適切なデータ ストアです。 詳細については、「キャッシュアサイド パターン」を参照してください。

#### Redis データ型

Redis はキー値ストアであり、値には単純な型や、ハッシュ、リスト、およびセットなどの複雑なデータ構造を含めることができます。 Redis は、このようなデータ型に対する一連のアトミック操作をサポートしています。 キーは永続的なものにすることも、キーとその対応する値が自動的にキャッシュから削除される制限時間を指定することもできます。 Redis のキーと値の詳細については、ページを参照してください。 [An Introduction to Redis データ型と抽象化](http://redis.io/topics/data-types-intro) Redis web サイトです。

#### Redis のレプリケーションとクラスタリング

Redis は、可用性を確保しつつスループットを維持するために、マスターと下位のレプリケーションをサポートしています。Redis マスター ノードへの書き込み操作は 1 つまたは複数の下位ノードにレプリケートされ、読み取り操作はマスター ノードまたはいずれかの下位ノードで処理することができます。 ネットワーク パーティションが発生した場合、下位ノードはデータの処理を継続してから、接続が再度確立されたときにマスターと透過的に再同期することができます。 詳細については、次を参照してください。、 [レプリケーション](http://redis.io/topics/replication) Redis web サイトのページです。

Redis ではクラスタリングも提供されるため、サーバー間のシャードにデータを透過的に分割して、負荷を分散することができます。 この機能によって、キャッシュのサイズの増加に合わせて新しい Redis サーバーを追加し、データを再分割することができるため、スケーラビリティが向上します。 さらに、マスターと下位のレプリケーションを使用し、クラスター内の各ノード間の可用性を確保して、クラスター内の各サーバーをレプリケートすることができます。 クラスタ リングとシャーディングの詳細については、次を参照してください。、 [Redis クラスター チュートリアル ページ](http://redis.io/topics/cluster-tutorial) Redis web サイトです。
> [AZURE.NOTE] 現在、Azure Redis Cache ではクラスタリングをサポートしていません。 Redis クラスターを作成する場合は、独自のカスタム Redis サーバーを構築できます。 詳細については、このドキュメントの後半の「カスタム Redis キャッシュの構築」セクションを参照してください。

### Redis のメモリ使用量

Redis キャッシュのサイズは、ホスト コンピューターで使用可能なリソースによって制限されます。 Redis サーバーを構成するときに、使用できるメモリの最大量を指定できます。 Redis キャッシュ内のキーには有効時間を設定することができ、この時間を過ぎるとキーがキャッシュから自動的に削除されます。 この機能によって、古いまたは最新でなくなったデータでメモリ内キャッシュが埋め尽くされるのを防ぐことができます。

メモリが上限に達すると、Redis は多くのポリシーに従ってキーとその値を自動的に削除します。 既定値は LRU (最も最近使用されていない) ですが、キーのランダムな削除や、削除をすべて無効化する (この場合、キャッシュがいっぱいになるとキャッシュに項目を追加する試行は失敗します) など、他のポリシーも選択することができます。 ページ [LRU キャッシュとしての Redis を使用して](http://redis.io/topics/lru-cache) 詳しく説明します。

### Redis のトランザクションとバッチ

Redis では、クライアント アプリケーションは、キャッシュ内のデータの読み取りおよび書き込みを行う一連の操作を、アトミック トランザクションとして送信することができます。 トランザクション内のすべてのコマンドは必ず順番に実行され、他の同時実行クライアントにより発行されたコマンドがそれらに混ざることはありません。 ただし、これらは正確にはトランザクションではなく、リレーショナル データベースが一連の操作を実行しています。 トランザクション処理には、コマンド キューとコマンド実行の 2 つの段階があります。 コマンド キューの段階では、トランザクションに含まれるコマンドがクライアントによって送信されます。 この時点でなんらかのエラー (構文エラー、不正な数のパラメーターなど) が発生すると、Redis はトランザクション全体の処理を拒否して、廃棄します。 実行フェーズでは、Redis はシーケンス内の各キューに登録されたコマンドを実行します。 このフェーズでコマンドが失敗した場合、Redis は次のキューに登録されたコマンドの実行を継続しますが、すでに実行されたコマンドの影響をロール バックすることはありません。 このように簡略化された形式のトランザクションにより、パフォーマンスを維持して、競合によって生じるパフォーマンスの問題を回避することができます。 Redis は、一貫性の維持を支援するオプティミスティック同時実行制御の形式を実装しています。 トランザクションとロック Redis を使用する方法の詳細についてを参照してください、 [トランザクション] ページの](http://redis.io/topics/transactions) Redis web サイトです。

Redis では、要求の非トランザクション バッチ処理もサポートされています。 Redis サーバーへのコマンドの送信にクライアントが使用する Redis プロトコルにより、クライアントは同じ要求の一部として一連の操作を送信することができます。 これにより、ネットワーク上でのパケットの断片化を抑えることができます。 バッチが処理されると、各コマンドが実行されます。 トランザクションとは異なり、いずれかのコマンドの形式が不正である場合、それらは拒否されますが、残りのコマンドは実行されます。 また、バッチ内のコマンドが処理される順番は保証されません。

### Redis のセキュリティ

Redis ではデータへの高速アクセスを実現することのみに重点が置かれており、信頼された環境内で実行され、信頼されたクライアントのみがアクセスするように設計されています。 Redis では、パスワード認証に基づいた限定的なセキュリティ モデルだけがサポートされています (認証を完全に削除することもできますが、これは推奨されません)。 すべての認証されたクライアントは同じグローバル パスワードを共有し、同じリソースにアクセスできます。 より包括的なログイン セキュリティが必要な場合には、Redis サーバーの前に独自のセキュリティ層を実装し、すべてのクライアントの要求がこの追加した層を通過するようにする必要があります。Redis を、信頼されていないクライアントまたは認証されていないクライアントに直接公開しないでください。

コマンドを無効化するか、その名前を変更して (および特権のあるクライアントにだけ新しい名前を提供して)、コマンドへのアクセスを制限することができます。

Redis ではデータの暗号化形式は直接的にサポートされていないため、すべてのエンコードはクライアント アプリケーションが実行する必要があります。 さらに、Redis ではトランスポート セキュリティが提供されないため、ネットワーク内を流れるデータを保護する必要がある場合には、SSL プロキシを実装する必要があります。

詳細については、次を参照してください。、 [Redis のセキュリティ](http://redis.io/topics/security) Redis web サイトのページです。
> [AZURE.NOTE] Azure Redis Cache; クライアントが接続を経由する独自のセキュリティ レイヤーを提供します。基になる Redis
  サーバーは、パブリック ネットワークには公開されません。

### Azure Redis Cache の使用

Azure Redis Cache は、Azure データセンターでホストされたサーバーで実行されている Redis サーバーへのアクセスを提供し、アクセス制御とセキュリティを提供するファサードとして機能します。 Microsoft Azure 管理ポータルを使用して、キャッシュをプロビジョニングすることができます。 このポータルには、SSL 通信 (プライバシー用) と、99.9% の可用性を持つ SLA とのマスター/下位のレプリケーションをサポートする専用サービスとして実行される 53 GB キャッシュから、共有ハードウェア上で実行される、レプリケーションを持たない (可用性の保証がない) 250 MB キャッシュまで、数多くの定義済み設定があります。

Microsoft Azure 管理ポータルを使用する場合、キャッシュの削除ポリシーを設定したり、提供されるロール (所有者、共同作業者、閲覧者) にユーザーを追加することでキャッシュへのアクセスを制御したりすることができます。 これらのロールは、メンバーが実行できる操作を定義します。 たとえば、所有者ロールのメンバーは、キャッシュ (セキュリティを含む) とその内容を完全に制御することができ、共同作業者ロールのメンバーはキャッシュ内の情報の読み取りおよび書き込みを行うことができ、閲覧者ロールのメンバーはキャッシュからのデータの取得だけが可能です。

ほとんどの管理タスクは Microsoft Azure 管理ポータルから実行します。このため、プログラムを使用した設定の変更機能、Redis サーバーのシャットダウン機能、追加スレーブの設定機能、またはディスクへのデータの保存機能など、標準バージョンの Redis で使用可能な管理コマンドの多くは使用できません。

Microsoft Azure 管理ポータルには、キャッシュのパフォーマンスを監視できるようにする、便利なグラフィカル表示が含まれています。 たとえば、確立されている接続の数、実行された要求の数、読み込みおよび書き込みの量、キャッシュ ミスに対するキャッシュ ヒットの数を確認できます。 この情報を使用してキャッシュの有効性を判断し、必要に応じて、別の構成に切り替えるか、削除ポリシーを変更することができます。 さらに、1 つ以上の重要な指標が想定される範囲を超えた場合に管理者に電子メール メッセージを送信する、アラートを作成することもできます。 たとえば、過去 1 時間でキャッシュ ミスの数が指定された値を上回った場合、キャッシュが小さすぎるかデータの削除が早すぎるというアラートを、管理者に送ることができます。

CPU、メモリ、およびキャッシュのネットワーク使用率を監視することもできます。
> [AZURE.NOTE] Azure Redis Cache は、データベースではなく、単なるキャッシュとして機能するように設計されています。 したがって、現在は Redis の永続性を実装していません。

詳しい情報と作成して Azure Redis Cache を構成する方法の例では、ページを参照して [Azure Redis Cache に関する説明](http://azure.microsoft.com/blog/2014/06/04/lap-around-azure-redis-cache-preview/) Azure ブログのです。

## セッション状態と HTML 出力のキャッシュ

Azure の Web ロールを使用して実行される ASP.NET Web アプリケーションを構築する場合、セッション状態の情報と HTML 出力を Azure Redis Cache 内に保存することができます。 Azure Redis Cache 用のセッション状態プロバイダーを使用すると、ASP.NET Web アプリケーションの複数のインスタンス間でセッション情報を共有できます。これは、クライアント サーバーのアフィニティを使用できず、メモリ内のセッション データをキャッシュするのに適切でない Web ファームの状況で役立ちます。

セッション状態プロバイダーを Azure Redis Cache と併用すると、次のようないくつかのメリットが得られます。

- ASP.NET Web アプリケーションの多数のインスタンス間でセッション状態を共有できるので、スケーラビリティが向上します。
- 複数のリーダーと単一のライターによる、同じセッション状態データへの制御された同時アクセスをサポートします。
- 圧縮を使用してメモリを節約し、ネットワーク パフォーマンスを改善できます。

詳細については、次を参照してください。、 [Azure Redis Cache 用の ASP.NET セッション状態プロバイダー](http://msdn.microsoft.com/library/azure/dn690522.aspx) 、Microsoft web サイトのページです。
> [AZURE.NOTE] Azure 環境の外で実行される ASP.NET アプリケーションには、Azure Redis Cache 用のセッション状態プロバイダーを使用しないでください。 Azure の外部からのキャッシュへのアクセスで発生する待機時間によって、データをキャッシュするパフォーマンスの利点が失われる可能性があります。

同様に、Azure Redis Cache 用の出力キャッシュ プロバイダーを使用すると、ASP.NET Web アプリケーションによって生成される HTTP 応答を削減できます。 出力キャッシュ プロバイダーと Azure Redis Cache を併用すると、複雑な HTML 出力を表示するアプリケーションの応答時間を改善することができます。似たような応答を生成するアプリケーション インスタンスは、このような HTML 出力を新たに生成するのではなく、キャッシュ内の共有出力フラグメントを活用できます。 詳細については、次を参照してください。、 [Azure Redis Cache 用の ASP.NET 出力キャッシュ プロバイダー](http://msdn.microsoft.com/library/azure/dn798898.aspx) 、Microsoft web サイトのページです。

## カスタムの Redis キャッシュの構築

Azure Redis キャッシュは、基になる Redis サーバーに対するファサードとして機能します。 現在は、構成の固定セットがサポートされていますが、Redis クラスタリング用の構成は提供されていません。 Azure Redis Cache の対象ではない高度な構成 (53 GB を超えるキャッシュなど) が必要な場合は、Azure 仮想マシンを使用して独自の Redis サーバーを構築し、ホストできます。 このプロセスは、レプリケーションを実装する場合にマスター ノードと下位ノードとして機能する複数の VM を作成する必要があるため、複雑になる可能性があります。 さらに、クラスターを作成する場合は、複数のマスター サーバーと下位サーバーが必要になります。高度な可用性とスケーラビリティを実現する、最小限にクラスター化されたレプリケーション トポロジは、3 組のマスター/下位サーバーとして編成した少なくとも 6 台の VM で構成されます (1 つのクラスターには少なくとも 3 つのマスター ノードが必要です)。 各マスター/下位の組は、待機時間を最小限に抑えるために近接して配置する必要があります。ただし、キャッシュされたデータを、そのデータを使用する可能性が最も高いアプリケーションの近くに配置する場合は、異なるリージョンに置かれた別々の Azure データセンターで各組のセットを実行することができます。 ページ [Azure の CentOS Linux VM で Redis を実行している](http://blogs.msdn.com/b/tconte/archive/2012/06/08/running-redis-on-a-centos-linux-vm-in-windows-azure.aspx) 、microsoft web サイトをビルドして、Azure VM として実行される Redis ノードを構成する方法を示すサンプルについて説明します。

この方法で独自の Redis キャッシュを実装する場合、サービスを監視、管理、および保護する責任があることに注意してください。

## Redis キャッシュのパーティション分割

キャッシュのパーティション分割では、複数のコンピューター間にキャッシュを分割します。 この構造では、1 つのキャッシュ サーバーを使用することに比べて、次のような複数の利点があります。

- 1 つのサーバーに保存できるサイズよりもはるかに大きなキャッシュを作成できます。
- サーバー間でデータを配布することで、可用性を向上できます。 1 つのサーバーで障害が発生するかアクセスできなくなった場合でも、使用できなくなるのはそのサーバーが保持しているデータだけであり、残りのサーバー上のデータにはアクセスできます。 キャッシュにとってこれは重要なことではありません。キャッシュ データはデータベースに保持されているデータの一時的なコピーにすぎず、アクセスできなくなったサーバー上のキャッシュ データは代わりに別のサーバーにキャッシュできるからです。
- サーバー間で負荷を分散することで、パフォーマンスとスケーラビリティが向上します。
- 位置情報データを基にアクセスしたユーザーに近づき、待ち時間を短縮します。

キャッシュの最も一般的なパーティション分割の形態はシャーディングです。 この方法では、各パーティション (シャード) はそれ自体の Redis キャッシュです。 データは、シャーディング ロジックを使用して特定のパーティションに送られます。シャーディング ロジックではさまざまな方法を使用してデータを配布できます。  [シャーディング パターン](http://msdn.microsoft.com/library/dn589797.aspx) シャーディングの実装について詳しく説明します。

Redis キャッシュでパーティション分割を実装するには、次の方法のいずれかを採用します。

- サーバー側でクエリをルーティングしますこの方法で _、クライアント アプリケーションに要求を送信のいずれか、。
  Redis キャッシュ (おそらくは最も近いサーバー) を構成するサーバー。 各 Redis サーバーに保管します。
  保持していると、に関する情報も含まれますが、パーティションを記述するメタデータ
  パーティションは、他のサーバーに配置されます。 Redis サーバーがクライアント要求を評価し、
  解決できるローカルで、操作を実行する要求された、それ以外の場合は、転送、
  適切なサーバーにログオンを要求します。 このモデルは Redis クラスタ リングによって実装され、は
  さらに詳しく説明されている、 [Redis クラスター チュートリアル](http://redis.io/topics/cluster-tutorial) Redis web サイトのページです。 Redis クラスタ リング
  クライアント アプリケーション、およびその他の Redis サーバーをクラスターに追加するのには透過的
  (および再パーティション分割されたデータ)、クライアントを再構成することを必要とせずします。
  > [AZURE.IMPORTANT] 現在、Azure Redis Cache と Redis クラスタリングは併用できません。 する場合
  このアプローチを実装し、既に説明したようにカスタムの Redis キャッシュを構築する必要があります。

- _ 側でパーティション分割します。 このモデルでは、クライアント アプリケーションで _ には、(おそらくのロジックが含まれています。
  ライブラリの形式) のルートを適切な Redis サーバーに要求することです。 このアプローチ
  Azure Redis キャッシュで使用できます。複数の Azure Redis Cache (各データに対して 1 つを作成します。
  パーティション) を適切な要求をルーティングするクライアント側ロジックを実装
  キャッシュします。 (追加の Azure Redis Cache を作成する場合、パーティション分割構成が変更された場合
  たとえば、) クライアント アプリケーションは、再構成する必要があります。

- パーティション分割 (_p). 支援しますこのスキームで _、クライアント アプリケーションの要求を送信、。
  中間プロキシ サービス、データを分割する方法を理解して、ルート
  適切な Redis サーバーに要求します。 この方法は、Azure でも使用できます。
  Redis Cache。プロキシ サービスは、Azure クラウド サービスとして実装できます。 この
  方法には、追加、サービスの実装の複雑さのレベルが必要があり、
  要求は、クライアント側でパーティション分割を使用するよりも長くかかる場合があります。

ページ [パーティション分割: 複数の Redis インスタンス間でデータを分割する方法](http://redis.io/topics/partitioning)
Redis では、web サイトは、Redis でパーティション分割の実装に関する詳細情報を提供します。

### Redis キャッシュ クライアント アプリケーションの実装

Redis は、さまざまなプログラミング言語で記述されたクライアント アプリケーションをサポートします。 .NET Framework を使用して新しいアプリケーションを作成する場合は、StackExchange.Redis クライアント ライブラリを使用する方法をお勧めします。 このライブラリは Redis サーバーへの接続、コマンドの送信、および応答の受信の詳細を抽象化する .NET Framework のオブジェクト モデルを提供します。 このライブラリは NuGet パッケージとして Visual Studio で入手できます。 この同じライブラリを使用すると、Azure Redis Cache または VM でホストされているカスタムの Redis キャッシュに接続することができます。

Redis サーバーへ接続するには、静的なを使用する `接続` のメソッド、 `ConnectionMultiplexer` クラスです。 このメソッドで作成される接続は、クライアント アプリケーションの有効期間を通して使用するように設計されているため、複数の同時実行スレッドで同じ接続を使用できます。パフォーマンスが低下する可能性があるので、Redis 操作を実行するたびに再接続/切断しないでください。 Redis ホストのアドレスやパスワードなどの接続パラメーターを指定できます。 Azure Redis Cache を使用している場合、このパスワードは、Microsoft Azure 管理ポータルを使用して Azure Redis Cache 用に生成されたプライマリまたはセカンダリ キーになります。

Redis サーバーに接続すると、キャッシュとして機能する Redis データベースを操作できます。 Redis 接続が提供する、 `GetDatabase` これを行うメソッドです。 キャッシュから項目を取得しを使用してキャッシュにデータを格納できる、 `StringGet` と `StringSet` メソッドです。 これらのメソッドをパラメーターとしてキーの予想し、一致する値を持つキャッシュに項目が返されるか (`StringGet`) このキーを使用してキャッシュに項目を追加または (`StringSet`)。

Redis サーバーの場所によっては、多くの操作で、要求がサーバーに転送され応答がクライアントに返されるまでの待機時間が発生する可能性があります。 StackExchange ライブラリには、クライアント アプリケーションの応答性を保つために公開されている、非同期バージョンのメソッドが多数あります。 これらのメソッドをサポート、 [タスク ベースの非同期パターン](http://msdn.microsoft.com/library/hh873175.aspx) .NET Framework にします。

次のコード スニペットは、という名前のメソッドを示しています。 `RetrieveItem` Redis と StackExchange ライブラリに基づくキャッシュア サイド パターンの実装の例です。 メソッドを選択して文字列のキー値が呼び出すことによって Redis キャッシュから対応する項目を取得しようとしています、 `StringGetAsync` メソッド (非同期バージョンの `StringGet`)。 場合は、項目が見つかっていませんが、基になるデータ ソースを使用して、フェッチ、 `GetItemFromDataSourceAsync` メソッドは、ローカル メソッドであり StackExchange ライブラリの一部ではない) を使用してキャッシュに追加し、 `StringSetAsync` メソッドを取得するより迅速に次回ようにします。

```csharp
// Connect to the Azure Redis cache
ConfigurationOptions config = new ConfigurationOptions();
config.EndPoints.Add("<your DNS name>.redis.cache.windows.net");
config.Password = "<Redis cache key from management portal>";
ConnectionMultiplexer redisHostConnection = ConnectionMultiplexer.Connect(config);
IDatabase cache = redisHostConnection.GetDatabase();
...
private async Task<string> RetrieveItem(string itemKey)
{
    // Attempt to retrieve the item from the Redis cache
    string itemValue = await cache.StringGetAsync(itemKey);

    // If the value returned is null, the item was not found in the cache
    // So retrieve the item from the data source and add it to the cache
    if (itemValue == null)
    {
        itemValue = await GetItemFromDataSourceAsync(itemKey);
        await cache.StringSetAsync(itemKey, itemValue);
    }

    // Return the item
    return itemValue;
}
```

`StringGet` と `StringSet` メソッドが取得および文字列の値を格納するためだけではありません。 バイト配列としてシリアル化された任意の項目になることができます。 .NET オブジェクトを保存する必要がある場合は、バイト ストリームとしてシリアル化し、StringSet メソッドを使用してキャッシュに書き込むことができます。 同様に、StringGet メソッドを使用してキャッシュからオブジェクトを読み取り、.NET オブジェクトとして逆シリアル化できます。 次のコードは、IDatabase インターフェイスの拡張メソッドのセット (Redis 接続の GetDatabase メソッドが戻る、 `IDatabase` オブジェクト)、およびこれらのメソッドを使用してキャッシュに BlogPost オブジェクトを読み書きするいくつかのサンプル コード。

```csharp
public static class RedisCacheExtensions
{
    public static async Task<T> GetAsync<T>(this IDatabase cache, string key)
    {
        return Deserialize<T>(await cache.StringGetAsync(key));
    }

    public static async Task<object> GetAsync(this IDatabase cache, string key)
    {
        return Deserialize<object>(await cache.StringGetAsync(key));
    }

    public static async Task SetAsync(this IDatabase cache, string key, object value)
    {
        await cache.StringSetAsync(key, Serialize(value));
    }

    static byte[] Serialize(object o)
    {
        byte[] objectDataAsStream = null;

        if (o != null)
        {
            BinaryFormatter binaryFormatter = new BinaryFormatter();
            using (MemoryStream memoryStream = new MemoryStream())
            {
                binaryFormatter.Serialize(memoryStream, o);
                objectDataAsStream = memoryStream.ToArray();
            }
        }

        return objectDataAsStream;
    }

    static T Deserialize<T>(byte[] stream)
    {
        T result = default(T);

        if (stream != null)
        {
            BinaryFormatter binaryFormatter = new BinaryFormatter();
            using (MemoryStream memoryStream = new MemoryStream(stream))
            {
                result = (T)binaryFormatter.Deserialize(memoryStream);
            }
        }

        return result;
    }
}
```

次のコードは、という名前のメソッドを示しています。 `RetrieveBlogPost` これらの拡張メソッドを使用して、読み書き可能なシリアル化できるを `BlogPost` キャッシュア サイド パターンに従ってキャッシュするオブジェクト。

```csharp
// The BlogPost type
[Serializable]
private class BlogPost
{
    private HashSet<string> tags = new HashSet<string>();

    public BlogPost(int id, string title, int score, IEnumerable<string> tags)
    {
        this.Id = id;
        this.Title = title;
        this.Score = score;
        this.tags = new HashSet<string>(tags);
    }

    public int Id { get; set; }
    public string Title { get; set; }
    public int Score { get; set; }
    public ICollection<string> Tags { get { return this.tags; } }
}
...
private async Task<BlogPost> RetrieveBlogPost(string blogPostKey)
{
    BlogPost blogPost = await cache.GetAsync<BlogPost>(blogPostKey);
    if (blogPost == null)
    {
        blogPost = await GetBlogPostFromDataSourceAsync(blogPostKey);
        await cache.SetAsync(blogPostKey, blogPost);
    }

    return blogPost;
}
```

Redis は、クライアント アプリケーションが複数の非同期要求を送信する場合のコマンド パイプライン処理をサポートします。 Redis は、厳密な順序でコマンドを受信して応答するのではなく、同じ接続を使用して要求を多重化できます。 この方法では、ネットワークの使用効率を高めて待機時間を短縮できます。 次のコード スニペットに、同時に 2 人の顧客の詳細を取得する例を示します。 このコードは、2 つの要求を送信後、結果の受信を待機する前に他の処理 (ここでは示されていません) を実行します。 キャッシュ オブジェクトの Wait メソッドは、.NET Framework の Task.Wait メソッドに似ています。

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
var task1 = cache.StringGetAsync("customer:1");
var task2 = cache.StringGetAsync("customer:2");
...
var customer1 = cache.Wait(task1);
var customer2 = cache.Wait(task2);
```

ページ [Azure Redis Cache の開発](http://msdn.microsoft.com/library/azure/dn690520.aspx) 、microsoft web サイトが Azure Redis cache を使用するクライアント アプリケーションを作成する方法に関する詳細を提供します。 詳細については、 [基本的な使用状況] ページ](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/Basics.md) StackExchange.Redis の web サイトで、ページの [パイプラインと Multiplexers](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/PipelinesMultiplexers.md) 、同じ web サイトの詳細については、非同期操作と Redis と StackExchange ライブラリでパイプライン処理を提供します。 このガイダンス後半の「Redis キャッシュのユースケース」セクションで、Redis キャッシュに保持されているデータに適用できる、より高度な手法の例をいくつか示します。

## Redis キャッシュのユースケース

(これは本質的にはバイト配列を文字列として扱うことです) のキー/値ペアの値が任意のバイナリ データを含めることができる任意の長さの解釈なしの文字列を格納する問題をキャッシュに Redis の最も簡単な使用します。 このシナリオは、このガイダンス前半の「Redis キャッシュ クライアント アプリケーションの実装」セクションで説明しました。 解釈されていないデータはキーにも含まれるため、任意のバイナリ情報をキーとして使用できます。ただし、キーが長くなればなるほど格納に必要な領域は大きくなり、参照操作の実行時間も長くなることに注意する必要があります。 使いやすさと保守のしやすさを考慮して、キースペースは慎重に設計し、意味のある (しかし冗長ではない) キーを使用してください。 たとえば ID が 100 の顧客のキーを表す場合は、単純に “100” とするのではなく、“customer:100” のような構造化されたキーを使用します。 このような設定にすると、さまざまなデータ型を格納する複数の値を簡単に区別することができます。 たとえば ID が 100 の注文のキーを表すために、キー “orders:100” を使用することもできます。

Redis のキー/値のペアの値には、1 次元のバイナリ文字列以外にも、リスト、セット (並べ替えあり、並べ替えなし)、ハッシュなどのより構造化された情報も格納できます。 Redis には、これらの型を操作できる包括的なコマンド セットが用意されています。これらのコマンドの多くは StackExchange などのクライアント ライブラリを介して .NET Framework アプリケーションで使用できます。 ページ [Redis データ型と抽象化の概要を](http://redis.io/topics/data-types-intro) 、Redis の web サイトがこれらの型と操作に使用できるコマンドのより詳細な概要を提供します。

このセクションでは、これらのデータ型とコマンドの一般的なユースケースをいくつか示します。

### アトミック操作とバッチ操作の実行

Redis は、文字列値を取得および設定する一連のアトミック操作をサポートします。 これらの操作が別の使用時に発生する可能性がある可能性のある競合状態によるハザードを削除する `取得` と `設定` コマンドです。 次のような操作を実行できます。

- `INCR`, 、`INCRBY`, 、`DECR`, 、および `DECRBY` のインクリメントおよびデクリメントするアトミック操作を実行します。
  整数データ値。 StackExchange ライブラリのオーバー ロードされたバージョンには、
  `IDatabase.StringIncrementAsync` と `IDatabase.StringDecrementAsync` を実行するメソッド
  これらの操作と、キャッシュに格納されている結果として得られる値が返されます。 次のコードは、
  これらのメソッドを使用する方法を示しています。

  ```csharp
  ConnectionMultiplexer redisHostConnection = ...;
  IDatabase cache = redisHostConnection.GetDatabase();
  ...
  await cache.StringSetAsync("data:counter", 99);
  ...
  long oldValue = await cache.StringIncrementAsync("data:counter");
  // Increment by 1 (the default)
  // oldValue should be 100

  long newValue = await cache.StringDecrementAsync("data:counter", 50);
  // Decrement by 50
  // newValue should be 50
  ```

- `GETSET` キーに関連付けられている値を取得し、新しい値に変更します。 この
  StackExchange ライブラリでは、この操作を通じて、 `IDatabase.StringGetSetAsync`
  メソッドを呼び出します。 以下のコード スニペットに、このメソッドの例を示します。 このコードは、現在を返します。
  値が"データ: counter"前の例からのキーに関連付けられているし、値にリセット
  このキーを同じ操作の一部としてすべてゼロにするには。

  ```csharp
  ConnectionMultiplexer redisHostConnection = ...;
  IDatabase cache = redisHostConnection.GetDatabase();
  ...
  string oldValue = await cache.StringGetSetAsync("data:counter", 0);
  ```

- `MGET` と `MSET`, を返すか、単一の操作として文字列値のセットを変更します。 この
  `IDatabase.StringGetAsync` と `IDatabase.StringSetAsync` をサポートするメソッドはオーバー ロード
  この機能は、次の例で示すようにします。

  ```csharp
  ConnectionMultiplexer redisHostConnection = ...;
  IDatabase cache = redisHostConnection.GetDatabase();
  ...
  // Create a list of key/value pairs
  var keysAndValues =
      new List<KeyValuePair<RedisKey, RedisValue>>()
      {
          new KeyValuePair<RedisKey, RedisValue>("data:key1", "value1"),
          new KeyValuePair<RedisKey, RedisValue>("data:key99", "value2"),
          new KeyValuePair<RedisKey, RedisValue>("data:key322", "value3")
      };

  // Store the list of key/value pairs in the cache
  cache.StringSet(keysAndValues.ToArray());
  ...
  // Find all values that match a list of keys
  RedisKey[] keys = { "data:key1", "data:key99", "data:key322"};
  RedisValue[] values = null;
  values = cache.StringGet(keys);
  // values should contain { "value1", "value2", "value3" }
  ```

このガイダンスの「Redis のトランザクションとバッチ」セクションで説明されているように、複数の操作を組み合わせて 1 つの Redis トランザクションにすることもできます。 StackExchange ライブラリを使用したトランザクションのサポートには、 `ITransaction` インターフェイスです。 IDatabase.CreateTransaction メソッドを使用して ITransaction オブジェクトを作成して提供されるメソッドを使用して、トランザクションにコマンドを呼び出す `ITransaction` オブジェクトです。  `ITransaction` インターフェイスは類似した一連のメソッドへのアクセスを提供、 `IDatabase` インターフェイスを除くすべてのメソッドは非同期です。 はしか実行、 `ITransaction.Execute` メソッドが呼び出されます。 Execute メソッドから返される値は、トランザクションが正常に作成されたか (true) 作成に失敗したか (false) を示します。

次のコード スニペットに、同じトランザクションの中で 2 つのカウンターをインクリメントおよびデクリメントする例を示します。

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
ITransaction transaction = cache.CreateTransaction();
var tx1 = transaction.StringIncrementAsync("data:counter1");
var tx2 = transaction.StringDecrementAsync("data:counter2");
bool result = transaction.Execute();
Console.WriteLine("Transaction {0}", result ? "succeeded" : "failed");
Console.WriteLine("Result of increment: {0}", tx1.Result);
Console.WriteLine("Result of decrement: {0}", tx2.Result);
```

Redis トランザクションはリレーショナル データベースのトランザクションとは異なることに注意してください。 Execute メソッドは、実行するトランザクションを構成するすべてのコマンドをキューに登録するだけです。コマンドのいずれかの形式が正しくない場合は、トランザクションは中止されます。 すべてのコマンドが正常にキューに登録されると、各コマンドは非同期的に実行されます。 いずれかのコマンドが失敗した場合にも、他のコマンドは継続して処理されます。 コマンドが正常に完了したことを確認する必要がある場合は、上の例に示すように、対応するタスクの Result プロパティを使用してコマンドの結果を取得する必要があります。 Result プロパティの読み取りは、タスクが完了するまでブロックされます。

詳細については、次を参照してください。、 [Redis のトランザクション](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/Transactions.md) StackExchange.Redis の web サイトのページです。

バッチ操作を実行するには、StackExchange ライブラリの IBatch インターフェイスを使用します。 このインターフェイスでは、IDatabase インターフェイスと同様の一連のメソッドにアクセスできますが、すべてのメソッドが非同期である点が異なります。 次の例に示すように、IDatabase.CreateBatch メソッドを使用して IBatch オブジェクトを作成し、次に IBatch.Execute メソッドを使用してバッチを実行します。 このコードでは、単純に文字列値を設定し、前の例で使用したのと同じカウンターをインクリメントおよびデクリメントして結果を表示します。

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
IBatch batch = cache.CreateBatch();
batch.StringSetAsync("data:key1", 11);
var t1 = batch.StringIncrementAsync("data:counter1");
var t2 = batch.StringDecrementAsync("data:counter2");
batch.Execute();
Console.WriteLine("{0}", t1.Result);
Console.WriteLine("{0}", t2.Result);
```

トランザクションとは異なり、バッチ内のコマンドの形式が正しくないために失敗した場合も他のコマンドは実行できると理解することが重要です。IBatch.Execute メソッドは、成功または失敗を示す結果を一切返しません。

### ファイア アンド フォーゲット キャッシュ操作の実行

Redis は、コマンドのフラグを使用することでファイア アンド フォーゲット操作をサポートします。 この場合は、クライアントは操作を開始するだけで、結果は考慮せず、コマンドの完了も待機しません。 以下の例に、ファイア アンド フォーゲット操作として INCR コマンドを実行する方法を示します。

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
await cache.StringSetAsync("data:key1", 99);
...
cache.StringIncrement("data:key1", flags: CommandFlags.FireAndForget);
```

### 自動的に期限切れになるキー

Redis キャッシュに項目を格納するときに、項目をキャッシュから自動的に削除するまでのタイムアウトを指定できます。 どれほど多くの時間、キーが使用して、有効期限が切れる前にクエリすることもできます、 `TTL` コマンドは、IDatabase.KeyTimeToLive メソッドを使用して、このコマンドは StackExchange アプリケーションで使用できます。

次のコード スニペットに、キーに 20 秒の有効期限を設定して、キーの残り時間をクエリする例を示します。

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
// Add a key with an expiration time of 20 seconds
await cache.StringSetAsync("data:key1", 99, TimeSpan.FromSeconds(20));
...
// Query how much time a key has left to live
// If the key has already expired, the KeyTimeToLive function returns a null
TimeSpan? expiry = cache.KeyTimeToLive("data:key1");
```

EXPIRE コマンドを使用すると有効期限を特定の日時に設定することもできます。このコマンドは、StackExchange ライブラリでは KeyExpireAsync メソッドとして使用できます。

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
// Add a key with an expiration date of midnight on 1st January 2015
await cache.StringSetAsync("data:key1", 99);
await cache.KeyExpireAsync("data:key1",
    new DateTime(2015, 1, 1, 0, 0, 0, DateTimeKind.Utc));
...
```

> _ヒント:_ 項目をキャッシュから手動で削除するには DEL コマンドを使用します。このコマンドは、StackExchange ライブラリでは IDatabase.KeyDeleteAsync メソッドとして使用できます。

### タグを使用するキャッシュされた項目のクロス関連付け

Redis セットは、1 つのキーを共有する複数の項目のコレクションです。 セットを作成するには、SADD コマンドを使用します。 セット内の項目は、SMEMBERS コマンドを使用して取得できます。 StackExchange ライブラリでは、SADD コマンドはIDatabase.SetMembersAsync メソッド、SMEMBERS コマンドは IDatabase.SetAddAsync メソッドを介して実装されています。 SDIFF (差集合) コマンド、SINTER (積集合) コマンド、および SUNION (和集合) コマンドを使用して、既存のセットを組み合わせて新しいセットを作成することもできます。 StackExchange ライブラリでは、これらの操作は IDatabase.SetCombineAsync メソッドにまとめられています。このメソッドの最初のパラメーターでは、実行するセット操作を指定します。

次のコード スニペットに、関連する項目のコレクションをすばやく格納したり取得したりするのにセットがどれほど威力を発揮するかを示します。 このコードでは、「Redis キャッシュ クライアント アプリケーションの実装」セクションで説明した BlogPost 型を使用します。 BlogPost オブジェクトには 4 つのフィールド (ID、タイトル、順位付けスコア、タグのコレクション) が含まれています。 以下の最初のコード スニペットに、BlogPost オブジェクトの C# コードのリストを設定するために使用するサンプル データを示します。

```csharp
List<string[]> tags = new List<string[]>()
{
    new string[] { "iot","csharp" },
    new string[] { "iot","azure","csharp" },
    new string[] { "csharp","git","big data" },
    new string[] { "iot","git","database" },
    new string[] { "database","git" },
    new string[] { "csharp","database" },
    new string[] { "iot" },
    new string[] { "iot","database","git" },
    new string[] { "azure","database","big data","git","csharp" },
    new string[] { "azure" }
};

List<BlogPost> posts = new List<BlogPost>();
int blogKey = 0;
int blogPostId = 0;
int numberOfPosts = 20;
Random random = new Random();
for (int i = 0; i < numberOfPosts; i++)
{
    blogPostId = blogKey++;
    posts.Add(new BlogPost(
        blogPostId,               // Blog post ID
        string.Format(CultureInfo.InvariantCulture, "Blog Post #{0}",
            blogPostId),          // Blog post title
        random.Next(100, 10000),  // Ranking score
        tags[i % tags.Count]));   // Tags – assigned from a collection
                                  // in the tags list
}
```

各 BlogPost オブジェクトのタグをセットとして Redis キャッシュに格納し、各セットに BlogPost の ID を関連付けることができます。 これにより、特定のブログの投稿に属するすべてのタグをアプリケーションですばやく検索できます。 逆引き検索を有効にして、特定のタグを共有するすべてのブログの投稿を検索するには、キーに含まれるタグ ID を参照するブログの投稿を保持する別のセットを作成します。

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
// Tags are easily represented as Redis Sets
foreach (BlogPost post in posts)
{
    string redisKey = string.Format(CultureInfo.InvariantCulture,
        "blog:posts:{0}:tags", post.Id);
    // Add tags to the blog post in redis
    await cache.SetAddAsync(
        redisKey, post.Tags.Select(s => (RedisValue)s).ToArray());

    // Now do the inverse so we can figure how which blog posts have a given tag.
    foreach (var tag in post.Tags)
    {
        await cache.SetAddAsync(string.Format(CultureInfo.InvariantCulture,
            "tag:{0}:blog:posts", tag), post.Id);
    }
}
```

これらの構造によって、多くの一般的なクエリを非常に効率よく実行することができます。 たとえば、次のようにすると、ブログの投稿 1 のすべてのタグを検索して表示できます。

```csharp
// Show the tags for blog post #1
foreach (var value in await cache.SetMembersAsync("blog:posts:1:tags"))
{
    Console.WriteLine(value);
}
```

次のような積集合演算を実行することで、ブログの投稿 1 とブログの投稿 2 に共通するすべてのタグを検索できます。

```csharp
// Show the tags in common for blog posts #1 and #2
foreach (var value in await cache.SetCombineAsync(SetOperation.Intersect, new RedisKey[]
    { "blog:posts:1:tags", "blog:posts:2:tags" }))
{
    Console.WriteLine(value);
}
```

また、次のようにすると、特定のタグを含むすべてのブログの投稿を検索できます。

```csharp
// Show the ids of the blog posts that have the tag "iot".
foreach (var value in await cache.SetMembersAsync("tag:iot:blog:posts"))
{
    Console.WriteLine(value);
}
```

### 最近アクセスした項目の検索

多くのアプリケーションに伴う共通の問題に、最近アクセスした項目の検索があります。 たとえば、あるブログ サイトで最近読まれたブログの投稿を表示する必要があるとしましょう。 この機能を実装するには、Redis リストを使用します。 Redis リストには、同じキーを共有する複数の項目が含まれていますが、このリストは両端キューとして機能します。 LPUSH (左プッシュ) コマンドと RPUSH (右プッシュ) コマンドを使用すると、リストのどちら側の終端にも項目をプッシュできます。 LPOP コマンドと RPOP コマンドを使用すると、リストのどちら側の終端からも項目を取得できます。 LRANGE コマンドと RRANGE コマンドを使用すると、要素のセットを返すこともできます。 以下のコード スニペットに、StackExchange ライブラリを使用してこれらの操作を実行する方法を示します。 このコードでは、これまでの例の BlogPost 型を使用します。 ブログの投稿がユーザーに読まれると、IDatabase.ListLeftPushAsync メソッドを使用して、ブログの投稿のタイトルが Redis キャッシュの "blog:recent_posts" キーに関連付けられているリストにプッシュされます。

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
string redisKey = "blog:recent_posts";
BlogPost blogPost = ...; // reference to the blog post that has just been read
await cache.ListLeftPushAsync(
    redisKey, blogPost.Title); // push the blog post onto the list
```

さらに別のブログ投稿が読まれたときにも、それらのタイトルは同じリストにプッシュされます。 リストは、タイトルが追加された順になります。最近読まれたブログの投稿がリストの左端に向かって並びます。(同じブログの投稿が複数回読まれた場合は、リストに複数のエントリが含まれることになります)。 IDatabase.ListRange メソッドを使用すると、最近読まれた投稿のタイトルを表示できます。 このメソッドは、リスト、開始位置、および終了位置を含むキーを取ります。 次のコードでは、リストの左端から 10 個のブログの投稿 (0 ～ 9 の項目) のタイトルを取得します。

```csharp
// Show latest ten posts
foreach (string postTitle in await cache.ListRangeAsync(redisKey, 0, 9))
{
    Console.WriteLine(postTitle);
}
```

ListRangeAsync はリストから項目を削除しないことに注意してください。削除するには、IDatabase.ListLeftPopAsync メソッドや IDatabase.ListRightPopAsync メソッドを使用します。

リストが無制限に大きくなるのを回避するには、定期的にリストをトリミングすることで項目の数を減らします。 以下のコード スニペットでは、左端の 5 項目以外のすべての項目をリストから削除します。

```csharp
await cache.ListTrimAsync(redisKey, 0, 5);
```

### スコア ボードの実装

既定では、セット内の項目は特定の順序で保持されません。 ZADD コマンド (StackExchange ライブラリの IDatabase.SortedSetAdd メソッド) を使用すると、順序付けされたセットを作成することができます。 項目は、コマンドのパラメーターとして指定する、スコアと呼ばれる数値を使用して並べます。 次のコード スニペットでは、ブログの投稿のタイトルを順序付きリストに追加します。 この例では、各ブログの投稿にもブログの投稿の順位を含むスコア フィールドが設定されています。

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
string redisKey = "blog:post_rankings";
BlogPost blogPost = ...; // reference to a blog post that has just been rated
await cache.SortedSetAddAsync(redisKey, blogPost.Title, blogpost.Score);
```

IDatabase.SortedSetRangeByRankWithScores メソッドを使用すると、ブログの投稿のタイトルとスコアを昇順で取得できます。

```csharp
foreach (var post in await cache.SortedSetRangeByRankWithScoresAsync(redisKey))
{
    Console.WriteLine(post);
}
```

> [AZURE.NOTE] StackExchange ライブラリには、スコアの順序でデータを返す IDatabase.SortedSetRangeByRankAsync メソッドもあります。ただしこのメソッドは、スコアは返しません。

IDatabase.SortedSetRangeByRankWithScoresAsync メソッドに追加のパラメーターを指定することで、スコアの降順でも項目を取得でき、返される項目の数を制限することもできます。 次の例では、上位 10 個のブログの投稿のタイトルとスコアを表示します。

```csharp
foreach (var post in await cache.SortedSetRangeByRankWithScoresAsync(
                               redisKey, 0, 9, Order.Descending))
{
    Console.WriteLine(post);
}
```

次の例では、返される項目数を指定したスコア範囲におさまる項目数に制限できる IDatabase.SortedSetRangeByScoreWithScoresAsync メソッドを使用します。

```csharp
// Blog posts with scores between 5000 and 100000
foreach (var post in await cache.SortedSetRangeByScoreWithScoresAsync(
                               redisKey, 5000, 100000))
{
    Console.WriteLine(post);
}
```

### チャネルを使用したメッセージング

Redis サーバーは、データ キャッシュとして機能する以外にも、高パフォーマンスのパブリッシャー/サブスクライバー メカニズムを使用してメッセージング機能を提供します。 クライアント アプリケーションはチャネルにサブスクライブし、他のアプリケーションまたはサービスはチャネルにメッセージを発行できます。 サブスクライブしているアプリケーションは、これらのメッセージを受信し、処理することができます。

Redis は、チャネルにサブスクライブするための SUBSCRIBE コマンドを提供します。 このコマンドでは、アプリケーションがメッセージを受け入れるチャネルの名前を 1 つまたは複数指定する必要があります。 StackExchange ライブラリには ISubscription インターフェイスが含まれ、これにより .NET Framework アプリケーションはチャネルに対するサブスクライブと発行を行うことができます。 Redis サーバーへの接続の GetSubscriber メソッドを使用することで ISubscription オブジェクトを作成し、このオブジェクトの SubscribeAsync メソッドを使用することでチャネルのメッセージをリッスンします。 次のコード例に、“messages:blogPosts” という名前のチャネルをサブスクライブする方法を示します。

```csharp
ConnectionMultiplexer redisHostConnection = ...;
ISubscriber subscriber = redisHostConnection.GetSubscriber();
...
await subscriber.SubscribeAsync("messages:blogPosts", (channel, message) =>
{
    Console.WriteLine("Title is: {0}", message);
});
```

Subscribe メソッドの最初のパラメーターは、チャネルの名前です。 この名前はキャッシュのキーで使用されるものと同じ規則に従って付け、任意のバイナリ データを含めることができます。ただし、比較的短く意味のある文字列を使用して、良好なパフォーマンスと保守性を確保することをお勧めします。 チャネルが使用する名前空間はキーが使用する名前空間とは別のものであるため、同じ名前を持つチャネルとキーを扱うことができますが、このことによりアプリケーション コードの管理が難しくなる場合があることに注意してください。

2 番目のパラメーターは、Action デリゲートです。 このデリゲートは、チャネルに新しいメッセージが出現するたびに、非同期に実行されます。 この例では、単にコンソールにメッセージを表示します (メッセージには、ブログの投稿のタイトルが含まれます)。

チャネルに発行するには、アプリケーションで Redis PUBLISH コマンドを使用します。 StackExchange ライブラリは、この操作を実行する IServer.PublishAsync メソッドを提供します。 次のコード スニペットに、“messages:blogPosts” チャネルにメッセージを発行する方法を示します。

```csharp
ConnectionMultiplexer redisHostConnection = ...;
ISubscriber subscriber = redisHostConnection.GetSubscriber();
...
BlogPost blogpost = ...;
subscriber.PublishAsync("messages:blogPosts", blogPost.Title);
```

発行/サブスクライブ メカニズムについて理解しておくべき点がいくつかあります。

- 複数のサブスクライバーが同じチャネルにサブスクライブでき、すべてのサブスクライバーがそのチャネルに発行されたメッセージを受信します。
- サブスクライバーは、サブスクライブした後に発行されたメッセージのみを受信します。 チャネルはバッファリングされません。メッセージが発行されると、Redis インフラストラクチャは各サブスクライバーにメッセージをプッシュし、メッセージを削除します。
- 既定では、サブスクライバーは、送信された順序でメッセージを受信します。 頻度の高いシステムの数が多い
  メッセージと多くのサブスクライバーおよびパブリッシャーのメッセージの順次配信の保証、システムのパフォーマンスが低下することができます。 もし
  各メッセージが独立して、順序は重要ではないになり、Redis システムによる同時処理を有効にすることができます
  応答性を向上します。 これを行う StackExchange クライアントで使用する接続の PreserveAsyncOrder を設定して
  false にサブスクライバー:
  ```csharp
  ConnectionMultiplexer redisHostConnection = ...;
  redisHostConnection.PreserveAsyncOrder = false;
  ISubscriber subscriber = redisHostConnection.GetSubscriber();
  ```

## 関連パターンとガイダンス

次のパターンは、アプリケーションでキャッシュを実装するときのシナリオにも関連することがあります。

- [キャッシュア サイド パターン](http://msdn.microsoft.com/library/dn589799.aspx): このパターンは、データ ストアからキャッシュにデータをオンデマンドを読み込む方法をについて説明します。 このパターンは、キャッシュに保持されているデータと、元のデータ ストア内のデータの一貫性の維持にも役立ちます。
- [シャーディング パターン](http://msdn.microsoft.com/library/dn589797.aspx) を格納する場合は、スケーラビリティを向上させる水平的パーティション分割と、大量のデータへのアクセスの実装に関する情報を提供します。

## 詳細情報

- [MemoryCache クラス](http://msdn.microsoft.com/library/system.runtime.caching.memorycache.aspx) 、Microsoft web サイトのページです。
- [Microsoft Azure Cache](http://msdn.microsoft.com/library/windowsazure/gg278356.aspx) 、Microsoft web サイトのページです。
- [どの Azure Cache を利用に最適な?](http://msdn.microsoft.com/library/azure/dn766201.aspx) 、Microsoft web サイトのページです。
- [構成モデル](http://msdn.microsoft.com/library/windowsazure/hh914149.aspx) 、Microsoft web サイトのページです。
- [タスク ベースの非同期パターン](http://msdn.microsoft.com/library/hh873175.aspx) 、Microsoft web サイトのページです。
- [パイプラインと Multiplexers](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/PipelinesMultiplexers.md) StackExchange.Redis GitHub リポジトリのページです。
- [Redis の永続化](http://redis.io/topics/persistence) Redis web サイトのページです。
- [レプリケーション ページ](http://redis.io/topics/replication) Redis web サイトです。
- [Redis クラスター チュートリアル](http://redis.io/topics/cluster-tutorial) Redis web サイトのページです。
- [パーティション分割: 複数の Redis インスタンス間でデータを分割する方法](http://redis.io/topics/partitioning) Redis web サイトのページです。
- ページ [LRU キャッシュとしての Redis を使用して](http://redis.io/topics/lru-cache) Redis web サイトです。
- [トランザクション] ページの](http://redis.io/topics/transactions) Redis web サイトです。
- [Redis のセキュリティ](http://redis.io/topics/security) Redis web サイトのページです。
- ページ [Azure Redis Cache に関する説明](http://azure.microsoft.com/blog/2014/06/04/lap-around-azure-redis-cache-preview/) Azure ブログのです。
- ページ [CentOS Linux VM で Redis を実行している](http://blogs.msdn.com/b/tconte/archive/2012/06/08/running-redis-on-a-centos-linux-vm-in-windows-azure.aspx) に、Microsoft web サイト Azure です。
- [Azure Redis Cache 用の ASP.NET セッション状態プロバイダー](http://msdn.microsoft.com/library/azure/dn690522.aspx) 、Microsoft web サイトのページです。
- [Azure Redis Cache 用の ASP.NET 出力キャッシュ プロバイダー](http://msdn.microsoft.com/library/azure/dn798898.aspx) 、Microsoft web サイトのページです。
- ページ [Azure Redis Cache の開発](http://msdn.microsoft.com/library/azure/dn690520.aspx) Azure サイトにします。
- ページ [An Introduction to Redis データ型と抽象化](http://redis.io/topics/data-types-intro) Redis web サイトです。
- [基本的な使用法](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/Basics.md) StackExchange.Redis の web サイトのページです。
- [Redis のトランザクション](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/Transactions.md) StackExchange.Redis リポジトリのページです。
- [データ パーティション分割ガイド](http://msdn.microsoft.com/library/dn589795.aspx) 、Microsoft web サイトです。





