<properties
   pageTitle="バックグラウンド ジョブのガイダンス | Microsoft Azure"
   description="ユーザー インターフェイスとは無関係に実行されるバックグラウンド タスクに関するガイダンスです。"
   services=""
   documentationCenter="na"
   authors="dragon119"
   manager="masimms"
   editor=""
   tags=""/>

<tags
   ms.service="best-practice"
   ms.devlang="na"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="na"
   ms.date="04/28/2015"
   ms.author="masashin"/>

# バックグラウンド ジョブのガイダンス

![](media/best-practices-background-jobs/pnp-logo.png)


## 概要

ユーザー インターフェイス (UI) とは無関係に実行されるバックグラウンド タスクは、さまざまな種類のアプリケーションで重要な役割を果たしています。 その例として、バッチ ジョブ、多くの処理能力を消費するタスク、長時間実行されるプロセス (ワークフローなど) を挙げることができます。 バックグラウンド ジョブの実行は、ユーザーの介入を必要としません。アプリケーションでジョブを起動した後も、ユーザーから対話式に送られる要求を処理し続けることができます。 アプリケーションの UI に対する負荷が小さくなるので、稼働率が向上し、対話の応答時間が短縮されます。

たとえば、ユーザーからアップロードされた画像のサムネイルをアプリケーションで生成する場合、その処理をバックグラウンド ジョブとして実行し、完成したサムネイルを記憶域に保存することができます。処理が完了するまでユーザーを待たせる必要はありません。 同様に、何かを購入する状況においても、注文を処理するワークフローをバックグラウンドで開始すれば、その間もユーザーは UI を使って Web サイトを閲覧することができます。 バックグラウンド ジョブが完了した時点で、保存された注文データを更新し、注文内容を確認するメールをユーザーに送信することが可能です。

特定のタスクをバックグラウンド ジョブとして実装するかどうかの主要な判断基準は、そのタスクが、ユーザーの介入なしで実行できるかどうかと、ジョブの完了まで UI を待機状態にする必要があるかどうかです。 完了までユーザーまたは UI を待機させる必要のあるタスクは、バックグラウンド ジョブに適していない可能性があります。

## バックグラウンド ジョブの種類

通常バックグラウンド ジョブには次の特徴があります。

- CPU に負荷のかかるジョブ (数学的計算、構造モデル分析など)。
- 入出力の多いジョブ (一連のストレージ トランザクションの実行、ファイルのインデックス作成など)。
- バッチ ジョブ (夜間のデータ更新、スケジュール設定された処理など)。
- 長時間実行されるワークフロー (受注処理、サービスやシステムのプロビジョニングなど)。
- 機密データ処理 (より安全な場所にタスクが引き渡されて処理される)。 たとえば、web ロール内で機密データを処理しないしてなど、パターンに従い [ゲートキーパー](http://msdn.microsoft.com/library/dn589793.aspx) 保護された記憶域にアクセスできる分離されたバック グラウンド ロールにデータを転送します。

## トリガー

バックグラウンド ジョブは、さまざまな方法で開始することができます。 実質的には、大きく次の 2 つのカテゴリに分けられます。

- [**イベント ドリブン トリガー**](#event-driven-triggers)します。 イベント (通常、ユーザーが実行する操作またはワークフロー内のステップ) に反応する形でタスクが開始されます。
- [**スケジュール ドリブン トリガー**](#schedule-driven-triggers)します。 タイマーに基づくスケジュールに従ってタスクが呼び出されます。 スケジュールに従って定期的に呼び出すことも、指定された時刻に 1 回だけ呼び出すこともできます。

### イベント ドリブン トリガー

イベント ドリブン型の呼び出しでは、トリガーを使ってバックグラウンド タスクが開始されます。 イベント ドリブン トリガーの例を次に示します。

- UI やその他のジョブによってキューにメッセージが追加されます。 メッセージに含まれているのは、実行された操作 (ユーザーによる注文など) に関するデータです。 バックグラウンド タスクは、このキューで待機し、新しいメッセージの到着を検出します。 そのメッセージが読み取られ、その中のデータが、バックグラウンド ジョブの入力として使用されます。
- UI やその他のジョブによって記憶域に値が保存されるか値が更新されます。 バックグラウンド タスクは記憶域を監視し、変更を検出します。 そのデータが読み取られ、バックグラウンド ジョブの入力として使用されます。
- UI やその他のジョブからエンドポイント (Web サービスとして公開されている API、HTTPS URI など) に要求が送られます。 その際バックグラウンド タスクを実行するために必要なデータは要求の一部として渡されます。 エンドポイントまたは Web サービスがバックグラウンド タスクを呼び出すときに、そのデータが入力として使用されます。

イベント ドリブンの呼び出しに適したタスクの例としては、画像処理、ワークフロー、リモート サービスへの情報送信、電子メール メッセージの送信、マルチテナント アプリケーションへの新しいユーザーのプロビジョニングが代表的です。

### スケジュール ドリブン トリガー

スケジュール ドリブン型の呼び出しでは、タイマーを使ってバックグラウンド タスクが開始されます。 スケジュール ドリブン トリガーの例を次に示します。

- 同じアプリケーション内でローカルに実行されているタイマーまたはその動作環境であるオペレーティング システムの機能として実行されているタイマーによってバックグラウンド タスクが定期的に呼び出されます。
- 別のアプリケーションで実行されているタイマーまたは Azure Scheduler などのタイマー サービスから API や Web サービスに対して定期的に要求が送られます。 その API または Web サービスによってバックグラウンド タスクが呼び出されます。
- 別のプロセスまたはアプリケーションによってタイマーが起動され、指定された時間の経過後または特定の時刻にバックグラウンド タスクが呼び出されます。

スケジュール ドリブンで呼び出すことが適しているタスクの例としては、バッチ処理ルーチン (ユーザーの直近の行動に基づいて、表示する関連製品一覧を更新するなど)、ルーチン データ処理タスク (インデックスの更新、蓄積された結果の生成など)、日次レポート用のデータ分析、保管データのクリーンアップ、データ一貫性チェックが代表的です。

スケジュール ドリブンのタスクを単一のインスタンスとして実行する必要がある場合は、次の点に注意してください。

- スケジューラを実行するコンピューティング インスタンス (Windows のスケジュール タスクを使用する仮想マシンなど) がスケーリングされた場合、そのスケジューラのインスタンスが複数実行され、タスクのインスタンスも複数起動される可能性があります。
- タスクの実行時間がスケジューラのイベントの発生間隔を超えた場合、先に起動されたインスタンスが終わる前に、スケジューラによってタスクのインスタンスがもう 1 つ起動されます。

## 結果の出力

バックグラウンド ジョブは、その呼び出し元となった UI やプロセスとは独立したプロセスで (または場合によっては別の場所で) 非同期的に実行されます。 バックグラウンド タスクは、開始後放置できること、またその実行中に UI や呼び出し元のプロセスに影響を与えないことが理想です。 呼び出し元のプロセスはタスクの完了を待機せず、いつタスクが完了するかを自動的には検出できません。
バックグラウンド タスクが呼び出し元のタスクと情報をやり取りし、進行状況や完了を伝えることができるようにするには、そのための機構を実装する必要があります。 次に例をいくつか示します。

- UI や呼び出し元のタスクからアクセスできる記憶域にステータス インジケーターの値を書き込み、呼び出し元が必要に応じてその値を監視、確認できるようにする。 その他、バックグラウンド タスクから呼び出し元に返す必要のあるデータも同じ記憶域に格納することができます。
- 応答キューを設定し、そこで UI または呼び出し元を待機させる。 バックグラウンド タスクは、このキューにメッセージを送ることでステータスや完了を知らせることができます。 バックグラウンド タスクから呼び出し元に返す必要のあるデータもそのメッセージに格納することができます。 使用することができます Azure Service Bus を使用している場合、 **ReplyTo** と **CorrelationId** にこの機能を実装するプロパティです。 詳細については、次を参照してください。 [Service Bus 仲介型メッセージングにおける相関](http://www.cloudcasts.net/devguide/Default.aspx?id=13029)します。
- UI や呼び出し元がステータス情報を取得する目的でアクセスできる API またはエンドポイントをバックグラウンド タスク側で公開する。 その応答に、バックグラウンド タスクから呼び出し元に返す必要のあるデータを格納することができます。
- バックグラウンド タスクから API を介して UI や呼び出し元をコールバックし、定義済みのポイントや完了時点でステータスを通知する。 コールバックのタイミングとしては、ローカルで発生するイベントや、パブリッシュとサブスクライブのメカニズムを利用することができます。 バックグラウンド タスクから呼び出し元に返す必要のあるデータは、要求またはイベントのペイロードに格納することができます。

## ホスティング環境

バックグラウンド タスクは、Azure の各種プラットフォーム サービスを使ってホストすることができます。

- [**Azure の Web サイト**](#azure-web-sites-and-webjobs)します。 WebJobs を使うと、各種のスクリプトや実行可能プログラムをカスタム ジョブとして Web サイトのコンテキスト内で実行することができます。
- [**Azure のクラウド サービス web および worker ロール**](#azure-cloud-services-web-and-worker-roles)します。 バックグラウンド タスクとして動作するロールにコードを記述することができます。
- [**Azure の仮想マシン**](#azure-virtual-machines)します。 Windows サービスがある場合または Windows タスク スケジューラを使用する場合、バックグラウンド タスクを専用の仮想マシンにホストするのが一般的です。

以降のセクションでそれぞれの方法について詳しく説明すると共に、適切な方法を選ぶうえでの注意事項を取り上げます。

### Azure WebSites と Azure WebJobs

Azure WebJobs を使うと、Azure WebSites にホストされているアプリケーション内でカスタム ジョブをバックグラウンド タスクとして実行できます。 WebJobs では、スクリプトや実行可能プログラムを Web サイトのコンテキスト内で実行することができます。継続するプロセスとしてそれらを実行できるほか、Azure Scheduler や外的要因 (BLOB ストレージやメッセージ キューに対する変更など) からのトリガー イベントに反応する形で実行することが可能です。 ジョブは、起動と停止をオンデマンドで行うことができ、正規の手順でシャットダウンすることができます。 継続的に実行される Web ジョブは、エラーが発生した場合、自動的に再起動されます。 再試行とエラーのアクションは、設定で変更することができます。

Web ジョブを構成する際の注意事項を次に示します。

- として構成するか、イベント ドリブン トリガーに対応するジョブを実行する場合に、 **連続的に実行**します。 スクリプトまたはプログラムは、"site/wwwroot/app_data/jobs/continuous" という名前のフォルダーに格納されます。
- として構成するか、ジョブ スケジュール ドリブン トリガーに応答する場合は、 **、スケジュールに従って実行**します。 スクリプトまたはプログラムは、"site/wwwroot/app_data/jobs/triggered" という名前のフォルダーに格納されます。
- 選択した場合、 **をオンデマンドで実行** オプションをジョブを構成すると同じコードが実行されます、 **、スケジュールに従って実行** オプションを開始するとします。

Azure WebJobs は、Web サイトのサンドボックス内で実行されます。つまり、環境変数にアクセスして、接続文字列などの情報を Web サイトとの間で共有することができます。 Web ジョブは、それを実行しているコンピューターの一意の識別子にアクセスすることができます。 名前付き接続文字列 **AzureJobsStorage** メッセージングおよび通信のためのアプリケーション データと Service Bus の Azure のストレージ キュー、blob、およびテーブルへのアクセスを提供します。 名前付き接続文字列 **AzureJobsDashboard** ジョブ アクションのログ ファイルへのアクセスを提供します。

Azure の Web ジョブの特徴を次に示します。

- **セキュリティ**: web ジョブは、web サイトのデプロイ資格情報によって保護されます。
- **ファイルの種類がサポートされている**: web ジョブはコマンド スクリプト (.cmd)、バッチ ファイル (.bat)、PowerShell スクリプト (.ps1) を使用して定義する、bash シェル スクリプト (.sh)、PHP スクリプト (.php)、Python スクリプト (.py)、JavaScript コード (.js)、および実行可能プログラム (.exe、.jar などなど)。
- **展開**: を使用して作成、配置は、Azure ポータルを使用して、スクリプトや実行可能ファイルを配置できます、 [WebJobsVs](https://visualstudiogallery.msdn.microsoft.com/f4824551-2660-4afa-aba1-1fcc1673c3d0) Visual Studio のアドインで、または [Visual Studio 2013 Update 4](http://www.visualstudio.com/news/vs2013-update4-rc-vs), を使用して、 [Azure web ジョブ SDK](websites-dotnet-webjobs-sdk-get-started.md), 、または、次の場所に直接コピーすることで。
  - トリガーによって実行する場合: site/wwwroot/app_data/jobs/triggered/{job name}
  - 連続実行の場合: site/wwwroot/app_data/jobs/continuous/{job name}
- **ログ記録**: Console.Out は INFO として、Console.Error は ERROR として (マーク) は処理されます。 監視情報と診断情報には、Azure ポータルからアクセスできます。ログ ファイルは、サイトから直接ダウンロードすることができます。 これらの情報は次の場所に保存されます。
  - トリガーによって実行する場合: Vfs/data/jobs/continuous/jobName
  - 連続実行の場合: Vfs/data/jobs/triggered/jobName
- **構成**: web ジョブの構成は、ポータル、REST API、PowerShell を使用します。 ジョブの構成情報は、ジョブ スクリプトと同じルート ディレクトリにある settings.job という名前の構成ファイルで指定できます。 次に例を示します。
  - { "stopping_wait_time": 60 }
  - { "is_singleton": true }

### 考慮事項

- 既定では、Web サイトをスケーリングすると Web ジョブもスケーリングされます。 ただし、設定、1 つのインスタンスで実行するジョブを構成できます、 **is_singleton** 構成プロパティを true にします。 単一インスタンスの Web ジョブは、スケーリングが不要なタスク (インデックスの再構築、データ分析など、同時に複数のインスタンスで実行することが望ましくないタスク) に適しています。
- 長時間実行されるジョブやリソースの消費量が大きいジョブは、Web サイトのパフォーマンスへの影響を最小限に抑えるために、新しい App Service プランで空の Azure WebSites インスタンスを作成し、そこでホストすることを検討してください。

### 詳細情報

- [Azure WebJobs 推奨リソース](websites-webjobs-resources/) 多くの有用な情報、ダウンロード、およびサンプル web ジョブの一覧が表示されます。

## Azure Cloud Services の Web ロールと worker ロール

バックグラウンド タスクは、Web ロール内で実行することも、独立した worker ロールで実行することもできます。 worker ロールを用いるかどうかは、スケーラビリティと弾力性の要件、タスクの有効期間、リリースの頻度、セキュリティ、フォールト トレランス、リソースの奪い合い、複雑性、論理アーキテクチャなどを考慮して判断します。 詳細については、次を参照してください。 [Compute Resource Consolidation パターン](http://msdn.microsoft.com/library/dn589778.aspx)します。

Cloud Services ロールには、さまざまな方法でバックグラウンド タスクを実装することができます。

- 実装を作成、 **RoleEntryPoint** ロールのクラスし、そのメソッドを使用して、バック グラウンド タスクを実行します。 タスクは WaIISHost.exe のコンテキストで実行され、使用できる、 **GetSetting** のメソッド、 **CloudConfigurationManager** クラスの構成設定を読み込めません。 詳細については、次を参照してください。 [ライフ サイクル (Cloud Services)](#lifecycle-cloud-services-)します。
- アプリケーションの起動時にスタートアップ タスクを使ってバックグラウンド タスクを実行する。 引き続きバック グラウンドのセットで実行するタスクを強制的に、 **taskType** プロパティを **バック グラウンド** (これを変更しない場合は、アプリケーションの起動プロセスは停止およびタスクの完了を待ちます)。 詳細については、次を参照してください。 [Azure におけるスタートアップ タスクの実行](http://msdn.microsoft.com/library/azure/hh180155.aspx)します。
- WebJobs SDK を使い、スタートアップ タスクとして開始される WebJobs としてバックグラウンド タスクを実装する。 詳細については、次を参照してください。 [Azure web ジョブ SDK を使ってみる](websites-dotnet-webjobs-sdk-get-started.md)します。
- バックグラウンド タスクを実行する Windows サービスを、スタートアップ タスクを使ってインストールする。 設定する必要があります、 **taskType** プロパティを **バック グラウンド** サービスがバック グラウンドで実行するようにします。 詳細については、次を参照してください。 [Azure におけるスタートアップ タスクの実行](http://msdn.microsoft.com/library/azure/hh180155.aspx)します。

### Web ロールでのバックグラウンド タスクの実行

バックグラウンド タスクを Web ロールで実行する利点はなんといっても、別途ロールを追加デプロイする必要がないため、ホスティングにかかるコストが低いことです。

### worker ロールでのバックグラウンド タスクの実行

以下、バックグラウンド タスクを worker ロールで実行する利点をいくつか挙げます。

- ロールの種類ごとに切り離してスケーリングを管理できる。 たとえば現状の負荷に対応するために Web ロールのインスタンス数を増やす必要がある一方で、バックグラウンド タスクを実行する worker ロールのインスタンス数はもっと少なくできるという状況が考えられます。 バックグラウンド タスクのコンピューティング インスタンスを UI のロールとは独立にスケーリングすることで、十分なパフォーマンスを維持しながら、ホスティングのコストを削減することができます。
- バックグラウンド タスクの処理オーバーヘッドを Web ロールから取り除くことができる。 UI として機能する Web ロールの応答性を保つことができるため、ユーザーからの特定の量の要求を処理するために必要なインスタンス数が相対的に少なくて済みます。
- 処理内容の独立性を高めることができる。 ロールの種類ごとに明確な特徴を持った関連するタスクを集めて実装することができます。 他のロールのコードや機能への依存度が下がるため、コードの設計と管理がしやすくなります。
- 機密を要するプロセスやデータが分離しやすくなる。 たとえば、UI の機能を実装する Web ロールが、worker ロールの管理下にあるデータにアクセスできる必要はありません。 これで、セキュリティの強化など、パターンを使用する場合に特に役に立ちます、 [Gatekeeper パターン](http://msdn.microsoft.com/library/dn589793.aspx)します。  

### 考慮事項

Cloud Services の Web ロールと worker ロールを使っているときに、バックグラウンド タスクをどこにどのようにデプロイするかは、次の点を考慮して判断してください。

- バックグラウンド タスクを既存の Web ロールでホスティングすると、そのタスク専用に独立した worker ロールを運用するコストを節約することができます。一方、処理や他のリソースを奪い合う状況が生じると、アプリケーションのパフォーマンスと稼働率に影響する可能性が高くなります。 独立した worker ロールを使うと、バックグラウンド タスクの実行時間が長時間に及んだり、リソースが大量に消費されたりする影響から Web ロールを守ることができます。
- 使用してバック グラウンド タスクをホストしている場合、 **RoleEntryPoint** クラス、別のロールに移動することに簡単にできます。 Web ロール、および後でクラスを作成した場合を行うことができます、ワーカー ロールでタスクを実行する必要があるを決定するなど、 **RoleEntryPoint** クラスの実装を worker ロールにします。
- スタートアップ タスクはプログラムまたはスクリプトを実行するように設計されています。 バックグラウンド ジョブを実行可能プログラムとしてデプロイするのは、特に依存アセンブリのデプロイを伴う場合、スクリプトとしてデプロイするよりも難易度が高くなります。 スタートアップ タスクを使うときは、スクリプトをデプロイして使用した方が簡単にバックグラウンド ジョブを定義できます。
- バックグラウンド タスクの障害を引き起こす例外の影響は、バックグラウンド タスクのホスティング形態によって異なります。
  - 使用する場合、 **RoleEntryPoint** クラス アプローチでは、失敗したタスクのタスクが自動的に再起動するために再起動するロールが発生します。 このことでアプリケーションの稼働率に影響が生じる可能性があります。 これを防ぐためには、堅牢な例外処理を含めることを確認、 **RoleEntryPoint** クラスとすべてのバック グラウンド タスクです。 障害の発生したタスクを (再起動することが妥当であれば) 再起動するようにコーディングし、そのコード内の正規の手順で障害から復旧できない場合にのみ、例外をスローしてロールを再起動するようにしてください。
  - スタートアップ タスクを使った場合、タスクの実行管理と障害が発生しているかどうかのチェックを自分で行う必要があります。
- 管理して、スタートアップ タスクの監視は、使用するよりも難しく、 **RoleEntryPoint** クラスのアプローチです。 ただし、Azure WebJobs SDK に用意されているダッシュボードを使うと、スタートアップ タスクを用いて開始された Web ジョブを簡単に管理することができます。

### 詳細情報

- [Compute Resource Consolidation パターン](http://msdn.microsoft.com/library/dn589778.aspx)
- [Azure Web ジョブ SDK の使用](websites-dotnet-webjobs-sdk-get-started/)

## Azure Virtual Machines

バックグラウンド タスクの実装形態によっては、Azure WebSites や Cloud Services にデプロイできなかったり、現実的ではなかったりすることもあります。 Windows のサービスや、サード パーティのユーティリティ、サード パーティの実行可能プログラムがその代表的な例です。 また、アプリケーションのホスティング環境とは異なる実行環境向けに作成されたプログラムも同様です。たとえば、Unix や Linux のプログラムを Windows アプリケーションまたは .NET アプリケーションから実行するケースなどが該当します。 Azure Virtual Machines には、さまざまなオペレーティング システムが用意されているので、そこから目的のオペレーティング システムを選んで、仮想マシン上で必要なサービスまたは実行可能ファイルを運用することができます。

仮想マシンを使用するかを選択するために、次を参照してください。 [Azure Websites、クラウド サービスおよび仮想マシンの比較](choose-web-site-cloud-service-vm.md)します。 オプションについては [仮想マシンでは、仮想マシンと Azure のクラウド サービスのサイズを参照してください](http://msdn.microsoft.com/library/azure/dn197896.aspx)します。 仮想マシンのオペレーティング システムと既製イメージの使用に関する詳細については、次を参照してください。 [Azure Virtual Machines ギャラリー](http://azure.microsoft.com/gallery/virtual-machines/)します。

バックグラウンド タスクを別の仮想マシンで開始するには、いくつかの方法があります。

- タスクの公開エンドポイントに要求を送り、タスクに必要なデータを渡すことによってアプリケーションからオンデマンドで直接タスクを実行する。 タスクは、このエンドポイントによって呼び出されます。
- 選択したオペレーティング システムに用意されているスケジューラやタイマーを使い、スケジュールに基づいて動作するようにタスクを構成する。 たとえば Windows では、Windows タスク スケジューラを使ってスクリプトやタスクを実行できるほか、仮想マシンに SQL Server がインストールされていれば、SQL Server エージェントを使ってスクリプトやタスクを実行することができます。
- Azure Scheduler を使用し、タスクが待機しているキューにメッセージを追加するか、タスクが公開している API に要求を送ることによってタスクを開始する。

前のセクションを参照してください [トリガー](#triggers) バック グラウンド タスクを開始する方法の詳細についてです。  

### 考慮事項

Azure 仮想マシンにバックグラウンド タスクをデプロイするかどうかは、次の点を考慮して判断してください。

- 独立した Azure 仮想マシンでバックグラウンド タスクをホスティングすれば、運用の幅が広がり、開始と実行、スケジューリング、リソース割り当てを細かく制御することができます。 ただし、バックグラウンド タスクを実行するためだけに仮想マシンをデプロイしなければならない場合、ランタイム コストが大きくなります。
- 仮想マシンの基本的なステータスを監視し、使用して管理できますが、Azure ポータルでの障害が発生したタスクは、自動的に再起動する機能もありませんタスクを監視する機能はありません、 [Azure サービス管理コマンドレット](http://msdn.microsoft.com/library/azure/dn495240.aspx)します。 コンピューティング ノード内のプロセスやスレッドを制御する機構も存在しません。 通常、仮想マシンを使うためには、タスクのインストルメンテーションや仮想マシン内のオペレーティング システムからデータを収集するメカニズムを別途導入する必要があります。 該当する可能性のある 1 つのソリューションは、使用する、 [Azure 用の System Center 管理パック](http://technet.microsoft.com/library/gg276383.aspx)します。
- HTTP エンドポイントを介して公開される監視プローブの作成を検討してください。 正常性チェックの実行、運用情報や統計情報の収集、エラー情報の照合を監視プローブのコードから実行して管理アプリケーションに返すようにします。 詳細については、次を参照してください。 [Health Endpoint Monitoring パターン](http://msdn.microsoft.com/library/dn589789.aspx)します。

### 詳細情報

- [仮想マシン](http://azure.microsoft.com/services/virtual-machines/) 、Azure web サイト
- [Azure Virtual Machines FAQ (Azure 仮想マシンの FAQ)](http://msdn.microsoft.com/library/azure/dn683781.aspx)

## 設計上の考慮事項

バックグラウンド タスクを設計する際は、基本的な考慮事項がいくつかあります。 以降のセクションで、パーティション分割、競合、調整について説明します。

## パーティション分割

バックグラウンド タスクを既存のコンピューティング インスタンス (Web サイト、Web ロール、既存の worker ロール、仮想マシンなど) でホストすることにした場合、そのコンピューティング インスタンスとバックグラウンド タスクそのもののパフォーマンス特性に波及する影響を考慮に入れる必要があります。 以下、既存のコンピューティング インスタンスを間借りする形でタスクを配置するか、独立したコンピューティング インスタンスを専用に用意して配置するかを決めるうえでの判断材料としてください。

- **可用性**: バック グラウンド タスクが UI およびその他の部分をユーザーの対話に直接関連する具体的には、アプリケーションの他の部分としての可用性の同じレベル] が設定する必要はありません。 バックグラウンド タスクは、処理をキューに追加することができるため、遅延や接続失敗時の再試行など、稼働率を左右する要因は、ある程度許容することができます。 ただし、要求が溢れてしまうとキューがブロックされてアプリケーション全体に影響が生じるので、ある程度の処理能力は必要です。
- **スケーラビリティ**: バック グラウンド タスクでは、UI と、アプリケーションの対話型のパーツにさまざまなスケーラビリティの要件があるやすくします。 UI のスケーリングは需要のピークに対応できるように行う必要があるのに対し、未処理のバックグラウンド タスクは混雑時を避け、より少ないコンピューティング インスタンス数で実行することができます。
- **回復性**: バック グラウンド タスクだけをホストするコンピューティング インスタンスの障害致命的に影響は、アプリケーション全体のこれらのタスクの要求をキューに置かれたまたはタスクが再び使用可能にするまで延期します。 適切な時間内にコンピューティング インスタンスまたはタスクが再起動されれば、アプリケーションのユーザーが影響を被ることはありません。
- **セキュリティ**: バック グラウンド タスクごとに異なるセキュリティの要件や UI やアプリケーションの他の部分よりも制限が適用される場合があります。 独立したコンピューティング インスタンスを使うことによって、そのタスクに異なるセキュリティ環境を適用することができます。 また、セキュリティと独立性を高めるために、Gatekeeper などのパターンを使って、バックグラウンド コンピューティング インスタンスと UI とを分離させることもできます。
- **パフォーマンス**: バック グラウンド タスクに用いる一致具体的には、タスクのパフォーマンス要件は、コンピューティング インスタンスの種類を選択することができます。 タスクに求められる処理能力が UI ほど高くない場合は、より安価なコンピューティング オプションを選ぶことができます。逆に、UI よりも高い処理能力と多くのリソースが必要である場合は、コンピューティング インスタンスを増設することができます。
- **管理の容易性**: バック グラウンド タスクは、開発および配置の頻度が異なるアプリケーションのメイン コードや UI にあります。 独立したコンピューティング インスタンスにデプロイすることで、更新とバージョン管理を単純化することができます。
- **コスト**: コンピューティング コストをホストしているバック グラウンド タスクの増加を実行するインスタンスを追加します。 処理能力の向上とコストの増大のトレードオフを慎重に検討する必要があります。

詳細については、次を参照してください。 [Leader Election パターン](http://msdn.microsoft.com/library/dn568104.aspx) と [Competing Consumers パターン](http://msdn.microsoft.com/library/dn568101.aspx)します。

## 競合

バックグラウンド ジョブのインスタンスが複数存在する場合、データベースや記憶域などのリソースやサービスを奪い合う状況が生じる可能性があります。 このとき同時アクセスによってリソースの競合が生じ、サービスの稼働状態や記憶域におけるデータの整合性に矛盾が生じる場合があります。 リソースの競合は、排他的ロックを使って解決できます。排他的ロックは、リソースを奪い合っている複数のタスクのインスタンスが同時にサービスにアクセスできないように (データを破損させないように) する手法です。

競合を解決するもう 1 つのアプローチとして、バックグラウンド タスクをシングルトンとして定義し、インスタンスを 1 つしか実行できないようにする方法もあります。 しかし、この方法では、複数インスタンス構成の利点である信頼性とパフォーマンスが活かされません。特に、複数のバックグラウンド タスクを常時塞いでしまうほどに UI の処理能力が高い場合はなおさらです。 バックグラウンド タスクを自動的に再起動できるようにし、さらに需要のピークに対処できるだけの処理能力を与えることが必須となります。 たとえば、十分なリソースを備えたコンピューティング インスタンスを割り当てるか、要求をいったんキューに格納しておき後で需要が落ち着いたときに処理するメカニズムを実装するか、その両方の手段を組み合わせることが考えられます。

## 調整

バックグラウンド タスクは、複合的な成り立ちを有している場合があり、1 つの結果を得たり、すべての要件を満たしたりするためには、ばらばらに存在するいくつものタスクが必要になることがあります。 そのような場合の常套手段は、より小さなステップ (サブタスク) にタスクを分割し、複数のコンシューマーによって実行できるようにすることです。 複数のステップでジョブが構成されていれば、個々のステップを他のジョブで再利用できるため、効率がよく柔軟性も向上します。 ステップの追加と削除、順序変更も容易に行うことができます。

複数のタスクやステップを調整するのは容易ではありませんが、その解決策として 3 つのパターンがよく知られているので、実装するうえでの参考にしてください。

- **タスクを再利用可能な複数のステップに分解する**です。 アプリケーションは、その処理の対象となる情報に対し、複雑度の異なる多様なタスクを実行しなければならない場合があります。 その処理を一体型のモジュールとして実行するのが、柔軟性は低いものの実装方法としては簡単です。 しかしそのアプリケーション内のどこか他の箇所で同じ処理の一部分が必要になったとき、この方法では、コードのリファクタリングや最適化、再利用の可能性が制限されます。 詳細については、次を参照してください。 [Pipes and Filters パターン](http://msdn.microsoft.com/library/dn568100.aspx)します。
- **タスクの手順の実行を管理する**です。 アプリケーションで実行するタスクが、多数のステップから成り立っていて、その中でリモート サービスを呼び出したり、リモート リソースにアクセスしたりする場合があります。 それぞれのステップは互いに独立しているかもしれませんが、それらを指揮するのは、タスクを実装するアプリケーションのロジックです。 詳細については、次を参照してください。 [Scheduler Agent Supervisor パターン](http://msdn.microsoft.com/library/dn589780.aspx)します。
- **手順については、タスクの失敗した回復を管理する**です。 一連のステップによって実行される作業は、最終的にそれらが集まって整合の取れた操作となるものであり、そのいずれかのステップで障害が発生した場合は、アプリケーション側で元に戻す必要があります。 詳細については、次を参照してください。 [Compensating Transaction パターン](http://msdn.microsoft.com/library/dn589804.aspx)します。

## ライフサイクル (Cloud Services)

 バック グラウンド ジョブを使用して web とワーカー ロールを使用するクラウド サービス アプリケーションを実装する場合、 **RoleEntryPoint** クラスでは適切に使用するためにこのクラスのライフ サイクルを理解しておく。

Web ロールと worker ロールが開始、実行、停止される過程には、明確に区別されたいくつかの段階が存在します。  **RoleEntryPoint** クラスは、一連のこれらのステージが発生しているかを示すイベントを公開します。 それらのイベントを利用して、カスタム バックグラウンド タスクの初期化、実行、停止を行うことができます。 その全体のサイクルは次のとおりです。

- Azure がロールのアセンブリが読み込まれから派生したクラスを検索 **RoleEntryPoint**します。
- このクラスが検出されると、それを呼び出す **RoleEntryPoint.OnStart()**します。 このメソッドをオーバーライドしてバックグラウンド タスクを初期化できます。
- 後に、 **OnStart** メソッドが完了すると、Azure 呼び出し **Application_Start()** が (たとえば、ASP.NET を実行する web ロールの Global.asax など) に存在する場合は、アプリケーションのグローバル ファイルにします。
- Azure 呼び出し **RoleEntryPoint.Run()** と並行して実行される新しいフォア グラウンド スレッドで **OnStart()**します。 このメソッドをオーバーライドしてバックグラウンド タスクを開始できます。
- Azure を初めて呼び出す Run メソッドの終了時に **Application_End()** アプリケーションのグローバル ファイルが、存在する場合と、呼び出しで **RoleEntryPoint.OnStop()**します。 オーバーライドする、 **OnStop** リソースのクリーンアップ、バック グラウンド タスクを停止するメソッド、オブジェクトの破棄し、タスクで使われていた接続を終了します。
- Azure worker ロールのホスト プロセスが停止します。 この時点で、ロールがリサイクルされて再起動します。

詳細と例のメソッドを使用した、 **RoleEntryPoint** を参照してください [Compute Resource Consolidation パターン](http://msdn.microsoft.com/library/dn589778.aspx)します。

## 考慮事項

バックグラウンド タスクを Web ロールで実行するか worker ロールで実行するかは、次の点を考慮して判断してください。

- 既定値 **実行** のメソッドの実装、 **RoleEntryPoint** クラスへの呼び出しに含まれる **Thread.Sleep(Timeout.Infinite)** を維持、ロール無期限にします。 オーバーライドする場合、 **実行** メソッド (これは通常、バック グラウンド タスクを実行するため)、ロール インスタンスをリサイクルするのでない限り、メソッドを終了するコードをすることはできません。
- 一般的な実装、 **実行** メソッドには、個々 のバック グラウンド タスクを開始するコードが含まれていて、すべてのバック グラウンド タスクの状態を定期的にチェックするループ構文です。 障害の発生したタスクを再起動したり、ジョブが完了したことを示すキャンセル トークンを監視したりすることが可能です。
- ハンドルされない例外が特定のバックグラウンド タスクでスローされた場合、ロール内の他のバックグラウンド タスクについては実行を継続し、例外のスローされたタスクだけをリサイクルします。 ただし、共有記憶域などのタスクの外部オブジェクトの破損によって例外が発生した場合、例外を処理して、 **RoleEntryPoint** クラスでは、すべてのタスクを取り消す必要があると、 **実行** メソッドを終了できます。 その後 Azure によってロールが再起動されます。
- 使用して、 **OnStop** メソッドを一時停止またはバック グラウンド タスクを強制終了し、リソースをクリーンアップします。 必然的に、長時間実行されるタスクや複数のステップから成るタスクを停止しなければならない場合があります。データに不整合を来さない方法でいかにそれを実行するかは重要な考慮事項です。 ロール インスタンスが、ユーザーによって開始されたシャット ダウンで実行されるコード以外の何らかの理由で停止したかどうか、 **OnStop** メソッドが強制的に終了されるまで 5 分以内に完了する必要があります。 その時間内に完了するようにコードを作成するか、最後まで実行されなくても支障がないようにコードを設計してください。  
- Azure ロード バランサーがトラフィックをロールはインスタンスの場合、 **RoleEntryPoint.OnStart** メソッドは true を返します。 したがって、すべての初期化コードに配置することを検討、 **OnStart** メソッドが正常に初期化しないロール インスタンスがないすべてのトラフィックを受け取れるようにします。
- メソッドに加えてスタートアップ タスクを使用して、 **RoleEntryPoint** クラスです。 Azure ロード バランサーの設定を初期化して変更する必要がある場合は、スタートアップ タスクを使う必要があります。スタートアップ タスクは、ロールが要求を受け取る前に実行されます。 詳細については、次を参照してください。 [Azure におけるスタートアップ タスクの実行](http://msdn.microsoft.com/library/azure/hh180155.aspx)します。
- スタートアップ タスクにエラーが存在すると、ロールの再起動が強制的に繰り返されることがあります。 この場合、それまでのステージング環境への VIP スワップを実行できなくなる可能性があります。VIP スワップを実行するためには、ロールへの排他アクセスが必要ですが、ロールの再起動中は排他アクセスを取得できないためです。 それを解決するには、次のようにします。
    -  先頭に次のコードを追加、 **OnStart** と **実行** 、ロール内のメソッド。

    ```C#
    var freeze = CloudConfigurationManager.GetSetting("Freeze");
    if (freeze != null)
    {
        if (Boolean.Parse(freeze))
        {
            Thread.Sleep(System.Threading.Timeout.Infinite);
        }
    }
    ```

   - 定義を追加、 **固定** ブール値として設定を選択し、ロールの ServiceDefinition.csdef と ServiceConfiguration.*.cscfg ファイルに値に設定 **false**します。 設定を変更するには、ロールになった場合に再起動を繰り返す、 **true** ロールの実行を凍結し、以前のバージョンにスワップすることを許可します。

## 回復性に関する考慮事項

バックグラウンド タスクが Reliable Services をアプリケーションに提供するためには、その回復力が重要となります。 バックグラウンド タスクを計画、設計する際は、次の点を考慮してください。

- バックグラウンド タスクは、ロールやサービスの再起動を正規の手順で処理できることが必要です。データが破損したり、アプリケーションに不整合をもたらしたりすることは許されません。 実行時間の長いまたは複数手順のタスクの使用を検討 _チェックポイント_ 妥当である場合、永続的なストレージやキュー内のメッセージとして、ジョブの状態を保存することによってです。 たとえば、状態情報をメッセージとしてキューに永続化し、タスクの進行状況に合わせてその状態情報を漸増的に更新します。そうすれば、良好な状態であることが確認できている最新のチェックポイントからタスクを処理することができ、最初からやり直す必要はありません。 Azure Service Bus キューを使っている場合は、メッセージ セッションを使って同じシナリオを実現できます。 保存しを使用してアプリケーションの処理状態を取得することが可能、 [SetState](http://msdn.microsoft.com/library/microsoft.servicebus.messaging.messagesession.setstate.aspx) と [GetState](http://msdn.microsoft.com/library/microsoft.servicebus.messaging.messagesession.getstate.aspx) メソッドです。 設計の信頼性の高いマルチ ステップのプロセスとワークフローの詳細については、次を参照してください。 [Scheduler Agent Supervisor パターン](http://msdn.microsoft.com/library/dn589780.aspx)します。
- を複数のバック グラウンド タスクをホストする web またはワーカー ロールを使用する場合は、オーバーライドを設計、 **実行** メソッドの失敗または停止しているタスクを監視し、それらを再起動します。 これは実用的ではないと、ワーカー ロールを使用して、強制的に worker ロールを終了して再起動する、 **実行** メソッドです。
- バックグラウンド タスクとのやり取りにキューを使っている場合、普段よりも高い負荷がアプリケーションにかかっているときにはキューがバッファーとして働き、タスクに送られた要求を溜めておくことができます。 負荷が低くなったときにタスクの処理が UI に追い付くことができます。 このことはまた、ロールをリサイクルしても UI がブロックされないことを意味します。 詳細については、次を参照してください。 [Queue-based Load Leveling パターン](http://msdn.microsoft.com/library/dn589783.aspx)します。 いくつかのタスクが他よりも重要な場合は、実装を検討して、 [Priority Queue パターン](http://msdn.microsoft.com/library/dn589794.aspx) 重要度の低いものの前にこれらのタスクを実行できるようにします。
- 順序で到着するメッセージをメッセージにエラーが起こる不整合を処理するバック グラウンド タスクによって、開始、またはその他のメッセージの処理を設計する必要があります (とも呼ば _有害メッセージ_)、および複数回配信されるメッセージ。 以下、具体例に沿って説明します。
  - 既存の値に基づいてデータを変更する (たとえば既存の値に加算する) など、特定の順序で処理する必要のあるメッセージが、送信されたときと同じ順序で到着するとは限りません。 また、バックグラウンド タスクの各インスタンスにかかる負荷の変動によって、メッセージを処理するインスタンスが変わったり、メッセージの処理の順番が入れ替わったりする可能性もあります。 特定の順序で処理する必要のあるメッセージは、バックグラウンド タスクが常に正しい順序で処理できるように、シーケンス番号やキーなど、何らかのインジケーターを含んでいる必要があります。 Azure Service Bus を使っている場合、メッセージ セッションを使って配信の順序を保証することができます。 ただし通常は、メッセージの順序が問題とならないようにプロセスを設計した方が効率的です。
  - バックグラウンド タスクは通常、キュー内のメッセージを読み出し (このとき、対象のメッセージは、一時的に他のメッセージ コンシューマーからは見えなくなります)、正常に処理した後でそのメッセージを削除します。 メッセージの処理中にバックグラウンド タスクで障害が発生した場合、読み出しのタイムアウト期間が経過するとそのメッセージが再びキューに現れ、別のタスク インスタンスによって (または同じインスタンスの次回の処理サイクルで) 処理されることになります。 同じメッセージに起因するエラーが繰り返しコンシューマーで発生すると、やがてキューがいっぱいになり、タスクやキュー、最終的にはアプリケーションそのものまでブロックされてしまいます。 そのため、有害なメッセージを検出してキューから除去することが不可欠となります。 Azure Service Bus を使っている場合、エラーの原因となるメッセージを自動的に、または手動で、対応する配信不能キューに移動することができます。
  - キューにあることが保証されます _最低 1 回_ 配信メカニズムが場合があります、同じメッセージ複数回配信します。 また、メッセージの処理後、キューから削除される前にバックグラウンド タスクで障害が発生した場合、そのメッセージは再び処理の対象となります。 バックグラウンド タスクは、1 と 1 のかけ算のように、同じメッセージを繰り返し処理しても、エラーを招いたり、アプリケーションのデータに不整合を来さないことが必要です。 中には、自然にそのような性質を備えている操作もあります (格納された値を特定の新しい値に設定するなど)。 ただし、格納されている既存の値に対して値を加算する際、格納されている値が、メッセージ送信時と同じであることをチェックしなかった場合は、不整合の原因となります。  Azure Service Bus のキューは、重複するメッセージを自動的に削除するように構成できます。
  - Azure ストレージ キューや Azure Service Bus キューなど、一部のメッセージング システムは、メッセージがキューから読み出された回数を示すデキュー カウント プロパティをサポートしています。 反復するメッセージや有害なメッセージの処理には、このプロパティを利用できます。 詳細については、次を参照してください。 [非同期メッセージングの基本](http://msdn.microsoft.com/library/dn589781.aspx) と [Idempotency パターン](http://blog.jonathanoliver.com/2010/04/idempotency-patterns/)します。

## スケーリングとパフォーマンスの考慮事項

バックグラウンド タスクは、システムに負荷がかかっている状況下で、アプリケーションをブロックしないこと、また操作に遅延が生じることによる不整合を起こさないことが重要です。そのような事態を引き起こさないだけのパフォーマンスをバックグラウンド タスクには確保する必要があります。 通常、バックグラウンド タスクをホストするコンピューティング インスタンスをスケーリングすることによってパフォーマンスは向上します。 バックグラウンド タスクを計画、設計する際は、スケーラビリティとパフォーマンスに関して次の点を考慮してください。

- Azure は自動スケールをサポートしています。WebSites、Cloud Services の Web ロールと worker ロール、Virtual Machines にホストされたデプロイに対し、そのときどきの需要と負荷に応じて、または、あらかじめ決められたスケジュールに基づいてスケールアウトし、不要になったら再びスケールインする、といったことが可能です。 この機能を利用することで、運用コストを最小限に抑えつつ、アプリケーション全体の性能を適切な水準に保つことができます。
- バックグラウンド タスクに求められるパフォーマンス要件が Cloud Services アプリケーションの他の領域 (たとえば UI や、データ アクセス レイヤーなどのコンポーネント) と異なる場合、バックグラウンド タスクをまとめて別個の worker ロールでホスティングすれば、UI とバックグラウンド タスクのロールを独立にスケーリングしながら負荷に対応することができます。 バックグラウンド タスク同士でパフォーマンス要件が大きく異なる場合は、それらを別々の worker ロールに分けて、それぞれのロール タイプを別々にスケーリングすることをお勧めします。ただしその場合、より少数のロールに全タスクをまとめた場合と比べ、運用コストが増える可能性があるので注意が必要です。
- 単純にロールをスケーリングするだけでは、負荷がかかった状況下でのパフォーマンス低下を防ぎきれない場合もあります。 処理チェーン全体の一箇所がボトルネックになってしまうことを防ぐためには、ストレージ キューやその他のリソースをスケーリングすることも、場合によっては必要です。 それ以外にも、アプリケーションとバックグラウンド タスクで使われているストレージや各種サービスの最大スループットなどの制限も考慮してください。
- バックグラウンド タスクの設計は、スケーリングを想定して行う必要があります。 たとえば、バックグラウンド タスクは、キューで待機したり適切なキューにメッセージを送信したりするために、使用中のストレージ キューの数を動的に検出できなければなりません。
- 既定では、Web ジョブは、それが関連付けられている Azure WebSites インスタンスに合わせてスケーリングされます。 ただし、1 つのインスタンスとして実行する web ジョブをする場合は、JSON データを含んだ Settings.job ファイルを作成できる **{"is_singleton": true}**します。 これで、関連付けられている Web サイトのインスタンスが複数存在していても、Web ジョブ インスタンスを強制的に 1 つだけ実行させることができます。スケジュール設定されたジョブで、常に単一インスタンスとして実行する必要がある場合などにこの手法を活用できます。

## 関連するパターン

- [非同期メッセージングの基本](http://msdn.microsoft.com/library/dn589781.aspx)
- [自動スケール ガイダンス](http://msdn.microsoft.com/library/dn589774.aspx)
- [Compensating Transaction パターン](http://msdn.microsoft.com/library/dn589804.aspx)
- [Competing Consumers パターン](http://msdn.microsoft.com/library/dn568101.aspx)
- [コンピューティング分割ガイダンス](http://msdn.microsoft.com/library/dn589773.aspx)
- [Compute Resource Consolidation パターン](http://msdn.microsoft.com/library/dn589778.aspx)
- [Gatekeeper パターン](http://msdn.microsoft.com/library/dn589793.aspx)
- [Leader Election パターン](http://msdn.microsoft.com/library/dn568104.aspx)
- [Pipes and Filters パターン](http://msdn.microsoft.com/library/dn568100.aspx)
- [Priority Queue パターン](http://msdn.microsoft.com/library/dn589794.aspx)
- [キュー ベースの負荷平準化プラットフォーム](http://msdn.microsoft.com/library/dn589783.aspx)
- [Scheduler Agent Supervisor パターン](http://msdn.microsoft.com/library/dn589780.aspx)

## 詳細情報

- [worker ロールを使用した Azure アプリケーションのスケーリング](http://msdn.microsoft.com/library/hh534484.aspx#sec8)
- [バックグラウンド タスクの実行](http://msdn.microsoft.com/library/ff803365.aspx)
- [Azure ロールのスタートアップ ライフ サイクル](http://blog.syntaxc4.net/post/2011/04/13/windows-azure-role-startup-life-cycle.aspx) (ブログの投稿)
- [Azure クラウド サービス ロールのライフ サイクル](http://channel9.msdn.com/Series/Windows-Azure-Cloud-Services-Tutorials/Windows-Azure-Cloud-Services-Role-Lifecycle) (ビデオ)
- [Azure Web ジョブ SDK の使用](websites-dotnet-webjobs-sdk-get-started/)
- [Azure キューと Service Bus キューの比較](http://msdn.microsoft.com/library/hh767287.aspx)
- [クラウド サービスの診断を有効にする方法](http://msdn.microsoft.com/library/dn482131.aspx)

