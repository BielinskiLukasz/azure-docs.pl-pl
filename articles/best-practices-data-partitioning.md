<properties
   pageTitle="データのパーティション分割のガイダンス | Microsoft Azure"
   description="パーティションを個別に管理およびアクセスする方法についてのガイダンス"
   services=""
   documentationCenter="na"
   authors="dragon119"
   manager="masimms"
   editor=""
   tags=""/>

<tags
   ms.service="best-practice"
   ms.devlang="na"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="na"
   ms.date="04/28/2015"
   ms.author="masashin"/>

# データのパーティション分割のガイダンス

![](media/best-practices-data-partitioning/pnp-logo.png)

## 概要

多くの大規模なソリューションでは、個別に管理およびアクセスできる複数のパーティションにデータが分割されています。 パーティション分割戦略は、メリットを最大限に活かし、悪影響を最小限に抑えるために、入念に選択する必要があります。 パーティション分割は、拡張性を向上させ、競合を少なくし、パフォーマンスを最適化します。 パーティション分割の二次的メリットとして、データを使用パターンに応じて分割することができるので、古くなったり、使用頻度が低くなったりしているデータを廉価なデータ ストレージにアーカイブすることができます。

## データをパーティション分割する理由

クラウドのほとんどのアプリケーションやサービスは、動作の一環としてデータを保存および取得します。 アプリケーションが使用するデータ ストアのデザインは、システムのパフォーマンス、スループット、および拡張性に大きく影響します。 大規模システムで一般的に使用されるテクニックの 1 つは、データを複数のパーティションに分割することです。

> 用語 _パーティション分割_ このガイダンスとは異なるデータ ストアにデータを物理的に分割するプロセスです。 これは、SQL Server のテーブル分割と同じではなく、概念が異なります。

データをパーティション分割することは、さまざまなメリットをもたらします。 たとえば、次のニーズを満たすことができます。

- **スケーラビリティを向上させる**します。 単一のデータベース システムをスケールアップすると、最終的には物理的なハードウェア限界に到達します。 データを複数のパーティションに分割し、各パーティションを個別のサーバー上でホストすることにより、システムをほとんど無制限にスケールアウトすることができます。
- **パフォーマンスを向上させる**します。 各パーティションでのデータ アクセス操作は、より少量のデータに対して実行されます。 適切な方法でデータをパーティション分割すると、これは非常に高い効率を実現します。 複数のパーティションに影響する操作は、並列に実行できます。 使用するアプリケーションの近くに各パーティションを配置することで、ネットワーク遅延を最小化することができます。
- **可用性を向上させる**します。 データを複数のサーバーにまたがって分割することで、単一障害点を避けることができます。 サーバーで障害が発生するか、計画的なメンテナンスが実行される場合、利用できなくなるのは、そのサーバーのパーティションに格納されているデータだけです。 その他のパーティションでの操作は、続行できます。 パーティションの数を増やすと、単一サーバーの障害が発生しても、利用できなくなるデータの割合は小さくなるので、相対的なインパクトを小さくすることができます。 各パーティションをレプリケートすると、単一パーティション障害が運用に及ぼす影響をさらに小さくすることができます。 また、連続的かつ高度に可用性を保つ必要のある機密データを、可用性の要求と価値の低い (ログ ファイルなどの) データから分離することができます。
- **セキュリティを向上させる**します。 データの特性およびパーティション分割の方法によっては、機密データと非機密データを分割して異なるパーティション、したがって異なるサーバーまたはデータ ストアに格納することが可能です。 こうすることで、特に機密データに対するセキュリティを最適化することができます。
- **運用上の柔軟性**します。 パーティション分割は、運用の微調整、管理効率の最大化、およびコストの最小化を達成するための多くの機会を提供します。 たとえば、各パーティションのデータの重要性に基づいて、管理、監視、バックアップと復元、および他の管理タスクについて、異なる戦略を定義することができます。
- **データ ストアの使用パターンと一致**します。 パーティション分割では、コストとデータ ストアが提供する組み込み機能に基づいて、各パーティションを異なるタイプのデータ ストアにデプロイできます。 たとえば、大量のバイナリ データを BLOB データ ストアに格納し、構造化されたデータをドキュメント データベースに保持することができます。 詳細については、次を参照してください。 [多言語ソリューションを構築する](https://msdn.microsoft.com/library/dn313279.aspx) patterns & practices のガイドで [、拡張性の高いソリューションへのデータ アクセス: を使用して SQL、NoSQL、および Polyglot の永続化](https://msdn.microsoft.com/library/dn271399.aspx) 、Microsoft web サイトです。

一部のシステムでは、メリットよりもオーバーヘッドの方が大きいと見なされて、パーティション分割が実装されていません。 この論拠の一般的な理由を次に示します。

- 多くのデータ ストレージ システムは、パーティション間にまたがる結合をサポートしません。また、パーティション化されたシステムでは参照整合性を維持することは困難になる可能性があります。 (パーティション分割レイヤーの) アプリケーション コードで結合や整合性チェックを頻繁に実装する必要があります。この結果、余分に I/O が発生したり、アプリケーションの複雑度が大きくなったりする可能性があります。
- パーティションを維持する作業は、必ずしも簡単なタスクではありません。 データの揮発性が高いシステムでは、パーティションを定期的に再調整し、競合とホット スポットを少なくする必要があります。
- 一部の一般的なツールは、パーティション化されたデータに対して、そのままでは動作しません。

## パーティションの設計

データは、水平的パーティション分割、垂直的パーティション分割、または機能的パーティション分割の方法でパーティション分割することができます。 選択する戦略は、データをパーティション分割する理由、およびデータを使用するアプリケーションとサービスの要件によって決定されます。

> [AZURE.NOTE] このガイドで説明されているパーティション構成は、基になるデータ ストレージ テクノロジの独立した方法で説明します。 それらの構成は、リレーショナル データベースおよび NoSQL データベースを含む多くのタイプのデータ ストアに適用できます。

### パーティション分割戦略

データをパーティション分割する際に使用される、典型的な 3 つの戦略を次に示します。

- **水平的パーティション分割** (多くの場合と呼ばれる _シャーディング_)。 この戦略では、各パーティションは、自身の権限を持つデータ ストアですが、すべてのパーティションは同じスキーマを持ちます。 各パーティションと呼ばれる、 _シャード_ 、e コマース アプリケーションで顧客の特定セットのすべての注文など、データの特定のサブセットを保持します。
- **垂直的パーティション分割**します。 この戦略では、各パーティションはデータ ストアに含まれる項目のフィールドのサブセットを含みます。 フィールドは、それらの使用パターンに従って分割されます。たとえば、頻繁にアクセスされるフィールドを 1 つの垂直的パーティションに、使用頻度の少ないフィールドをまとめて別の垂直的パーティションに配置します。
- **機能的パーティション分割**します。 この戦略では、システム内の区分可能な各コンテキストによって使用される方法に従って、データは集約されます。 たとえば、請求処理と製品在庫の管理用に複数の個別のビジネス機能を実装する e コマース システムでは、請求データを 1 つのパーティションに、製品在庫データを別のパーティションに格納することができます。

ここで説明する 3 つの戦略は、組み合わせて使用できることに注意してください。  これらの戦略は相互に排他的ではなく、パーティション分割構成を設計する際には、これらすべてを考慮する必要があります。 たとえば、データをシャードに分割し、次に垂直的パーティション分割を使用して、各シャード内のデータをさら分割することができます。 同様に、機能的パーティション分割内のデータをシャードに分割することもできます (垂直的にパーティション分割することもできます)。

ただし、各戦略の異なる要件により、システムの全体的なデータ処理パフォーマンス目標を満たすパーティション分割構成を設計する際に、評価および調整する必要のある、いくつかの競合する問題が発生することがあります。 以降のセクションでは、各戦略について、さらに詳細に説明します。

### 水平的パーティション分割 (シャーディング)

図 1 は、水平的パーティション分割またはシャーディングの概要を示します。 この例では、製品在庫データが製品キーに基づいてシャードに分割されます。 各シャードは、シャード キーの連続する範囲 (A ～ G および H ～ Z) のデータを保持し、アルファベット順に編成されます。

![](media/best-practices-data-partitioning/DataPartitioning01.png)

_図 1. 水平方向にパーティション分割 (シャーディング) データがパーティション キーに基づく_

シャーディングを使用して負荷をより多くのコンピューターに分散することにより、競合を少なくし、パフォーマンスを向上させることができます。 別のサーバーで動作するシャードをさらに追加することで、システムをスケールアウトすることができます。

このパーティション分割戦略を実装する場合に最も重要な要因は、シャーディング キーを選択する方法です。 システムが運用状態に移行した後にキーを変更することは、非常に困難になる可能性があります。 キーは、ワークロードがシャード間で可能な限り均等になるようにデータがパーティション分割されるものである必要があります。 シャード間でデータ量が同じになるようにする必要はありません。重要なことは、要求の数が均等になるようにすることです。一部のシャードでは大量の項目が格納されていても各項目へのアクセス操作は少なく、一方で、他のシャードでは項目数は少なくても各項目へのアクセスは非常に頻繁に発生することがあります。 また、単一のシャードが、シャードをホストするために使用されているデータ ストアのスケール制限を (容量と処理リソースの観点で) 超えないようにする必要があります。

さらに、シャーディング構成では、パフォーマンスと可用性に影響する可能性のあるホットスポット (またはホット パーティション) が作成されないようにする必要があります。 たとえば、顧客の名前の最初の文字ではなく、顧客 ID のハッシュを使用することで、使用頻度にばらつきのある先頭文字を使用することにより発生する不均等を防ぐことができます。 これは、データをパーティション間で均等に分散するために役立つ典型的な手法です。

選択するシャーディング キーは、将来、大きなシャードを小さなシャードに分割する、小さなシャードをマージして大きなシャードにする、またはシャード セットに格納されているデータを定義するスキーマを変更する、などの要件ができるだけ発生しないようにする必要があります。 これらの操作は非常に時間がかかる可能性があり、実行時に 1 つ以上のシャードをオフラインにすることが必要になる場合があります。 シャードをレプリケートすると、他のシャードの分割、マージ、または再構成を行うときに、一部のレプリカをオンラインにしておくことができますが、再構成が行われているときには、これらのシャードに含まれるデータ上で実行できる操作を制限することが必要になる場合があります。 たとえば、シャードの再構成時には、レプリカのデータを読み取り専用にして、不整合の発生を防ぐことが必要になる場合があります。

> 詳細な情報とこれらの考慮事項の多くについてのガイダンスとベスト プラクティス手法データ ストアを設計、実装水平的パーティション分割を参照してください、 [シャーディング パターン](http://aka.ms/Sharding-Pattern)

### 垂直的パーティション分割

垂直的パーティション分割を使用する最も一般的な目的は、最も頻繁にアクセスされる項目をフェッチする操作に関連する I/O とパフォーマンスのコストを削減することです。 図 2 に、垂直的パーティション分割の例の概要を示します。この例では、各データ項目のさまざまなプロパティが異なるパーティションで保持されています。製品の名前 (Name)、説明 (Description)、および価格 (Price) の情報は、在庫量 (Stock) や最終注文日付 (LastOrdered) よりも頻繁にアクセスされます。

![](media/best-practices-data-partitioning/DataPartitioning02.png)

_図 2. の使用パターンによるデータ垂直方向にパーティション分割_

この例では、アプリケーションは、製品の詳細を顧客に表示する際は常に、製品の名前、説明、および価格を一緒にクエリします。 在庫レベルおよび製造元からの最終注文日の 2 つの項目は通常一緒に使用されるので、別のパーティションに保持されています。 このパーティション分割構成のメリットは、変動することが比較的少ないデータ (製品の名前、説明、および価格) を、より動的なデータ (在庫レベルおよび最終注文日) から分離していることです。 アプリケーションにとっては、変動することの少ないデータが頻繁にアクセスされる場合に、それらをメモリ上にキャッシュできるというメリットがあります。

このパーティション分割戦略の別の典型的なシナリオは、機密データのセキュリティを最大化することです。 たとえば、クレジット カードの番号とセキュリティ コードをそれぞれ別のパーティションに格納することができます。

垂直的パーティション分割は、データに対して必要な同時アクセスの量を減らすこともできます。

> 垂直的パーティション分割の細分化するエンティティを部分的に正規化、データ ストア内のエンティティ レベルで動作し、 _ワイド_ 項目のセットを _を絞り込む_ 項目。 垂直的パーティション分割は、HBase や Cassandra など、列指向のデータ ストアに理想的に適しています。 変化する可能性が低い列コレクションのデータの場合は、SQL Server の列ストアを使用することも検討してください。

### 機能的パーティション分割

アプリケーションで各ビジネス エリアまたはサービスの区分のあるコンテキストを識別できる場合、機能的パーティション分割は、分離とデータ アクセスのパフォーマンスを向上する手法を提供します。 機能的パーティション分割の別の一般的な使用法は、読み書き可能なデータをレポート目的で使用される読み取り専用データから分離することです。 図 3 は、機能的パーティション分割の概要を示しており、在庫データが顧客データから分離されています。

![](media/best-practices-data-partitioning/DataPartitioning03.png)

_図 3: 境界のあるコンテキストまたはサブドメインによりデータを機能的パーティション分割_

このパーティション分割戦略は、システムのさまざまな部分にまたがるデータ アクセスの競合を少なくするのに役立ちます。

## 拡張性の観点でのパーティション分割の設計

各パーティションのサイズとワークロードを考慮して、それらを均等に分散することにより、最大の拡張性を達成することが重要です。 ただし、データのパーティションが単一のパーティション ストアの拡張制限を超えないようにすることも必要です。

拡張性の観点でパーティション分割を設計する際には、次の手順に従います。

1. アプリケーションを分析して、各クエリで返される結果セットのサイズ、アクセス頻度、固有の遅延時間、サーバー側のコンピューティング処理要件など、データ アクセス パターンを理解します。 多くの場合、少数の主要なエンティティが最大の処理リソースを要求します。
2. 分析に基づいて、データ サイズやワークロードなどの現在および将来の拡張性目標を決定し、拡張性目標を満たすようにパーティション全体にデータを分散します。 水平的パーティション分割戦略では、均等に分散するために適切なシャード キーを選択する必要があります。 詳細については、次を参照してください。、 [シャーディング パターン](http://aka.ms/Sharding-Pattern)します。
3. 各パーティションで利用できるリソースが、データ サイズとスループットの観点で拡張性の要件を満たすことを確認します。 たとえば、パーティションをホストしているノードで、ストレージ領域、処理能力、またはネットワーク帯域幅のサイズに関してハード的な制限があることがあります。 ストレージと処理能力の要件がこれらの制限を超える可能性がある場合、パーティション分割戦略を再調整するか、データをさらに分割することが必要になることがあります。 たとえば、1 つの拡張性アプローチとして、別のデータ ストアを使用してログ データを主要なアプリケーション機能から分離し、データ ストレージ全体での要件がノードの拡張性制限を超えないようにすることができます。 データ ストアの総数がノード制限を超える場合、別のストレージ ノードを使用することが必要になる場合があります。
4. 使用中のシステムを監視して、データが想定どおりに分散されており、それぞれのパーティションで負荷が適切に処理されていることを検証します。 使用状況が分析で期待されたものとは一致せず、パーティションを再調整することが必要になることがあります。 再調整できない場合、必要とされる均等性を達成するために、システムの一部を再設計することが必要になる場合があります。

一部のクラウド環境では、リソースがインフラストラクチャ境界の観点で割り当てられるので、選択した境界の制限が、データ ストレージ、処理能力、および帯域幅の観点で、データ量の想定される成長を収容できることを確認する必要があります。 たとえば、Azure テーブル ストレージを使用する場合、ビジー状態のシャード必要がありますが要求を処理する 1 つのパーティションで利用できるその他のリソース (一定の時間に 1 つのパーティションで処理できる要求の量に制限がある-ページを参照して [Azure ストレージのスケーラビリティおよびパフォーマンスのターゲット](https://msdn.microsoft.com/library/azure/dn249410.aspx) 詳細については、Microsoft web サイト)。 この場合、負荷を分散するために、シャードを再パーティション分割することが必要な場合があります。 これらのテーブルの合計サイズまたはスループットがストレージ アカウントの容量を超える場合、追加のストレージ アカウントを作成して、テーブルをそれらのアカウント全体で分散することが必要な場合があります。 ストレージ アカウントの数がサブスクリプションで利用できるストレージ アカウントの数を超える場合、複数のサブスクリプションを使用することが必要な場合があります。

## クエリ パフォーマンスの観点でのパーティション分割の設計

クエリのパフォーマンスは、多くの場合、小さなデータ セットと並列クエリ実行を使用することで、格段に向上できます。 各パーティションにデータ セット全体の小さな割合を収容することで、容量が小さくなるので、クエリのパフォーマンスが向上します。 ただし、パーティション分割は、データベースを適切に設計および構成することの代替にはなりません。 たとえば、リレーショナル データベースを使用している場合は、必要なインデックスが構成されていることを確認します。

クエリ パフォーマンスの観点でパーティション分割を設計する際には、次の手順に従います。

1. アプリケーションの要件とパフォーマンスを検証します。
    - ビジネス要件を使用して、常に高速に実行する必要のある重要なクエリを決定します。
    - システムを監視して、低速で実行するクエリを識別します。
    - 最も頻繁に実行されるクエリを見つけます。 各クエリの単一インスタンスのコストは少ない場合でも、累積されたリソース消費量は非常に大きくなる場合があります。 これらのクエリによって取得されるデータを個別のパーティションまたはキャッシュに配置することが適切な場合があります。
2. パフォーマンスの低下を引き起こしているデータをパーティション分割します。 次の点に注意します。
    - クエリの応答時間がターゲット時間内になるように各パーティションのサイズを制限します。
    - 水平的パーティション分割を実装しようとしている場合、アプリケーションが簡単にパーティションを見つけられる方法でシャード キーを設計します。 これにより、クエリがすべてのパーティションを通してスキャンする必要がなくなります。
    - クエリのパフォーマンスを考慮して、パーティションの場所を検討します。 可能な限り、パーティションのデータを、それにアクセスするアプリケーションやユーザーに地理的に近い場所に維持します。
3. エンティティにスループットとクエリ パフォーマンスの要件がある場合、そのエンティティに基づく機能的パーティション分割を使用します。 これでは要件が満たされない場合、水平的パーティション分割も適用します。 ほとんどの場合、単一のパーティション分割戦略で十分ですが、両方の戦略を組み合わせて使用することが効果的な場合があります。
4. パフォーマンスを向上させるために、パーティション全体で並列に実行する非同期クエリを使用することを検討します。

## 可用性の観点でのパーティション分割の設計

データをパーティション分割すると、データセット全体が単一障害点となることはなく、またデータセットの個々のサブセットを個別に管理できるので、アプリケーションの可用性が向上します。 機密データを含んでいるパーティションをレプリケートすることでも、可用性を向上できます。

パーティションを設計および実装する際には、可用性に影響する次の要因を検討します。

- 業務に対するデータの重要度。 一部のデータは、請求書の詳細や銀行取引情報など、ビジネス上の機密情報を含むことがあります。 その他のデータは、ログ ファイルやパフォーマンス トレースなど、単純に機密性の低い運用データである可能性があります。 各データの種類を識別したら、次の点を考慮します。
    - 機密データを可用性の高いパーティションに格納し、適切なバックアップ プランを構築します。
    - 各データセットのさまざまな重要度に応じて、個別の管理および監視のメカニズムまたは手順を確立します。 同じレベルの重要度を持つデータを同じパーティションに配置して、適切な頻度で一緒にバックアップできるようにします。 たとえば、銀行取引のデータを保持するパーティションでは、ログ情報またはトレース情報を保持するパーティションよりも頻繁にバックアップすることが必要な場合があります。
- 個々のパーティションを管理する方法。 個別に管理および保守ができるようにパーティションを設計すると、いくつかのメリットが生じます。 次に例を示します。
    - 1 つのパーティションで障害が発生した場合、他のパーティションのデータにアクセスするアプリケーションのインスタンスに影響を及ぼすことなく、そのパーティションを個別に復旧できます。
    - 地理的な場所に基づいてデータをパーティション分割すると、各場所のオフピーク時間に保守タスクが実行されるようにスケジュールできます。 計画された保守タスクがこの期間内に完了するように、パーティションのサイズが大きすぎないことを確認します。
- 機密データをパーティション全体でレプリケートすることの必要性。 この戦略は、可用性とパフォーマンスを向上させますが、整合性に関して問題を発生させることもあります。 パーティションのデータに対して行われた変更がすべてのレプリカと同期されるのに時間がかかり、この期間は、さまざまなパーティションが異なるデータ値を持つ可能性があります。

## 問題と注意事項

パーティション分割を使用すると、システムの設計および開発で複雑さが増大します。 初期においてシステムが単一のパーティションのみを含んでいる場合でも、パーティション分割をシステム設計の基盤として考慮することが必要です。 システムでパフォーマンスおよび拡張性の問題が発生しだしてから、パーティション分割を付け足しで構築しようとすると、保守する必要のあるライブ システムが既に存在するので、複雑さが大きくなるだけです。 この環境でパーティション分割に対応できるようにシステムを更新すると、データ アクセス ロジックを変更することが必要になるだけでなく、ユーザーがシステムを使い続けることができると期待している期間に、大量の既存データをパーティション全体に分散して移行する必要もあります。

場合によっては、初期のデータ セットが小さく、単一サーバーで容易に処理できるので、パーティション分割は重要ではないと見なされます。 これは、システムが初期サイズを超えてスケールすることはないと想定されるシステムでは正しいですが、多くの商用システムでは、ユーザー数の増加に従って、拡張できることが必要になります。 この拡張は、一般的に、データ量の増加を伴います。 パーティション分割は、必ずしも大規模データ ストア用の機能ではないことも理解する必要があります。 たとえば、小さなデータ ストアが数百の同時クライアントによって過度にアクセスされることがあります。 このような状況でデータをパーティション分割すると、競合を少なくし、スループットを向上させることができます。

データパーティション分割構成を設計する際には、次の点を考慮する必要があります。

- 可能な限り、最も頻度の高いデータベース操作で対象となるデータを各パーティションで一緒になるように配置して、パーティションをまたがるデータ アクセス操作を最小限にします。 パーティションをまたがるクエリは、単一パーティション内だけのクエリよりも時間がかかることがあります。また、あるクエリ セットに対してパーティションを最適化すると、別のクエリ セットが悪影響を受けることがあります。 クエリでパーティションをまたがることが避けられない場合にクエリの時間を最小化するには、パーティション上で並列クエリを実行し、アプリケーション内で結果を集約します。 ただし、この方法は状況によっては実現できないことがあります。たとえば、あるクエリの結果を取得して、次のクエリで使用することが必要な場合です。
- クエリで、郵便番号表や製品リストなど比較的静的な参照データが使用される場合、すべてのパーティションでこのデータをレプリケートして、それぞれのパーティションで個別の検索操作が必要にならないようにすることを検討します。 この方法は、参照データが、システム全体からの過度なトラフィックの対象である "ホット" データセットになる可能性を小さくしますが、この参照データに対して発生する可能性のあるあらゆる変更を同期化することに伴う追加コストも発生します。
- 可能な限り、垂直的パーティション間、および機能的パーティション間での参照整合性の要件を最小化します。 これらの構成では、データが更新および消費された場合に、パーティション間での参照整合性を、アプリケーション自体が維持する必要があります。 複数のパーティション間でデータを結合する必要のあるクエリは、同一パーティション内でのみデータを結合するクエリよりも低速に実行します。これは、アプリケーションが一般的に、キーに基づいてクエリを実行し、続いて外部キーに基づいてクエリを実行する必要があるためです。 このような状況では、パーティション分割の代わりに、関連するデータのレプリケートまたは非正規化を検討します。 パーティション間結合が必要な場合にクエリ時間を最小化するには、パーティション上で並列クエリを実行し、データをアプリケーション内で結合します。
- パーティション分割構成がパーティション間のデータ整合性に及ぼす影響を考慮します。 強力な整合性が実際に要件であるかどうかを評価する必要があります。 クラウドでの一般的な手法では、強力な整合性の代わりに、結果整合性を実装します。 各パーティションのデータは個別に更新され、アプリケーションのロジックはすべての更新が正常に完了したことを確認することができます。また、結果整合性の操作が実行している間、データをクエリすることにより発生する可能性のある不整合を処理することができます。 結果整合性を実装する方法の詳細については、「Consistency Guidance (整合性ガイダンス)」を参照してください。(#insertlink#)
- クエリが正しいパーティションを見つける方法を考慮します。 必要なデータを見つけるためにクエリがすべてのパーティションをスキャンする必要がある場合、複数の並列クエリを使用している場合でも、パフォーマンスに非常に大きな影響を及ぼします。 垂直的パーティション分割および機能的パーティション分割と共に使用されるクエリは、本質的にパーティションを指定できますが、 水平的パーティション分割 (シャーディング) が使用される場合、すべてのシャードが同じスキーマを持つので、項目を見つけることが困難になる可能性があります。 シャーディングに対する一般的な解決法は、データの特定の項目のシャード場所を検索するために使用できるマップを維持することです。 このマップは、アプリケーションのシャーディング ロジックに実装することも、データ ストアが透過的シャーディングをサポートする場合にはデータ ストアにより維持されるようにすることもできます。
- 水平的パーティション分割戦略を使用する場合、シャードを定期的に再調整して、サイズおよびワークロードが均等になるようにデータを分散することにより、ホットスポットの最小化、クエリ パフォーマンスの最大化、および物理ストレージ制限の回避を達成します。 ただし、これは複雑なタスクで、多くの場合、カスタム ツールまたはカスタム プロセスの使用が必要になります。
- 各パーティションをレプリケートすると、障害に対する保護能力が高まります。 単一のレプリカで障害が発生しても、動作しているコピーにクエリを振り向けることができます。
- パーティション分割戦略の物理制限に到達した場合、拡張性を別のレベルに拡張することが必要な場合があります。 たとえば、パーティション分割がデータベース レベルで行われる場合、パーティションを複数のデータベースで配置したりレプリケートしたりすることが必要になる場合があります。 パーティション分割が既にデータベース レベルで行われており、物理制限が問題になっている場合、パーティションを複数のホスティング アカウントで配置したりレプリケートしたりすることが必要な可能性があります。
- トランザクションでは、複数のパーティションのデータにアクセスしないようにします。 一部のデータ ストアには、データを変更する操作に対してトランザクション レベルの一貫性と整合性を保つ機能を実装していますが、これが有効になるのは、データが単一のパーティションに配置されている場合だけです。 複数のパーティションにまたがってトランザクション レベルのサポートを必要とする場合、ほとんどのパーティション分割システムでこの機能はネイティブにサポートされていないので、アプリケーション ロジックの一部として実装することが必要になる可能性があります。

すべてのデータ ストアで運用の管理および監視のアクティビティが必要です。 これらのタスクには、データのロード、データのバックアップおよび復元、データの再編成、システムが正しく効率よく動作していることの確認などがあります。

運用管理に影響する次の要因を考慮してください。

- データをパーティション分割する際には、バックアップと復元、データのアーカイブ、システムの監視、その他の管理タスクなど、適切な管理と運用のタスクを実装する方法を検討します。 たとえば、バックアップと復元の操作では論理的な一貫性を維持することが課題になります。
- データを複数のパーティションにロードする方法と、他のソースから到着する新しいデータを追加する方法。 一部のツールおよびユーティリティでは、データを正しいパーティションにロードするなど、シャード化されているデータの操作がサポートされていないことがあります。このため、新しいツールおよびユーティリティの作成または取得が必要になることがあります。
- パーティションの過度な成長を防止するために、定期的に (たとえば、月単位で) データをアーカイブして削除する方法。 異なるアーカイブ スキーマに一致するように、データを変換することが必要な場合があります。
- あるパーティションに存在するデータが別のパーティションに存在する情報を参照しているが、その情報が実際には存在しない、などのデータ整合性の問題を見つけるプロセスを定期的に実行することを検討します。 このようなプロセスでは、問題を自動的に修復するか、問題を手動で修正してもらうために、オペレーターに警告を発行するかのいずれかを実装できることがあります。 たとえば、e コマース アプリケーションでは、注文情報が 1 つのパーティションで保持されているが、各注文を構成する行項目が別のパーティションで保持されていることがあります。 注文を格納するプロセスは、データを両方のパーティションに追加する必要があります。 このプロセスに障害が発生すると、対応する注文のない行項目が格納される可能性があります。

一般的に、データ ストレージ テクノロジそれぞれに、パーティション分割をサポートするための独自の機能があります。 次のセクションでは、Azure アプリケーションで一般的に使用されるデータ ストアによって実装されているオプションの概要と、これらの機能を最大限に活用できるようにアプリケーションを設計するための考慮事項について説明します。

## Azure SQL Database 用のパーティション分割戦略

Azure SQL Database はクラウドで動作するサービスとしてのリレーショナル データベースです。 Microsoft SQL Server を基盤にしています。 リレーショナル データベースでは、情報はテーブルに分割されます。各テーブルは、エンティティに関する情報を一連の行として保持します。 各行には、エンティティの個々のフィールドのデータを保持する列が含まれます。  [Azure SQL Database](https://msdn.microsoft.com/library/azure/ee336279.aspx) 、Microsoft web サイト] ページでは、SQL データベースの作成とについて詳しく説明します。

## Elastic Scale での水平的パーティション分割

単一の SQL データベースには保持できるデータ量に制限があり、スループットにはアーキテクチャ上の要因とアーキテクチャがサポートする同時接続数による制約があります。 Azure SQL Database には、SQL データベースの水平的な拡張性をサポートする Elastic Scale が用意されています。 Elastic Scale を使用することで、複数の SQL データベースにまたがってデータをシャードにパーティション分割できます。また、処理する必要のあるデータ量が増加または減少する場合にシャードを追加または削除できます。 さらに、Elastic Scale を使用して負荷をデータベース全体に分散することにより、競合を少なくすることもできます。

> [AZURE.NOTE] Elastic Scale は、2015 年 1 月時点でプレビューします。 これは、廃止が予定されている Azure SQL Database Federations の後継版となります。 Azure SQL データベース フェデレーションの既存のインストールを使用して Elastic Scale に移行できる、 [Federations Migration Utility](https://code.msdn.microsoft.com/vstudio/Federations-Migration-ce61e9c1)します。 また、Elastic Scale によって提供される機能がユーザーのシナリオに本質的に適合しない場合は、独自のシャーディング メカニズムを実装することもできます。

各シャードは、SQL データベースとして実装されます。 シャードが 1 つ以上のデータセットを保持できます (と呼ばれる、 _シャードレット_)、し、各データベースが格納されているシャードレットを記述するメタデータを保持します。 シャードレットは単一のデータ項目であることも、同じシャードレット キーを共有する項目グループであることもできます。 たとえば、マルチテナント アプリケーションでデータをシャーディングしている場合、シャードレット キーをテナント ID にし、特定のテナントのすべてのデータを同じシャードレットの一部として保持することができます。 他のテナントのデータは、異なるシャードレットに保持されます。

プログラマーは、データセットをシャードレット キーに関連付ける処理を実装する必要があります。 個別の SQL データベースは、各データベースのシャードレットについての情報と共に、システム全体を構成するデータベース (シャードレット) の一覧を含むグローバル シャードマップ マネージャーとして動作します。 データにアクセスするクライアント アプリケーションは、最初に、グローバル シャードマップ マネージャー データベースに接続し、シャードマップ (シャードとシャードレットの一覧) のコピーを取得して、ローカルにキャッシュします。 次に、アプリケーションはこの情報を使用して、データ要求を該当するシャードに転送します。 この機能は、NuGet パッケージとして利用できる Azure SQL Database Elastic Scale Client Library に含まれる一連の API の背後に隠されています。 ページ [Azure SQL Database Elastic Scale の概要](sql-database-elastic-scale-introduction.md) 、microsoft web サイトが Elastic Scale のより包括的な概要を提供します。

> [AZURE.NOTE] 待機時間を短縮し、可用性を向上させるには、グローバル シャード マップ マネージャー データベースをレプリケートすることができます。 Premium 価格レベルの 1 つを使用してデータベースを実装する場合、アクティブ geo レプリケーションを構成して、データを異なるリージョン内のデータベースに連続してコピーできます。 ユーザーが存在する各リージョンにデータベースのコピーを作成し、このコピーに接続してシャードマップを取得するようにアプリケーションを構成します。

> 別の方法として、Azure SQL データ同期または Azure Data Factory パイプラインを使用して、リージョン間でシャードマップ マネージャー データベースをレプリケートします。 この形態のレプリケーションは定期的に実行され、シャードマップの変更がまれな場合に適しています。 さらに、シャードマップ マネージャー データベースは、Premium の価格レベルを使用して作成する必要はありません。

Elastic Scale では、データをシャードレットにマップし、シャードに格納するために、2 つの構成を利用できます。

- リスト シャード マップは、単一キーとシャードレットとの間の関連を定義します。 たとえば、マルチテナント システムで、各テナント用のデータを一意なキーに関連付けて、独自のシャードレットに格納することができます。 プライバシーと分離を保証するために (テナントが別のテナントに提供されているデータ ストレージ リソースを枯渇させないようにするために)、各シャードレットは独自のシャード内に保持できます。

![](media/best-practices-data-partitioning/PointShardlet.png)

_図 4: -個別のシャードにテナント データを格納するリスト シャード マップを使用します。_

- 範囲シャードマップは、一連の連続するキー値とシャードレットとの間の関連を定義します。 前に取り上げたマルチテナントの例で、専用のシャードレットを実装する代わりに、それぞれに独自のキーを持つ一連のテナントのデータを、同一のシャードレット内にグループ化できます。 この構成は、複数のテナントがデータ ストレージ リソースを共有するので、最初の構成よりも安価ですが、データのプライバシーと分離が維持できなくなるリスクがあります。

![](media/best-practices-data-partitioning/RangeShardlet.png)

_図 5: データを格納する範囲のテナントのシャードに範囲シャード マップを使用します。_

単一のシャードは複数のシャードレットのデータを含むことができることに注意してください。 たとえば、リスト シャードレットを使用してさまざまな非連続テナントのデータを同一のシャードに格納できることがあります。 同一のシャード内で範囲シャードレットとリスト シャードレットを混在させることもできます。ただし、それぞれは、グローバル シャードマップ マネージャー データベースの別のマップを通してアドレス指定されます (グローバル シャードマップ マネージャー データベースは、複数のシャードマップを含むことができます)。 図 6 は、この手法を説明しています。

![](media/best-practices-data-partitioning/MultipleShardMaps.png)

_図 6: -複数シャード マップの実装_

パーティション分割構成の実装方法によっては、システムのパフォーマンスに非常に大きな影響を与えることがあります。また、シャードの追加/削除の頻度、シャード全体で再パーティション分割されるデータにも影響を及ぼします。 Elastic Scale を使用してデータをパーティション分割する際には、次の点を考慮する必要があります。

- 一緒に使用されるデータを同一のシャードにグループ化し、複数のシャードに保持されているデータにアクセスする必要のある操作が発生しないようにします。 Elastic Scale では、シャードは独自の権限を持つ SQL データベースで、Azure SQL Database はデータベース間結合をサポートしません。これらの操作は、クライアント側で実行される必要があります。 また、Azure SQL Database では、1 つのデータベース内の参照整合性制約、トリガー、およびストアド プロシージャは、別のデータベースのオブジェクトを参照できません。このため、シャード間に依存関係のあるシステムを設計しないでください。 ただし、SQL データベースでは、クエリや他の操作で頻繁に使用される参照データのコピーを保持するテーブルを持つことができます。また、これらのテーブルは、特定のシャードレットに属する必要はありません。 このデータをシャード間でレプリケートすると、データベースをまたがってデータを結合する必要性をなくすことができる可能性があります。 理想的には、そのようなデータは静的であるか移動頻度が低く、レプリケーション負荷が最小であり、無効となる機会がないものにする必要があります。

    > [AZURE.NOTE] Azure SQL データベースがデータベースにまたがる結合をサポートしていませんが、Elastic Scale API では、シャード マップによって参照されるすべてのシャードレットに保持されているデータを透過的に反復処理するシャード間クエリを実行することができます。 Elastic Scale API はシャード間クエリを一連の個々のクエリ (データベースごとに 1 つずつ) に分割し、すべての結果をマージします。 詳細については、次を参照してください。、 [マルチシャード クエリ実行](sql-database-elastic-scale-multishard-querying.md) 、Microsoft web サイトのページです。

- 同じシャードマップに属するシャードレットに格納されるデータは、同じスキーマを持つ必要があります。 たとえば、テナント データを含むシャードレットと製品情報を含む別のシャードレットをポイントするようなリスト シャードマップを作成しないでください。 このルールは Elastic Scale によって強制されませんが、各シャードレットに異なるスキーマが存在すると、データ管理とクエリが非常に複雑になります。 前の例では、2 つのリスト シャードマップを作成する必要があります。1 つはテナント データを参照し、他の 1 つは製品情報をポイントします。 異なるシャードレットに属するデータを、同じシャードに格納できることに注意してください。

    > [AZURE.NOTE] Elastic Scale API のシャード間クエリ機能は、同じスキーマを含むシャード マップ内の各シャードレットに依存します。
- トランザクション操作は、同一のシャード内で保持されているデータを対象にする場合にのみサポートされます。シャード間ではサポートされません。 トランザクションは、シャードレットをまたがってデータにアクセスできますが、シャードレットが同一のシャードに属する場合に限られます。 このため、ビジネス ロジックがトランザクションを実行する必要がある場合、影響を受けるデータを同一のシャードに格納するか、または結果整合性を実装します。 詳細については、データ整合性のガイダンスを参照してください。
- シャードを、シャードのデータにアクセスするユーザーの近くに配置します (geo 配置シャード) この戦略は、遅延を小さくするのに役立ちます。
- アクセス頻度の非常に高いシャード (ホットスポット) と低いシャードが混在しないようにします。 シャード間で負荷が均等に分散されるようにします。 これを行うには、シャードレット キーをハッシュ処理することが必要になることがあります。
- geo 配置シャードを実装する場合、ハッシュ処理されたキーが、データにアクセスするユーザーの近くに格納されているシャードに保持されているシャードレットにマッピングすることを確認する必要があります。
- 現時点では、種類がシャードレット キーとしてサポートされている SQL データのセットが制限のみ _int、bigint、varbinary、_ と _uniqueidentifier_します。 SQL _int_ と _bigint_ に対応する型、 _int_ と _長い_ 、C# の場合は、データ型同じ範囲があるとします。 SQL _varbinary_ を使用して型を処理できる、 _バイト_ 配列では、c#、および SQL _uniqueidentier_ 種類に対応する、 _Guid_ .NET Framework クラスにします。

名前が示すように、Elastic Scale を使用すると、データ量が増加または減少するに従って、シャードを追加または削除することができます。 Azure SQL Database Elastic Scale Client Library の API を使用すると、アプリケーションからシャードを動的に作成および削除 (さらにはシャードマップ マネージャーを透過的に更新することが) できます。ただし、シャードを削除する操作は、そのシャード内のすべてのデータの削除を要求する破壊的な操作です。 アプリケーションで、1 つのシャードを 2 つのシャードに分割する、または複数のシャードを 1 つのシャードにマージする必要がある場合、Elastic Scale には、個別の Split/Merge サービスが用意されています。 このサービスはクラウドでホストされたサービス内で動作し、シャード間でデータを安全に移動します。このクラウドでホストされるサービスは、開発者が作成する必要があります。 詳細については、トピックを参照してください。 [Elastic Scale による分割とマージ](sql-database-elastic-scale-overview-split-and-merge.md) 、Microsoft web サイトです。

## Azure Storage 用のパーティション分割戦略

Azure Storage は、データを管理するための 3 つの抽象化概念を提供します。

- Table Storage: 拡張性のある構造化ストレージを実装します。 テーブルには、エンティティのコレクションが含まれ、各エンティティは一連のプロパティおよび値で構成されます。
- Blob Storage: 大きなオブジェクトおよびファイル用のストレージを提供します。
- ストレージ キュー: アプリケーション間の信頼性のある非同期メッセージ処理をサポートします。

Table Storage と Blob Storage は、本質的にキー値ストアで、それぞれ構造化データおよび非構造化データを保持するように最適化されています。 ストレージ キューは、疎結合で拡張性のあるアプリケーションを構築するメカニズムを提供します。 Table Storage、Blob Storage、およびストレージ キューは、Azure ストレージ アカウントのコンテキスト内で作成されます。 Azure ストレージ アカウントは、冗長性に関して 3 つの形態をサポートします。

- ローカル冗長ストレージ: 単一のデータセンター内に 3 つのデータ コピーを維持します。 この形態の冗長性は、ハードウェア障害に対して保護を提供しますが、データセンター全体を使用不能にする災害に対しては保護を提供しません。
- ゾーン冗長ストレージ: 同じリージョン内 (または地理的に近い 2 つのリージョン間) の異なるデータセンター間で 3 つのデータ コピーを維持します。 この形態の冗長性は、単一のデータセンター内で発生する災害に対して保護を提供できますが、リージョン全体に影響する大規模なネットワーク切断に対しては保護を提供できません。 ゾーン冗長ストレージは現在、ブロック BLOB に対してのみ利用できることに注意してください。
- geo 冗長ストレージ: 6 つのデータ コピーを維持します。3 つのコピーを 1 つのリージョン (ローカル リージョン) に、別の 3 つのコピーをリモート リージョンに維持します。 この形態の冗長性は、災害に対する最高レベルの保護を提供します。

マイクロソフトでは、Azure ストレージ アカウントのスケーラビリティ ターゲットを公開します。ページを参照して [Azure ストレージのスケーラビリティおよびパフォーマンスのターゲット](https://msdn.microsoft.com/library/azure/dn249410.aspx) 、Microsoft web サイトです。 現在、ストレージ アカウントの総容量 (Table Storage および Blob Storage に保持されているデータのサイズと、ストレージ キューに保持されている未処理のメッセージのサイズの合計) は、500 TB を超えることはできません。 最大要求レート (1 KB のエンティティ、BLOB、またはメッセージのサイズを想定) は、20,000/秒です。 システムでこれらの制限を超えることが想定される場合は、負荷を複数のストレージ アカウント間でパーティション分割することを検討します。単一の Azure サブスクリプションで、最大 100 のストレージ アカウントを作成できます。 ただし、これらの制限は将来変更される可能性があることに注意してください。

## Azure Table Storage のパーティション分割

Azure Table Storage は、パーティション分割に対応するために、キーと値を格納するように設計されています。 すべてのエンティティは、パーティションに格納され、パーティションは Azure Table Storage によって内部的に管理されます。 テーブルに格納される各エンティティは、2 つの部分で構成されるキーを提供します。

- パーティション キー: これは文字列値で、Azure Table Storage がこのエンティティを配置するパーティションを決定するために使用されます。 同じパーティション キーを持つすべてのエンティティは、同じパーティションに格納されます。
- 行キー: これは別の文字列値で、パーティション内のエンティティを識別します。 パーティション内のすべてのエンティティは、このキーの昇順で辞書的に並び替えられます。 パーティション キーと行キーの組み合わせは、各エンティティで一意になる必要があり、1 KB の長さを超えることはできません。

エンティティのデータの残りの部分は、アプリケーションで定義されたフィールドで構成されます。 特定のスキーマが強制されることはありません。各行は、異なるセットのアプリケーションで定義されたフィールドを持つことができます。 唯一の制限は、エンティティのパーティション キーと行キーを含む最大サイズで、現在は 1 MB です。 これらの値が、将来変更可能性がありますが、テーブルの最大サイズは 200 TB (ページを確認して [Azure ストレージのスケーラビリティおよびパフォーマンスのターゲット](https://msdn.microsoft.com/library/azure/dn249410.aspx) これらの制限に関する最新情報について、Microsoft web サイトです。 この容量を超えるエンティティを格納する必要がある場合、複数のテーブルに分割することを検討します。垂直的パーティション分割を使用し、フィールドを最も一緒にアクセスされる頻度の高いグループに分割します。

図 7 に、架空の e コマース アプリケーションのサンプル ストレージ アカウント (Contoso Data) の論理構造を示します。 このストレージ アカウントは、3 つのテーブル (Customer Info、Product Info、および Order Info) を含み、各テーブルには複数のパーティションがあります。 Customer Info テーブルでは、データは顧客の所在地の市に従ってパーティション分割され、行キーには顧客 ID が含まれます。 Product Info テーブルでは、製品が製品カテゴリによってパーティション分割され、行キーには製品番号が含まれます。 Order Info テーブルでは、注文が注文日によってパーティション分割され、行キーには、注文が受信された時刻が指定されます。 すべてのデータは、各パーティションで行キーの順に並べられることに注意してください。

![](media/best-practices-data-partitioning/TableStorage.png)

_図 7: -テーブルとサンプル ストレージ アカウント内のパーティション_

> [AZURE.NOTE] また、azure テーブル ストレージは、各エンティティにタイムスタンプ フィールドを追加します。 タイムスタンプ フィールドは Table Storage により維持され、エンティティが変更されるごとに更新されて、パーティションに書き戻されます。 Table Storage サービスはこのフィールドを使用して、緩やかな同時アクセス制御を実装します (アプリケーションがエンティティを Table Storage に書き戻すごとに、Table Storage サービスは、書き込まれるエンティティのタイムスタンプの値と Table Storage に保持されている値を比較します。異なる場合は、エンティティの取得後に別のアプリケーションがエンティティを変更していると判断され、書き込み操作は失敗します)。 アプリケーションのコードでこのフィールドを変更しないでください。また、新しいエンティティを作成する際に、このフィールド用の値を指定しないでください。

Azure Table Storage は、パーティション キーを使用して、データを格納する方法を決定します。 以前に使用されていないパーティション キーを使用してエンティティがテーブルに追加される場合、Azure Table Storage はこのエンティティ用に新しいパーティションを作成します。 同じパーティション キーを持つ別のエンティティは、同じパーティションに格納されます。 このメカニズムは、自動スケールアウト戦略を効果的に実装します。 各パーティションは (単一パーティションからデータを取得するクエリが高速に実行できるようにするために) Azure データセンターの単一サーバーに格納されますが、それぞれのパーティションは、複数のサーバー間で分散して格納することができます。 また、単一のサーバーが複数のパーティションをホストすることもできます (これらのパーティションにサイズの制限がある場合)。

Azure Table Storage 用にエンティティを設計する際には、次の点を考慮する必要があります。

- パーティション キーと行キーの値を選択する際には、データがアクセスされる方法に主眼を置く必要があります。 パーティション キーと行キーの組み合わせは、クエリの大半をサポートするように選択する必要があります。 最も効率的にクエリを実行するには、パーティション キーと行キーを指定してデータを取得します。 パーティション キーと連続する行キーの範囲を指定するクエリは、単一のパーティションをスキャンすることによって結果が返されます。データは行キーの順序で並んでいるため、このクエリは比較的高速に実行されます。 クエリでパーティション キーが指定されていない場合、Azure Table Storage はすべてのパーティションをスキャンしてデータを探す可能性があります。

    > [AZURE.TIP] エンティティにナチュラル キーがある場合は、パーティション キーとして使用し、行キーとして、空の文字列を指定します。 エンティティに 2 つのプロパティで構成される複合キーがある場合、変化の少ない方のプロパティをパーティション キーとして選択し、別のプロパティを行キーとして指定します。 エンティティに 3 つ以上のキー プロパティがある場合、プロパティの連結を使用して、パーティション キーと行キーを指定します。

- パーティションと行キー以外のフィールドを使用してデータを検索するクエリを定期的に実行する場合を実装することを検討してください、 [インデックス テーブル パターン](https://msdn.microsoft.com/library/dn589791.aspx)します。
- 単純に増加または減少する数列 ("0001"、"0002"、"0003"、…など) を使用してパーティション キーを生成する場合で、各パーティションには少量のデータしか含まれない場合、Azure Table Storage は、これらのパーティションを物理的にグループ化して、同一のサーバーに配置することがあります。 このメカニズムでは、アプリケーションはパーティションの連続した範囲を対象にするクエリ (範囲クエリ) を実行する可能性が最も高く、このようにすることで最適化されると想定します。 ただし、この手法は、新しいエンティティのすべての挿入操作が連続する範囲の 1 つの末尾または別の末尾に集中する可能性があるので、単一サーバー上にホットスポットを発生させる可能性があります。 また、拡張性が損なわれる可能性もあります。 サーバー間で負荷をさらに均等に分散するために、パーティション キーをハッシュ処理して、数列をさらにランダム化することを検討します。
- Azure Table Storage は、同一パーティションに属するエンティティに対するトランザクション操作をサポートします。 これは、アプリケーションが、複数の挿入、更新、削除、置換、またはマージの操作を 1 つのアトミック単位として実行できることを意味します (トランザクションの対象としては、100 を超えるエンティティを含まず、要求のペイロードのサイズは 4 MB を超えないようにする必要があります)。 複数のパーティションにまたがる操作はトランザクションとしてはサポートされません。また、データ整合性ガイドラインで説明されている結果整合性を実装することが必要になることがあります。 テーブル ストレージとトランザクションの詳細については、次を参照してください。、 [エンティティ グループ トランザクションの実行](https://msdn.microsoft.com/library/azure/dd894038.aspx) 、Microsoft web サイトのページです。
- パーティション キーの粒度については、入念に注意を払ってください。
    - すべてのエンティティで同じパーティション キーを使用すると、Table Storage サービスにより、1 つのサーバー上に保持される単一の大きなパーティションが作成されます。これにより、スケールアウトが機能しなくなり、負荷が単一サーバーに集中します。 結論として、この手法が適しているのは、少量のエンティティを管理するシステムだけです。 ただし、この手法では、すべてのエンティティをエンティティ グループ トランザクションの対象にすることができます。
    - 各エンティティに対して一意なパーティション キーを使用すると、Table Storage サービスにより、エンティティごとに異なるパーティションが作成され、結果として、エンティティのサイズに依存して小さなパーティションが大量に作成される可能性があります。 この手法は、単一パーティション キーの手法よりも拡張性に優れていますが、エンティティ グループ トランザクションは可能ではなく、複数のエンティティをフェッチするクエリが複数のサーバーからの読み込みを実行する可能性があります。 ただし、アプリケーションが範囲クエリを実行し、単純数列を使用してパーティション キーを生成すると、これらのクエリが最適化される可能性があります。
    - エンティティのサブセット間でパーティション キーを共有すると、関連するエンティティをグループ化して同一のパーティションに格納できます。 関連するエンティティにアクセスする操作は、エンティティ グループ トランザクションを使用して実行でき、一連の関連するエンティティをフェッチするクエリは単一サーバーにアクセスするだけで結果が返される可能性があります。

Azure テーブル ストレージでデータをパーティション分割の詳細については、記事を参照して [Azure テーブル ストレージのスケーラブルなパーティション分割戦略の設計](https://msdn.microsoft.com/library/azure/hh508997.aspx) 、Microsoft web サイトです。

## Azure Blob Storage のパーティション分割

Azure Blob ストレージでは、ページ blob のバイナリ ラージ オブジェクト、現在に最大サイズは、ブロック blob で 200 GB または 1 TB を保持することができます (最新の情報を参照してください、 [Azure ストレージのスケーラビリティおよびパフォーマンスのターゲット](https://msdn.microsoft.com/library/azure/dn249410.aspx) 、Microsoft web サイト] ページ)。 大量のデータを高速にアップロードまたはダウンロードする必要があるストリーミングのようなシナリオでは、ブロック BLOB を使用します。 データの一部への順次アクセスではなくランダム アクセスを必要とするアプリケーションでは、ページ BLOB を使用します。

ブロック BLOB とページ BLOB のいずれも、Azure ストレージ アカウントのコンテナーに保持されます。 コンテナーを使用することにより、同じセキュリティ要件を持つ関連する BLOB をグループ化することができます。ただし、このグループ化は、物理的ではなく論理的に行われます。 コンテナー内では、各 BLOB は一意な名前を持ちます。

Blob Storage は、BLOB 名に基づいて自動的にパーティション分割されます。 各 BLOB は独自のパーティションに保持され、同じコンテナー内の BLOB がパーティションを共有することはありません。 このアーキテクチャにより、同じコンテナー内のそれぞれの BLOB はそれぞれ異なるサーバーに分散される可能性があるので、Azure Blob Storage ではサーバー間で負荷が透過的に均等化されます。

単一のブロック (ブロック BLOB) またはページ (ページ BLOB) を書き込む操作はアトミックですが、複数のブロック、ページ、または BLOB にまたがる操作はアトミックではありません。 複数のブロック、ページ、または BLOB にまたがる書き込み操作の実行中に一貫性を確保するには、BLOB リースを使用して書き込みロックを取得する必要があります。

Azure Blob Storage は、最大 60 MB/秒の転送速度、または各 BLOB に対して最大 500/秒の要求をサポートします。 これらの制限を超えることが予想され、BLOB データが比較的静的である場合、Azure Content Delivery Network (CDN) を使用して BLOB をレプリケートすることを検討します。 詳細については、ページを参照してください。 [Azure 用 CDN の使用](cdn-how-to-use.md) 、Microsoft web サイトです。 その他のガイダンスおよび考慮事項については、Content Delivery Network (CDN) に関する記事を参照してください。

## Azure ストレージ キューのパーティション分割

Azure ストレージ キューを使用すると、プロセス間の非同期メッセージ処理を実装できます。 Azure ストレージ アカウントは任意の数のキューを含むことができ、各キューは任意の数のメッセージを含むことができます。 唯一の制限は、ストレージ アカウントで利用できる領域です。 個々のメッセージの最大サイズは、64 KB です。 このサイズよりも大きいメッセージを必要とする場合は、代わりに Azure Service Bus キューの使用を検討します。

各ストレージ キューは、それを含むストレージ アカウント内で一意な名前を持ちます。 Azure はこの名前に基づいてキューをパーティション分割します。同じキューのすべてのメッセージは同一のパーティションに格納され、単一のサーバーにより制御されます。 負荷を均等化するために、キューごとに異なるサーバーで管理することができます。 サーバーへのキューの割り当ては、アプリケーションおよびユーザーにとって透過的です。 大規模なアプリケーションでは、アプリケーションのすべてのインスタンスに対して同一のストレージ キューを使用しないでください。この手法では、キューをホストするサーバーがホットスポットになる可能性があるためです。アプリケーションの機能分野ごとに異なるキューを使用してください。 Azure ストレージ キューはトランザクションをサポートしません。このため、メッセージを別のキューに転送することは、メッセージ処理の一貫性にほとんど影響を与えません。

Azure ストレージ キューは、最大 2,000 メッセージ/秒を処理できます。  これよりも多いメッセージを処理する必要がある場合、複数のキューを作成することを検討します。 たとえば、グローバル アプリケーションで、複数のストレージ アカウントのそれぞれにストレージ キューを作成し、各リージョンで動作するアプリケーション インスタンスを処理します。

## Azure Service Bus 用のパーティション分割戦略

Azure Service Bus はメッセージ ブローカーを使用して、Service Bus のキューまたはトピックに送信されるメッセージを処理します。 既定では、キューまたはトピックに送信されるすべてのメッセージは、同一のメッセージ ブローカー プロセスによって処理されます。 このアーキテクチャにより、メッセージ キューの全体的なスループットに制限が生じる可能性があります。 ただし、作成したキューまたはトピックを設定して作成されたとき、 _EnablePartitioning_ するキューまたはトピックの説明のプロパティ _true_します。 パーティション分割されたキューまたはトピックは複数のフラグメントに分割され、それぞれのフラグメントは個別のメッセージ ストアおよびメッセージ ブローカーにより返されます。 これらのフラグメントの作成および管理は、Service Bus によって行われます。 アプリケーションがメッセージをパーティション分割されたキューまたはトピックに送信すると、Service Bus はメッセージをそのキューまたはトピックのフラグメントに割り当てます。 アプリケーションがメッセージをキューまたはサブスクリプションから受信すると、Service Bus は各フラグメントで次に利用可能なメッセージが存在するかどうかを確認し、存在する場合はそのメッセージを処理するために、アプリケーションに渡します。 この構造は、メッセージ ブローカー間およびメッセージ ストア間で負荷を分散するのに役立ち、拡張性と可用性を向上させます。1 つのフラグメントのメッセージ ブローカーまたはメッセージ ストアが一時的に利用できなくなると、Service Bus は利用可能な残りのフラグメントの 1 つからメッセージを取得できます。

Service Bus は、次の手順に従って、メッセージをフラグメントに割り当てます。

- メッセージがセッションに所属している場合は、_ sessionid _ プロパティに同じ値を持つすべてのメッセージが、同一のフラグメントに送信されます。
- メッセージは、セッションに属していませんが、送信者がの値を指定された場合、 _PartitionKey_ プロパティには、[すべてのメッセージでは、同じ _PartitionKey_ 値は、同一のフラグメントに送信されます。

    > [AZURE.NOTE] 場合、 _SessionId_ と _PartitionKey_ プロパティ両方を指定し、メッセージが拒否される同じ値がそれ以外の場合に設定する必要があります。
- 場合、 _SessionId_ と _PartitionKey_ メッセージのプロパティが指定されていないが、重複データ検出が有効になっている、 _MessageId_ プロパティが使用されます。 すべてのメッセージでは、同じ _MessageId_ 、同一のフラグメントに送信されます。
- メッセージに含まれない場合、 _SessionId、PartitionKey、_ または _MessageId_ プロパティには、Service Bus はメッセージを割り当てます、ラウンド ロビン方式でフラグメントです。 あるフラグメントが利用できない場合、Service Bus は次のフラグメントに移動します。 この方式により、メッセージ インフラストラクチャで一時的な障害が発生しても、メッセージ送信操作が失敗することはありません。

Service Bus でのメッセージのキューまたはトピックをパーティション分割するかどうか、また、パーティション分割する方法を決定する際には、次の点を考慮する必要があります。

- Service Bus のキューとトピックは、Service Bus 名前空間のスコープ内で作成されます。 Service Bus は、現在、名前空間あたり最大 100 のパーティション分割されたキューまたはトピックをサポートします。
- 各 Service Bus 名前空間は利用可能なリソースについてクォータが適用されます。これらのリソースには、トピックあたりのサブスクリプションの数、秒あたりの同時送受信要求の数、確立可能な同時接続の最大数などがあります。 これらのクォータ] ページで、Microsoft web サイトについては [Service Bus のクォータ](https://msdn.microsoft.com/library/azure/ee732538.aspx)します。 これらの値を超えることが予想される場合、独自のキューとトピックを持つ追加の名前空間を作成し、負荷をこれらの名前空間間で分散します。 たとえば、グローバル アプリケーションで、リージョンごとに個別の名前空間を作成し、最も近い名前空間のキューとトピックを使用するように、アプリケーション インスタンスを構成します。
- トランザクションの一部として送信されるメッセージでは、パーティション キーを指定する必要があります。 これは、 _SessionId、PartitionKey、_ または _MessageId_します。 同一トランザクションの一部として送信されるすべてのメッセージは、同じパーティション キーを指定する必要があります。これは、これらのメッセージが同一のメッセージ ブローカー プロセスによって処理される必要があるためです。 同一トランザクション内のメッセージを異なるキューまたはトピックに送信することはできません。
- パーティション分割されたキューまたはトピックがアイドル状態になったときに、自動的に削除されるように構成することはできません。
- クロスプラットフォームまたはハイブリッドのソリューションを構築している場合、現在、Advanced Message Queuing Protocol (AMQP) を使用するパーティション分割されたキューおよびトピックを使用することはできません。

## Azure DocumentDB 用のパーティション分割戦略

Azure DocumentDB は NoSQL データベースで、ドキュメントを格納できます。 DocumentDB のドキュメントは、オブジェクトまたは他の種類のデータの JSON シリアル化された表現です。 すべてのドキュメントは一意な ID を含む必要があることを除いて、いずれの固定されたスキーマも強制されません。

ドキュメントはコレクションに編成されます。 コレクションを使用することにより、関連するドキュメントをグループ化できます。 たとえば、ブログ投稿を維持するシステムでは、各ブログ投稿のコンテンツをドキュメントとしてコレクションに格納し、各サブジェクト タイプのコレクションを作成できることがあります。 また、さまざまな著者が自身のブログ投稿を制御および管理できるシステムなどのマルチテナント アプリケーションでは、ブログを著者別にパーティション分割して、著者ごとに個別のコレクションを作成できることがあります。 コレクションに割り当てられるストレージ領域は、弾力性があり、必要に応じて縮小または拡大できます。

ドキュメント コレクションは、単一データベース内でデータをパーティション分割するための自然なメカニズムを提供します。 内部的には、DocumentDB データベースは複数のサーバーに分散できるので、DocumentDB はコレクションをサーバー間に分散して負荷を分散しようとすることがあります。 シャーディングを実装するための最も簡単な方法は、各シャード用にコレクションを作成することです。

> [AZURE.NOTE] 各 DocumentDB での観点で、リソースが割り当てられている、 _パフォーマンス レベル_します。 パフォーマンス レベルには、関連する _要求単位_ (RU) レートの制限です。 RU レートの制限は、そのコレクションに予約されており、そのコレクションによって排他使用できるリソースの量を指定します。 コレクションのコストは、そのコレクションによって選択されたパフォーマンス レベルに依存します。パフォーマンス レベル (および RU レートの制限) が高くなるほど、料金も高くなります。 コレクションのパフォーマンス レベルは、Microsoft Azure 管理ポータルを使用することにより調整できます。 詳細については、ページを参照してください。 [DocumentDB のパフォーマンス レベル](documentdb-performance-levels.md) 、Microsoft web サイトです。

すべてのデータベースは、DocumentDB アカウントのコンテキストで作成されます。 単一の DocumentDB アカウントは複数のデータベースを含むことができ、データベースの作成先となるリージョンを指定します。 各 DocumentDB アカウントは、独自のアクセス制御を強制します。 DocumentDB アカウントを使用して、シャード (データベース内のコレクション) をそれらにアクセスする必要のあるユーザーの近くに geo 配置し、それらのユーザーだけがそれらのシャードに接続できるように制限を強制することができます。

各 DocumentDB アカウントには、収容できるデータベースおよびコレクションの数と、利用可能なドキュメント ストレージの量を制限するクォータがあります。 これらの制限は常に変化しますが、ページを参照して [DocumentDB の制限とクォータ](documentdb-limits.md) 、Microsoft web サイトです。 すべてのシャードが同一データベースに属するシステムを実装することは理論的には可能ですが、アカウントのストレージ容量制限に到達する可能性があります。 このような場合、追加の DocumentDB アカウントとデータベースを作成し、シャードをこれらのデータベース間で分散することが必要になることがあります。 ただし、データベースのストレージ容量制限に到達する可能性が少ない場合でも、複数のデータベースを使用すると、各データベースで独自のユーザーとアクセス権限のセットを定義できるというメリットを活用することができます。 このメカニズムを使用することにより、データベース単位でコレクションへのアクセスを分離できます。

図 8 に、DocumentDB アーキテクチャの構造の概要を示します。

![](media/best-practices-data-partitioning/DocumentDBStructure.png)

_図 8: -DocumentDB の構造_

クライアント アプリケーションは、要求を適切なシャードに転送する必要があります。このためには、通常、シャード キーを定義するデータのいくつかの属性に基づく、独自のマッピング メカニズムを実装します。 図 9 に、シャードとして機能する 2 つのコレクションをそれぞれに含む、2 つの DocumentDB データベースを示します。 データはテナント ID を使用してパーティション分割され、特定のテナント用のデータを含みます。 データベースは、それに含まれるデータに関連するテナントと同じリージョンに配置されている別の DocumenDB アカウントに作成されます。 クライアント アプリケーションのルーティング ロジックは、テナント ID をシャード キーとして使用します。

![](media/best-practices-data-partitioning/DocumentDBPartitions.png)

_図 9: -Azure DocumentDB を使用したシャーディングの実装_

DocumentDB でデータをパーティション分割する方法を決定する際には、次の点を考慮する必要があります。

- DocumentDB データベースで利用できるリソースは、DocumentDB アカウントのクォータ制限の対象になります。 各データベースは複数のコレクションを保持できます (制限あり)。各コレクションには、そのコレクションの RU レートの制限 (予約されているスループット) を管理する、関連するパフォーマンス レベルがあります。 詳細については、次を参照してください。、 [DocumentDB の制限とクォータ](documentdb-limits.md) 、Microsoft web サイトのページです。
- 各ドキュメントには、それが保持されるコレクション内でそれを一意に識別するために使用できる属性が存在する必要があります。 これは、ドキュメントの保持先となるコレクションを定義するシャード キーとは異なります。 コレクションは大量のドキュメントを含むことができます。理論的には、ドキュメント ID の最大長によってのみ制限されます。 ドキュメント ID の最大長は、255 文字です。
- ドキュメントに対するすべての操作は、ドキュメントが含まれているコレクションに制限されるトランザクションのコンテキスト内で実行されます。 操作が失敗すると、それまでに実行された作業はロールバックされます。  ドキュメントは操作の対象ですが、実行されるすべての変更は、スナップショット レベルで分離されます。 このメカニズムは、たとえば、新しいドキュメントを作成する要求が失敗すると、同時にデータベースをクエリしている別のユーザーが、その時点で削除された不完全なドキュメントを見ることはないことを保証します。
- DocumentDB クエリもまた、コレクション レベルの範囲に制限されます。 単一のクエリは、1 つのコレクションからのデータのみを取得できます。 複数のコレクションからデータを取得する必要がある場合、各コレクションを個別にクエリし、結果をアプリケーション コードでマージする必要があります。
- DocumentDB はプログラム可能な項目をサポートします。これらはすべて、ドキュメントと一緒にコレクションに格納できます。これらの項目としては、ストアド プロシージャ、ユーザー定義の関数、および JavaScript で記述されたトリガーがあります。 これらの項目は、同一コレクション内の任意のドキュメントにアクセスできます。 さらに、これらの項目は、ドキュメントに対して実行された作成、削除、または置換の操作の結果として起動されるトリガーの場合には、アンビエント トランザクションのスコープ内で実行します。また、明示的なクライアント要求の結果として実行されるストアド プロシージャの場合には、新しいトランザクションを開始することによって実行されます。 プログラム可能な項目内のコードが例外をスローすると、トランザクションはロールバックされます。 ストアド プロシージャとトリガーを使用してドキュメント間の整合性と一貫性を維持できますが、これらのドキュメントはすべて、同一のコレクション内に含まれている必要があります。
- DocumentDB アカウントのデータベースに保持することが想定されているコレクションが、コレクションのパフォーマンス レベルによって定義されているスループット制限を超えないことを確認する必要があります。 これらの制限を参照して、 [DocumentDB の容量が必要な](documentdb-manage.md) 、Microsoft web サイトのページです。 これらの制限に到達することが予想される場合は、異なる DocumentDB アカウントのデータベースにまたがってコレクションを分割して、コレクションごとの負荷を軽減します。

## Azure Search 用のパーティション分割戦略

データを検索する機能は、多くの Web アプリケーションによって提供されるナビゲーションと探索の主要な方法です。この機能を使用することにより、ユーザーは、検索条件の組み合わせに基づいて、リソース (たとえば、e コマース アプリケーションでの製品) をすばやく見つけることができます。 Azure Search サービスは、Web コンテンツに対するフルテキスト検索機能に加えて、先行入力、近似一致に基づくクエリ候補表示、ファセット ナビゲーションなどの機能を提供しています。 これらの機能の詳しい説明については、 [Azure Search の概要](https://msdn.microsoft.com/library/azure/dn798933.aspx) 、Microsoft web サイトのページです。

Search サービスは、検索可能なコンテンツを JSON ドキュメントとしてデータベースに格納します。 これらのドキュメントの検索可能なフィールドを指定するインデックスを定義し、これらの定義を Search サービスに提供します。 ユーザーが検索要求を発行すると、Search サービスは適切なインデックスを使用して一致する項目を検索します。

競合を少なくするために、Search サービスによって使用されるストレージは、最大 1、2、3、4、6、または 12 のパーティションに分割でき、各パーティションは最大 6 回レプリケートできます。 レプリカの数によって乗算されたパーティションの数の積と呼ばれる、 _検索単位_ (SU)。 Search サービスの単一インスタンスは、最大 36 SU を含むことができます (12 のパーティションを持つデータベースは、最大 3 つのレプリカをサポートします)。 課金は、サービスに割り当てられている各 SU に対して行われます。 検索可能なコンテンツの量、または検索要求の割合が増加した場合、Search サービスの既存のインスタンスに SU を追加して、増加した負荷を処理できます。 Search サービス自体が、パーティション間でドキュメントを均等に分散します。手動によるパーティション分割戦略は、現時点でサポートされていません。

各パーティションは、最大 1,500 万のドキュメント、または 300 GB のストレージ領域のいずれか少ない方を収容できます (ドキュメントとインデックスのサイズによって異なります)。 最大 50 のインデックスを作成できます。 サービスのパフォーマンスは、ドキュメントの複雑さ、利用可能なインデックス、およびネットワーク遅延の影響によって異なります。 平均すると、単一レプリカ (1 SU) は 15 クエリ/秒 (QPS) を処理できます。ただし、スループットをより正確に測定するために、自身のデータを使用してベンチマークを実行する必要があります。 詳細については、次を参照してください。、 [制限および制約 (Azure Search API)]( https://msdn.microsoft.com/library/azure/dn798934.aspx) 、Microsoft web サイトのページです。

> [AZURE.NOTE] 検索可能なドキュメントのデータ型の限られたセットを格納することができます。文字列、ブール値、数値データ、datetime データ、および地理的なデータの一部です。 詳細については、次を参照してください。、 [サポートされるデータ型 (Azure Search)]( https://msdn.microsoft.com/library/azure/dn798938.aspx) 、Microsoft web サイトのページです。

Azure Search サービスがサービスの各インスタンス用にデータをパーティション分割する方法については、限定された制御しかできません。 ただし、グローバル環境でパフォーマンスを改善し、次の方法のいずれかを使用しているサービスをパーティション分割によって遅延と詳細の競合を削減できる時間ができます。

- 各リージョンで Search サービスのインスタンスを作成し、クライアント アプリケーションの要求が最も近い利用可能なインスタンスに転送されることを確認します。 この戦略では、検索可能なコンテンツに対するすべての更新がサービスのすべてのインスタンスに対して、遅れることなくレプリケートされる必要があります。
- 2 層の Search サービスを作成します。各リージョンに、そのリージョンで最も頻繁にアクセスされるデータを含むローカル サービスを作成し、さらに、すべてのデータを収容するグローバル サービスを作成します。 ユーザーは、部分的な結果を高速に取得する場合はローカル サービスに、低速であるが完全な結果を得る場合はグローバル サービスに、要求を転送できます この手法は、検索対象のデータに大きな地域的な相違がある場合に最も適しています。

## Azure Redis Cache 用のパーティション分割戦略

Azure Redis Cache は、Redis キー/値データ ストアに基づく、クラウド内の共有キャッシュ サービスを提供します。 名前が示すように、Azure Redis Cache はキャッシュ ソリューションを意図しており、恒久的なデータ ストアとしてではなく一時的なデータを保持するためにのみ使用する必要があります。Azure Redis Cache を利用するアプリケーションは、キャッシュが利用できない場合でも、継続して動作できる必要があります。 Azure Redis Cache はプライマリ/セカンダリ レプリケーションをサポートし、高可用性を提供しますが、現在、最大キャッシュ サイズは 53 GB に制限されています。 このサイズを超える領域を必要とする場合は、追加のキャッシュを作成する必要があります。 詳細については、次を参照してください。、 [Microsoft Azure Cache](http://azure.microsoft.com/services/cache/) 、Microsoft web サイトのページです。

Redis データ ストアをパーティション分割する場合、Redis サービスのインスタンス全体でデータを分割します。 各インスタンスは、単一パーティションを構成します。 Azure Redis Cache はファサードの背後に Redis サービスを抽象化し、それらが直接アクセスされないようにします。 パーティション分割を実装する最も簡単な方法は、複数の Azure Redis Cache を作成し、データをそれら全体に分散することです。 各データ項目を識別子 (パーティション キー) に関連付けることによって、データ項目の格納先となるキャッシュを指定することができます。 クライアント アプリケーション ロジックはこの識別子を使用して、要求を適切なパーティションにルーティングできます。 この構成は非常に単純ですが、パーティション分割構成が変更されると (たとえば、追加の Azure Redis Cache が作成されると)、クライアント アプリケーションの再構成が必要になる場合があります。

Azure Redis Cache ではないネイティブ Redis は、Redis クラスタリングに基づくサーバー側のパーティション分割をサポートします。 この手法では、ハッシュ メカニズムを使用することにより、データがサーバー間で均等に分散されます。 各 Redis サーバーは、パーティションが保持するハッシュ キーの範囲を定義するメタデータを格納します。また、他のサーバーのパーティションに配置されているハッシュ キーに関する情報も含みます。 クライアント アプリケーションは単純に要求を、パーティション分割された任意の Redis サーバー (最も近いサーバーの可能性大) に送信します。Redis サーバーはクライアント要求を検証し、ローカルで解決できる場合は要求された操作を実行します。それ以外の場合は、要求を適切なサーバーに転送します。 このモデルは Redis クラスタ リングを使用して実装し、の詳細については説明、 [Redis クラスター チュートリアル](http://redis.io/topics/cluster-tutorial) 、Redis web サイトのページです。 Redis クラスタリングはクライアント アプリケーションにとって透過的なものであり、クライアントを再構成しなくても追加の Redis サーバーをクラスター (および再パーティション分割されたデータ) に追加できます。

> [AZURE.IMPORTANT] Azure Redis Cache では、Redis クラスタ リングを現在はサポートしていません。 Azure でこの手法を実装したい場合は、一連の Azure 仮想マシンに Redis をインストールし、手動で構成することにより、独自の Redis サーバーを実装する必要があります。 ページ [Azure の CentOS Linux VM で Redis を実行している](http://blogs.msdn.com/b/tconte/archive/2012/06/08/running-redis-on-a-centos-linux-vm-in-windows-azure.aspx) 、microsoft web サイトをビルドして、Azure VM として実行される Redis ノードを構成する方法を示すサンプルについて説明します。

ページ [パーティション分割: 複数の Redis インスタンス間でデータを分割する方法](http://redis.io/topics/partitioning) web サイトは、Redis で Redis でパーティション分割の実装に関する詳細情報を提供します。 このセクションの以降の説明では、クライアント側またはプロキシに支援されたパーティション分割を実装していると想定します。

Azure Redis Cache でデータをパーティション分割する方法を決定する際には、次の点を検討する必要があります。

- Azure Redis Cache は恒久的なデータ ストアとして動作するようには意図されていません。このため、実装するパーティション分割構成に関係なく、データがキャッシュに見つからない状況を受け入れ、その場合には別の場所から取得するように、アプリケーション コードを実装する必要があります。
- 頻繁に一緒にアクセスされるデータは、同一パーティションに維持します。 Redis は強力なキー/値ストアで、データを構造化するための高度に最適化された一連のメカニズムを提供します。対象となるデータの範囲は、単純な文字列 (実際には、最大 512 MB 長のバイナリ データ) から、リスト (キューおよびスタックとして動作可能)、セット (順序ありおよび順序なし)、ハッシュ (オブジェクト内のフィールドを表す項目などの関連するフィールドをグループ化することが可能) などの集約型に至ります。 集約型を使用すると、多くの関連する値を同じキーに関連付けることができます。Redis キーは、それが含むデータ項目ではなく、リスト、セット、またはハッシュを識別します。 これらの種類の Azure Redis Cache ですべて利用できますが、によって説明されて、 [データ型](http://redis.io/topics/data-types) 、Redis web サイトのページです。 たとえば、顧客により登録された注文を追跡する e コマース システムの一部として、各顧客の詳細情報を、顧客 ID をキーとして使用して Redis ハッシュに格納できる場合があります。 各ハッシュは、その顧客の注文 ID のコレクションを保持できることがあります。 別の Redis セットで注文を保持できることがあります。この場合も、ハッシュとして構造化され、注文 ID をキーとして使用します。  図 10 に、この構造を示します。 Redis では、いずれの形態の参照整合性も実装しないので、開発者は、顧客と注文の間の関係を維持するロジックを組み込む必要があります。

![](media/best-practices-data-partitioning/RedisCustomersandOrders.png)

_図 10: の顧客の注文とその詳細を記録するために Redis ストレージで推奨される構造_

> [AZURE.NOTE] Redis ですべてのキー (Redis 文字列) のようなバイナリ データ値、理論的には、キーがほぼすべての情報を含めることができますので、最大 512 MB のデータを含めることができます。 ただし、キーに対して一貫した名前付け規則を適用し、データの型をわかりやすく表し、エンティティを識別し、しかも過度に長すぎないような名前を割り当てます。 一般的な手法では、"entity_type:ID" の形のキーを使用します。たとえば、"customer:99" は ID 99 の顧客のキーを示します。

- 関連する情報を同一データベースの異なる集約型に格納することによって、垂直的パーティション分割を実装できます。 たとえば、e コマース アプリケーションで、製品について共通してアクセスされる情報を 1 つの Redis ハッシュに格納し、アクセス頻度の低い詳細情報を別の Redis ハッシュに格納できることがあります。 両方のハッシュは、キーの一部として同じ製品 ID を次に例を使用できます"製品:_nn_"場所 _nn_ 製品情報については、製品 id を指定し、"product_details: _nn_"詳細データ用です。 この戦略は、ほとんどのクエリが取得する可能性が高いデータの量を少なくするのに役立てることができます。
- Redis データ ストアを再パーティション分割する操作は、複雑で時間のかかるタスクです。 Redis クラスタリングではデータの再パーティション分割を自動的に実行できますが、この機能は、Azure Redis Cache とは併用できません。 このため、パーティション分割構成を設計する際には、各パーティションに十分な空き領域を確保して、予想される将来のデータ増加に最初から備える必要があります。 ただし、Azure Redis Cache はデータを一時的にキャッシュすることを意図しており、キャッシュに保持されるデータは有効期間 (TTL) 値として指定される期間だけ有効であることに注意する必要があります。 揮発性が比較的高いデータには、TTL を短くする必要があり、静的なデータでは、TTL を非常に長くすることができます。 有効期間の長いデータをキャッシュに大量に格納しないでください。このデータにより、キャッシュがいっぱいになる可能性があります。 強制退去ポリシーを指定して、利用できる領域が少ない場合に Azure Redis Cache がデータを削除できるようにすることができます。

    > [AZURE.NOTE] Azure Redis キャッシュは、適切な価格レベルを選択して (から 53 GB に 250 MB) キャッシュの最大サイズを指定するようにことができます。 ただし、いったん Azure Redis Cache を作成したら、その後にはサイズを大きくしたり小さくしたりすることはできません。

- Redis のバッチおよびトランザクションは、複数の接続を利用できないので、バッチまたはトランザクションによりアクセスされるすべてのデータは同一のデータベース (シャード) で保持する必要があります。

    > [AZURE.NOTE] Redis のトランザクションで操作のシーケンスは、必ずしもアトミックではないです。 トランザクションを構成するコマンドは、実行前に検証されてキューに登録されます。この段階でエラーが発生すると、キュー全体が破棄されます。 ただし、トランザクションが正常に発行されると、キューに登録されていた一連のコマンドが正しい順序で実行されます。 いずれかのコマンドで障害が発生すると、そのコマンドだけが中止され、キュー内の後続のコマンドは実行されます。 アトミック操作を実行する必要がある場合、 詳細については、次を参照してください。、 [トランザクション](http://redis.io/topics/transactions) 、Redis web サイトのページです。

- Redis は、限定された数のアトミック操作をサポートします。複数のキーと値をサポートするこの種の操作は、指定したキー リストの値のコレクションを返す MGET と指定したキー リストの値のコレクションを格納できる MSET だけです。 これらの操作を使用する必要がある場合、MSET コマンドと MGET コマンドによって参照されるキー/値ペアは、同一のデータベースに格納される必要があります。

## パーティションの再調整

システムが安定し、使用パターンが適切に理解されるようになったら、パーティション分割構成を調整することが必要になる場合があります。 これは、パーティション間でトラフィック量に不均衡が生じ、特定のパーティションがホットスポットになり、過度な競合が発生しているために起きることがあります。 また、一部のパーティションでデータ量が過少に見積もられており、これらのパーティションでストレージ容量の制限に近づいていることもあります。 原因が何であるかに関係なく、パーティションを再調整して、負荷をより均等に分散することが必要になることがあります。

状況によっては、データをサーバーに透過的に割り当てているデータ ストレージ システムは、利用可能なリソースの制限内でパーティションを自動的に再調整できます。 その他の状況では、再調整は、次の 2 段階で構成される管理タスクとなります。

1. 分割またはマージすることが必要なパーティションを特定し、新しいパーティション キーを設計してこれらの新しいパーティションにデータを割り当てる方法を確定して、新しいパーティション分割戦略を決定します。
2. 影響を受けるデータを古いパーティション分割構成から一連の新しいパーティションに移行します。

> [AZURE.NOTE] サーバーへの DocumentDB コレクションのマッピングは透過的でが、DocumentDB アカウントのストレージの容量とスループットの制限に到達する可能性がありますも、このような場合、パーティション分割構成のデザインを変更し、データを移行する必要があります。

データ ストレージのテクノロジとデータ ストレージ システムの設計によっては、パーティションが使用されている間に、データをパーティション間で移行できることがあります (オンライン移行)。 これが不可能な場合、データを再配置する間、影響を受けるパーティションを一時的に利用できないようにすることが必要になることがあります (オフライン移行)

## オフライン移行

オフライン移行は、競合が発生する機会を少なくするので、ほぼ間違いなく、最も簡単な手法です。移行対象のデータは、移動および再構成時に変更されることはありません。

概念的に、このプロセスは次の手順で構成されます。

1. シャードをオフラインにします。
2. データを分割/マージして、新しいシャードに移動します。
3. データを検証します。
4. 新しいシャードをオンラインにします。
5. 古いシャードを削除します。

データを部分的に利用できるようにするために、手順 1. で元のシャードを利用不能にする代わりに、読み取り専用にすることも可能な場合があります。 これにより、データが移動されている間、アプリケーションはデータを読み込むことができます。ただし、変更することはできません。

## オンライン移行

オンライン移行は、実行するのにより複雑な操作を必要としますが、手順全体を通してデータが利用できるので、ユーザーにとってはサービスの中断がより少なくなります。 プロセスは、オフライン移行で使用されるものと類似していますが、元のシャードがオフラインになることはありません (手順 1.)。 移行プロセスの粒度 (項目単位またはシャード単位) に応じて、クライアント アプリケーションのデータ アクセス コードは、2 つの場所 (元のシャードと新しいシャード) に対してデータの読み書きを処理することが必要になる場合があります。

オンライン移行をサポートするソリューションの例は、次を参照してください。、 [Elastic Scale の分割/結合サービス](sql-database-elastic-scale-overview-split-and-merge.md), 、Microsoft web サイトで参照します。

## 関連のあるパターンとガイダンス

次のパターンも、データの一貫性を実装するための戦略を検討している際に、シナリオに関連する可能性があります。

- Microsoft Web サイトで提供されている「Data Consistency Guidance (データ一貫性ガイダンス)」ページでは、クラウドなどの分散環境で一貫性を維持するための戦略が説明されています。
-  [データ パーティション分割ガイダンス](https://msdn.microsoft.com/library/dn589795.aspx) 、Microsoft web サイトのページは、分散ソリューションのさまざまな条件を満たすパーティションの設計の概要を示します。
-  [シャーディング パターン](https://msdn.microsoft.com/library/dn589797.aspx), 、Microsoft web サイトで説明されている、データをシャーディングするための一般的な戦略の概要を示します。
-  [インデックス テーブル パターン](https://msdn.microsoft.com/library/dn589791.aspx) 説明されている web サイトを microsoft には、データに対してセカンダリ インデックスを作成する方法を示しています。 この手法を使用すると、アプリケーションは、コレクションのプライマリ キーを参照しないクエリで、データをすばやく取得できます。
-  [具体化されたビュー パターン](https://msdn.microsoft.com/library/dn589782.aspx) 説明した、microsoft web サイトが高速なクエリ操作をサポートするデータを要約するあらかじめ設定されているビューを生成する方法を説明します。 この手法は、要約対象のデータを含むパーティションが複数のサイトにまたがって分散されている場合に、パーティション分割されたデータ ストアで役立つ可能性があります。
- Content Delivery Network (CDN) に関する記事は、Azure で CDN を構成および使用するための詳細なガイダンスを提供します。

## 詳細情報

-  [Azure SQL Database](https://msdn.microsoft.com/library/azure/ee336279.aspx) 、Microsoft web サイトのページの詳細に説明を作成して、SQL データベースを使用する方法を提供します。
- ページ [Azure SQL Database Elastic Scale の概要](sql-database-elastic-scale-introduction.md) 、microsoft web サイトが Elastic Scale の包括的な概要を提供します。
- トピック [Elastic Scale による分割とマージ](sql-database-elastic-scale-overview-split-and-merge.md) web サイトには、microsoft には、分割/マージ サービスを使用して、Elastic Scale シャードを管理する情報が含まれています。
- ページ [Azure ストレージのスケーラビリティおよびパフォーマンスのターゲット](https://msdn.microsoft.com/library/azure/dn249410.aspx) web サイト、microsoft Azure ストレージの現在のサイズとスループットの制限について説明します。
-  [エンティティ グループ トランザクションの実行](https://msdn.microsoft.com/library/azure/dd894038.aspx) 、Microsoft web サイトのページが Azure テーブル ストレージに格納されたエンティティにトランザクション操作を実装する方法の詳細情報を提供します。
- 記事 [Azure テーブル ストレージのスケーラブルなパーティション分割戦略の設計](https://msdn.microsoft.com/library/azure/hh508997.aspx) web サイトには、microsoft には、Azure テーブル ストレージでデータをパーティション分割に関する詳細情報が含まれています。
- ページ [Azure 用 CDN の使用](cdn-how-to-use.md) web サイトは、microsoft Azure コンテンツ配信ネットワーク (CDN) を使用して Azure Blob ストレージに保持されているデータをレプリケートする方法を説明します。
- ページ [プレビュー リリースにおける DocumentDB の制限](documentdb-limits.md) 、microsoft web サイトに関する現在の制限とクォータについて説明 Microsoft DocumentDB します。
- ページ [管理 DocumentDB の容量とパフォーマンス](documentdb-manage.md) web サイトには、microsoft Azure DocumentDB がリソースをデータベースに割り当てる方法に関する情報が含まれています。
-  [Azure Search の概要](https://msdn.microsoft.com/library/azure/dn798933.aspx) 、Microsoft web サイトのページが Azure Search サービスで利用できる機能の詳しい説明を提供します。
-  [制限および制約 (Azure Search API)](https://msdn.microsoft.com/library/azure/dn798934.aspx) 、Microsoft web サイトのページには、Azure Search サービスの各インスタンスの容量の情報が含まれています。
-  [サポートされるデータ型 (Azure Search)](https://msdn.microsoft.com/library/azure/dn798938.aspx) 、Microsoft web サイトのページには、検索可能ドキュメントおよびインデックスとして使用できるデータ型がまとめて表示します。
-  [Microsoft Azure Cache](http://azure.microsoft.com/services/cache.md) 、Microsoft web サイトのページは、Azure Redis Cache の概要を提供します。
- ページ [パーティション分割: 複数の Redis インスタンス間でデータを分割する方法](http://redis.io/topics/partitioning) web サイトは、Redis で Redis でパーティション分割を実装する方法についてを提供します。
- ページ [Azure の CentOS Linux VM で Redis を実行している](http://blogs.msdn.com/b/tconte/archive/2012/06/08/running-redis-on-a-centos-linux-vm-in-windows-azure.aspx) 、microsoft web サイトをビルドして、Azure VM として実行される Redis ノードを構成する方法を示すサンプルについて説明します。
-  [データ型](http://redis.io/topics/data-types) Redis web サイトのページは、Redis および Azure Redis Cache で利用可能なデータ型を説明します。

