<properties
    pageTitle="データベースが 1 台の場合の Azure SQL Database のパフォーマンス ガイダンス"
    description="このトピックでは、お使いのアプリケーションに最適なサービス層を決める際の指針と Azure SQL Database を最大限活用するためにアプリケーションを調整する際の推奨事項について説明します。"
    services="sql-database"
    documentationCenter="na"
    authors="rothja"
    manager="jeffreyg"
    editor="monicar" />


<tags
    ms.service="sql-database"
    ms.devlang="na"
    ms.topic="article"
    ms.tgt_pltfrm="na"
    ms.workload="data-management"
    ms.date="11/03/2015"
    ms.author="jroth" />

# データベースが 1 台の場合の Azure SQL Database のパフォーマンス ガイダンス

## 概要 

Microsoft Azure SQL Database が 3 つの [サービス階層](sql-database-service-tiers.md), 、Basic、Standard、および Premium です。 すべてのサービス層で、Azure SQL Database に与えられたリソースが厳密に分離され、パフォーマンスが予測可能になります。 データベースに保証されるスループットは、Premium、Standard、Basic の順に高くなります。

>[AZURE.NOTE] Business および Web サービス層は 2015 年 9 月に廃止されます。 詳細については、次を参照してください。 [Web および Business エディションの終了に関する FAQ](https://msdn.microsoft.com/library/azure/dn741330.aspx)します。 既存の Web と Business データベースを新しいサービス階層にアップグレードする方法の詳細については、次を参照してください。 [を新しいサービス階層 SQL Database Web/ビジネス データベースをアップグレード](sql-database-upgrade-new-service-tiers.md)します。

この文書では、お使いのアプリケーションに最適なサービス層を決める際の指針と Azure SQL Database を最大限活用するためにアプリケーションを調整する際の推奨事項について説明します。

>[AZURE.NOTE] この記事は、SQL データベース内の 1 つのデータベースのパフォーマンス ガイダンスについて説明します。 エラスティック データベース プールに関連するパフォーマンス ガイダンスを参照してください。 [弾力性データベース プールの価格およびパフォーマンスに関する考慮事項](sql-database-elastic-pool-guidance.md)します。 ただし、この記事にある、データベースが 1 つの場合の調整事項の多くは、パフォーマンス上の長所が同じエラスティック プール内のデータベースに適用できます。

**執筆者:** Conor Cunningham、Kun Cheng、Jan Engelsberg

**技術校閲者:** Morgan Oslake、Joanne Marone、Keith Elmore、José Batista-neto、Rohit Nayak

## Azure SQL Database の背景

Basic、Standard、Premium サービス層が Azure SQL Database サービスを機能強化するしくみについて理解するには、Azure SQL Database の全体像を把握しておくと役立ちます。 Azure SQL Database はいくつかの理由から選択できます。 その 1 つは、ハードウェアの購入と取り付けという長期にわたる周期を回避するためです。 Azure SQL Database があれば、購買発注の承認、コンピューターの到着、電源と冷却機能のアップグレード、取り付けの完了を待たなくても、データベースをオンザフライで作成したり、切断したりできます。 Microsoft はこれらの課題に対処し、各データ センターで集計された需要に基づいてハードウェアを事前プロビジョニングし、アイデアをソリューションに変えるために必要な時間を大幅に短縮します。 企業がハードウェアを購入し、手動でデプロイするために必要な時間を数週間または数か月短縮できます。

Microsoft はまた、自動 HA や組み込み管理など、さまざまな自動管理機能を Azure SQL Database に追加しています。

### 自動高可用性 (HA) 
 Azure SQL Database はユーザー データベースごとに最低 3 台のレプリカを維持し、レプリカのクォーラムに合わせ、各々の変化を自動的にコミットするロジックを備えています。 それにより、1 台のコンピューターが壊れても、データを失うことがありません。 さらに、各レプリカは異なるハードウェア ラックに配置され、電力またはネットワーク スイッチを失ってもデータベースは影響を受けません。 最後になりますが、コンピューターが失われた場合、レプリカを自動的に再構築するロジックを備えています。コンピューターが正常でなくなった場合でも、好ましい状態のプロパティが自動的に保持されています。 こうしたメカニズムにより、今日の高可用性ソリューションの設置と構成に必要な時間のかかるプロセスを回避できます。 事前構成済み HA ソリューションをデータに与えることで、従来の手法では難しかったミッションクリティカル データベース ソリューションの構築から悩みの種がまた 1 つ取り除かれます。

### 組み込み管理 
 Azure SQL Database はサービスとして実行されます。 つまり、データベースごとにアップタイムの目標が定義されており、保守管理のための長期にわたるダウンタイム枠が回避されます。 Microsoft はこのサービスにシングルベンダー ソリューションを提供します。つまり、問題が発生した場合、連絡先は 1 社だけになります。 Microsoft はまた、継続的にサービスを更新し、機能と容量を追加し、より簡単に更新するための方法を模索しています。 更新プログラムは透過的かつダウンタイム枠なしで行われます。つまり、通常の HA フェールオーバー メカニズムに統合されています。 それにより、新しい機能が発表された直後にそれを活用できます。一定のダウンタイム枠の間、サーバーのアップグレードを待つ必要がありません。

以上の機能はすべて、あらゆるサービス層で利用できます。 自己所有のサーバーを購入し、実行するよりはるかに安く、非常に小規模なプロジェクトでも大金を使わずに Azure の機能を活用できます。

## 各サービス層の違い
Basic、Standard、Premium という 3 つのサービス階層があります。 各サービス階層には 1 つまたは複数のパフォーマンス レベルがあり、予測できる方法でデータベースを実行するためのパワーを与えます。 電源については、「 [データベース トランザクション単位 (Dtu)](sql-database-technical-overview.md#understand-dtus)します。

Basic サービス層は、各データベースのパフォーマンスを時間単位で予測できるように設計されています。 Basic データベースの DTU は、複数の同時要求がない、小規模のデータベースに十分なリソースを与えるように設計されています。

Standard サービス層ではパフォーマンス予測機能が上がっており、ワークグループや Web アプリケーションなど、複数の同時要求があるデータベースに対応します。 Standard サービス層のデータベースを使用すると、分単位の予測可能パフォーマンスに基づいてデータベース アプリケーションをサイズ調整できます。

Premium サービス層のパフォーマンスに関する看板機能は、Premium データベースごとに秒単位でパフォーマンスを予測できることです。 Premium サービス層を利用すれば、データベースのピーク負荷に基づいてデータベース アプリケーションのサイズを調整し、パフォーマンス差異に起因し、待ち時間が重要な操作で予想以上の時間が小規模クエリにかかる事態をなくすることができます。 このモデルは、ピーク時のリソース ニーズ、パフォーマンス差異、クエリ待ち時間を高い確率で予測するために必要なアプリケーションの開発と製品検証の周期を大幅に単純化できます。 

Standard と同様に、Premium サービス層では、お客様が希望する分離に基づき、さまざまなパフォーマンス レベルを選択できます。 

Standard と Premium のパフォーマンス レベル設定では、必要とする容量の分だけ支払い、作業負荷の変化に合わせ、容量を増やしたり、減らしたりできます。 たとえばに、新学期のお買い物シーズンにデータベースの作業負荷がビジー状態になる場合、その期間、データベースのパフォーマンス レベルを増やし、ピーク期間が過ぎたら、減らすなどできます。 ビジネスの季節性に合わせてクラウド環境を最適化することで、支払いを最小限に抑えることができます。 このモデルはソフトウェア製品のリリース周期にも適しています。 テスト チームは、テストの実行中に容量を割り当て、テストが完了したらその容量を解放できます。 必要な分の容量に支払い、滅多に使われない専用リソースにかける支出を避けるとき、このような容量要求機能が最適です。 Microsoft の多くのお客様に SQL Server と共にご利用いただいている従来の専用ハードウェア モデルに近いパフォーマンスが与えられます。 Azure SQL Database でもっとたくさんのアプリケーションをより簡単に実行できます。

サービス階層、パフォーマンス レベルと Dtu の詳細については、次を参照してください。 [Azure SQL Database サービス階層とパフォーマンス レベル](sql-database-service-tiers.md)します。

## サービス層を使用する理由

作業負荷は変化に富み、サービス層の目的は、さまざまなパフォーマンス レベルでパフォーマンスの高度な予測機能を提供することです。 データベースのリソース要件が大規模になるお客様は、より専用度の高いコンピューティング環境で作業できます。 

### Basic サービス層の使用例:

- **Azure SQL Database の概要**: 多くの場合、開発中のアプリケーションは、高いレベルのパフォーマンスを必要ありません。 Basic データベースは、低価格でデータベースを開発するための理想的な環境となります。
- **1 人のユーザーを持つデータベース**: 通常、データベースと 1 人のユーザーに関連付けるアプリケーションでは要件の高い同時実行制御とパフォーマンスにありません。 そのような要件のアプリケーションの場合、Basic サービス層が候補となります。

### Standard サービス層の使用例:

- **複数の同時要求を持つデータベース**: 中程度のトラフィックやより多くのリソースを必要とする部門別のアプリケーションと web サイトは、Standard サービス階層に適した候補と同様に、一度に 1 つ以上のユーザーをサービス アプリケーション。

### Premium サービス層の使用例:

- **高いピーク時負荷**: 多数の操作を完了するには、CPU、メモリ、または IO を必要とするアプリケーション。 たとえば、データベース操作で延長時間に対して複数の CPU コアが使用される場合、Premium データベースが候補となります。
- **多くの同時要求**: 一部のデータベース アプリケーション サービスを例については、多くの同時要求のトラフィック量の多い web サイトを提供します。 Basic サービス層と Standard サービス層の場合、同時要求の数に制限があります。 アプリケーションが多くの接続を必要とするとき、場合によっては、必要な要求の最大数を処理するための予約サイズを選択する必要があります。
- **待ち時間の短い**: 一部のアプリケーションは、最短時間で、データベースからの応答を保証する必要があります。 お客様側の操作の一部として所与のストアド プロシージャが呼び出されるとき、99% の割合で 20 ミリ秒以内にその呼び出しから返すことが場合によっては要求されます。 この種のアプリケーションでは、Premium データベースを利用すれば、コンピューティング パワーが確実に得られます。

必要となる厳密なレベルはリソース次元ごとのピーク負荷要件に基づきます。 アプリケーションによっては 1 つのリソースのわずかな量を利用するものもあれば、要件が大規模になるものもあります。

サービス階層の詳細については、次を参照してください。 [Azure SQL Database サービス階層とパフォーマンス レベル](sql-database-service-tiers.md)します。

## サービス層の機能と制限
各サービス層とパフォーマンス レベルは、さまざまな制限やパフォーマンス特性に関連付けられています。 次の表は、単一データベースの特性についてまとめたものです。

[AZURE.INCLUDE [SQL DB service tiers table](../../includes/sql-database-service-tiers-table.md)]

次のセクションでは、前の表の各領域の詳細を提供します。

### データベースの最大サイズ

**データベースの最大サイズ** GB のデータベースのサイズに制限するだけです。

### DTU

**Dtu** データベース トランザクション単位を指します。 データベースのトランザクションという実際の測定に基づいたデータベースの相対的な能力を表す SQL Database の測定単位です。 オンライン トランザクション処理 (OLTP) 要求に一般的な一連の操作で構成され、完全搭載条件で 1 秒間に完了可能なトランザクション数を測定します。 Dtu の詳細を取得するには、次を参照してください。 [理解 Dtu](sql-database-technical-overview.md#understand-dtus)します。 Dtu の測定方法の詳細については、次を参照してください。 [のベンチマークの概要](sql-database-benchmark-overview.md)します。

### ポイントインタイム リストア

**特定の時点の復元** の以前の時点にデータベースを復元する機能です。 何日前までさかのぼれるかはご利用のサービス層によって決まります。 詳細については、次を参照してください。 [ユーザー エラーから Azure SQL データベースを回復](sql-database-user-error-recovery.md)します。

### 障害復旧

**災害復旧** は、プライマリの SQL データベースで障害から回復する能力です。

*地理的復元* なしですべてのサービス層にある余分なコストです。 障害の発生時、最も新しい geo 冗長バックアップを利用し、任意の Azure リージョンにデータベースを復元できます。

標準のアクティブ geo レプリケーションにも同様の障害復旧機能が備わっていますが、回復ポイントの目標 (RPO) は非常に低くなります。 たとえば、geo リストアの場合、RPO は 1 時間未満になります (言い換えると、バックアップは最も新しくて 1 時間前になります)。 geo レプリケーションの場合、RPO は 5 秒未満です。

詳細については、次を参照してください。、 [ビジネス継続性の概要](sql-database-business-continuity.md)します。

### 最大インメモリ OLTP ストレージ
**最大のインメモリ OLTP ストレージ** は使用できるストレージの最大時間を示します、 [、インメモリ OLTP プレビュー](sql-database-in-memory.md) Premium データベース。 これはもとも呼ば *メモリ内に XTP ストレージ*します。 Azure クラシック ポータルを使用して、または **sys.dm_db_resource_stats** インメモリ ストレージの使用を監視するビュー。 監視の詳細については、次を参照してください。 [モニター、インメモリ OLTP ストレージ](sql-database-in-memory-oltp-monitoring.md)します。 

>[AZURE.NOTE] インメモリ OLTP のプレビューは現在、1 つのデータベースをエラスティック データベース プール内のデータベースではなくのみサポートされています。

### 最大同時要求数

**同時要求の最大** は、データベースに同時に実行するユーザーまたはアプリケーションの同時要求の最大数。 同時要求の数を確認するには、SQL データベースで次の Transact-SQL クエリを実行します。

    SELECT COUNT(*) AS [Concurrent_Requests] 
    FROM sys.dm_exec_requests R

オンプレミス SQL Server データベースの作業負荷を分析している場合、分析している特定のデータベースでフィルター処理するようにこのクエリを変更してください。 たとえば、「MyDatabase」という名前のオンプレミス データベースがある場合、次の Transact-SQL クエリはそのデータベースの同時要求数を返します。

    SELECT COUNT(*) AS [Concurrent_Requests] 
    FROM sys.dm_exec_requests R
    INNER JOIN sys.databases D ON D.database_id = R.database_id
    AND D.name = 'MyDatabase'

これはある時点のスナップショットにすぎないことに注意してください。 作業負荷をさらに詳しく理解するには、長期間のたくさんのサンプルを集め、同時要求要件を理解する必要があります。

### 最大同時ログイン数

**最大同時ログイン** ユーザーや、同時にデータベースにログインしようとしています。 アプリケーションの数の制限を表します。 これらのクライアントで同じ接続文字列を使用している場合でも、サービスは各ログインを認証することに注意してください。 つまり、10 人のユーザーが同じユーザー名とパスワードでデータベースに同時に接続した場合、10 件の同時ログインが発生します。 この制限は、ログインと認証の期間のみに適用されます。 そのため、同じ 10 人のユーザーがデータベースに順番に接続した場合、同時ログイン数が 1 より大きくなることはありません。 

>[AZURE.NOTE] この制限は、エラスティック データベース プール内のデータベースに現在は適用されません。

同時ログイン数または履歴を表示するクエリや DMV はありません。 ユーザーやアプリケーションのパターンを分析すれば、ログインの頻度を理解できます。 テスト環境で実世界の負荷を実行し、この上限やこのトピックで説明されている他の上限に達していないことを確認できます。

### 最大セッション数

**最大セッション数** は、データベースへの同時接続の最大数。 ユーザーがログインすると、セッションが確立され、ログアウトするか、セッションがタイムアウトになるまでアクティで名状態を維持します。 現在のアクティブなセッション数を確認するには、SQL データベースで次の Transact-SQL クエリを実行します。

    SELECT COUNT(*) AS [Sessions]
    FROM sys.dm_exec_connections

オンプレミス SQL Server の作業負荷を分析している場合、特定のデータベースに焦点を当てるようにクエリを変更してください。 それにより、そのデータベースを Azure SQL Database に移動する場合、そのデータベースに考えられるセッション ニーズを決定できます。

    SELECT COUNT(*)  AS [Sessions]
    FROM sys.dm_exec_connections C
    INNER JOIN sys.dm_exec_sessions S ON (S.session_id = C.session_id)
    INNER JOIN sys.databases D ON (D.database_id = S.database_id)
    WHERE D.name = 'MyDatabase'

ここでも、これらのクエリはある時点の検数を返します。つまり、長期間、複数のサンプルを集めることで、セッション使用を正確に理解できます。

SQL データベースの分析に照会することも **sys.resource_stats** を使用してセッション履歴の統計を取得する、 **active_session_count** 列です。 次の監視セクションで、このビューの利用に関する詳細を提供します。

## リソース使用の監視
SQL データベースのリソース使用をそのサービス層との関連で監視できるビューが 2 つあります。

- [sys.dm_db_resource_stats](https://msdn.microsoft.com/library/dn800981.aspx)
- [sys.resource_stats](https://msdn.microsoft.com/library/dn269979.aspx)

>[AZURE.NOTE] Azure クラシック ポータルを使用して、リソース使用率を表示することもできます。 例については、次を参照してください。 [サービス層のパフォーマンスの監視](sql-database-service-tiers.md#monitoring-performance)します。

### sys.dm_db_resource_stats の使用
 [Sys.dm_db_resource_stats](https://msdn.microsoft.com/library/dn800981.aspx) ビューは、各 SQL データベースに存在して、サービス層の基準とした最新のリソース使用率データを提供します。 CPU、データ IO、ログ書き込み、メモリの平均 (%) が 15 秒ごとに記録され、1 時間保持されます。 

このビューにはリソース使用率が詳細に表示されるので、現状の分析やトラブルシューティングの場合、最初に「sys.dm_db_resource_stats」を利用してください。 たとえば、次のクエリは、この 1 時間の現在のデータベースの平均リソース使用率と最大リソース使用率を表示します。

    SELECT  
        AVG(avg_cpu_percent) AS 'Average CPU Utilization In Percent', 
        MAX(avg_cpu_percent) AS 'Maximum CPU Utilization In Percent', 
        AVG(avg_data_io_percent) AS 'Average Data IO In Percent', 
        MAX(avg_data_io_percent) AS 'Maximum Data IO In Percent', 
        AVG(avg_log_write_percent) AS 'Average Log Write Utilization In Percent', 
        MAX(avg_log_write_percent) AS 'Maximum Log Write Utilization In Percent', 
        AVG(avg_memory_usage_percent) AS 'Average Memory Usage In Percent', 
        MAX(avg_memory_usage_percent) AS 'Maximum Memory Usage In Percent' 
    FROM sys.dm_db_resource_stats;  

他のクエリの例を参照してください。 [sys.dm_db_resource_stats](https://msdn.microsoft.com/library/dn800981.aspx)します。

### sys.resource_stats の使用

 [Sys.resource_stats](https://msdn.microsoft.com/library/dn269979.aspx) で表示、 **マスター** データベースは、特定のサービス階層とパフォーマンス レベルでの SQL データベースのパフォーマンスの使用を監視するための追加情報を提供します。 データは 5 分ごとに集められ、約 14 日間保存されます。 このビューは、SQL データベースの過去のリソース使用率を長期にわたり分析する際に役立ちます。

次のグラフは、Premium データベースの CPU リソース利用率を示しています (P2 パフォーマンス レベル、1 週間における毎時間の利用率)。 このグラフは月曜日始まり、5 営業日を示し、週末ではアプリケーションの活動が大幅に減っていることがわかります。

![SQL DB リソース使用率](./media/sql-database-performance-guidance/sql_db_resource_utilization.png)

このデータから、このデータベースのピーク CPU 負荷は現在のところ、P2 パフォーマンス レベルに対して 50% をわずかに超える CPU 利用率になっていることがわかります (火曜日の昼)。 アプリケーションのリソース プロファイルにおいて CPU が支配的要因になる場合、P2 が作業負荷に常に対処できる最適なパフォーマンス レベルであると決定できます。 アプリケーションで時間と共に増加が予測される場合、上限に到達しないように、余分にリソース バッファーを考慮すると合理的です。 特に待ち時間が重要になる環境において (データベース呼び出しの結果に基づいて Web ページを表示するアプリケーションをサポートするデータベースなど)、パワーが足りないため、要求を効果的に処理できないデータベースに起因して、お客様に見えるエラーが発生する事態を回避できます。 

アプリケーションの種類が異なれば、同じグラフの解釈が異なることにも注意してください。 たとえば、あるアプリケーションが給与データを毎日処理し、同じグラフが与えられるとき、場合によっては、この種の「一括ジョブ」モデルは P1 パフォーマンス レベルで何の問題もありません。 P1 パフォーマンス レベルの DTU は 100 で、P2 パフォーマンス レベルの DTU は 200 です。 つまり、P1 パフォーマンス レベルのパフォーマンスは P2 パフォーマンス レベルの半分となります。 そのため、P2 の 50%  CPU 使用は P1 の 100% CPU 使用に等しくなります。 アプリケーションにタイムアウトがない限り、当日に完了するのであれば、大きなジョブに 2 時間かかっても 2.5 時間かかっても問題ないでしょう。 このカテゴリのアプリケーションは、おそらく、P1 パフォーマンス レベルを利用します。 その日の中でリソース利用率が低くなる時間帯があるという事実を利用できます。つまり、「大きなピーク」があっても、そのような時間帯の 1 つに広がることがあります。 ジョブを毎日定刻で完了できる限り、P1 パフォーマンス レベルがこのようなアプリケーションに最適化もしれません (さらにコストを削減します)。

各アクティブ データベースでのリソース情報で使用された azure SQL データベースの公開、 **sys.resource_stats** の表示、 **マスター** 各サーバーのデータベースです。 テーブルのデータは 5 分おきに集計されます。 Basic、Standard、Premium サービス層では、データをテーブルに表示するのに 5 分以上かかります。つまり、このデータはほぼリアルタイムの分析より過去の分析に適しています。 クエリを実行する、 **sys.resource_stats** ビューは選択予約が必要なときに、目的のパフォーマンスを配信するかどうかを検証するデータベースの最近の履歴を表示します。 

>[AZURE.NOTE] 接続する必要があります、 **マスター** クエリの順序で、論理 SQL データベース サーバーのデータベース **sys.resource_stats** 次の例です。

次の例は、このビューのデータが公開されるしくみを示しています。

    SELECT TOP 10 * 
    FROM sys.resource_stats 
    WHERE database_name = 'resource1' 
    ORDER BY start_time DESC

![システム リソース統計](./media/sql-database-performance-guidance/sys_resource_stats.png)

次の例を使用して、SQL データベースのリソース使用率を理解できるさまざまな方法を示す、 **sys.resource_stats** カタログを表示します。

>[AZURE.NOTE] 一部の列の **sys.resource_stats** で次の例のサンプル クエリがエラーを生成するため、現在の V12 データベースで変更されています。 このトピックの今後の更新では、この問題に対処する新しいバージョンのクエリを紹介します。

1. たとえば、「userdb1」という名前のデータベースの先週のリソース利用率を調べる場合、次のクエリを実行できます。
    
        SELECT * 
        FROM sys.resource_stats 
        WHERE database_name = 'userdb1' AND 
              start_time > DATEADD(day, -7, GETDATE())
        ORDER BY start_time DESC;
    
2. 作業負荷がパフォーマンス レベルに適合する様子を評価するために、さまざまなリソース指標 (CPU、読み取り、書き込み、ワーカー数、セッション数) で分析する必要があります。 次は sys.resource_stats を利用したクエリを修正したものです。平均とリソース指標の最大値を報告します。
    
        SELECT 
            avg(avg_cpu_percent) AS 'Average CPU Utilization In Percent',
            max(avg_cpu_percent) AS 'Maximum CPU Utilization In Percent',
            avg(avg_physical_data_read_percent) AS 'Average Physical Data Read Utilization In Percent',
            max(avg_physical_data_read_percent) AS 'Maximum Physical Data Read Utilization In Percent',
            avg(avg_log_write_percent) AS 'Average Log Write Utilization In Percent',
            max(avg_log_write_percent) AS 'Maximum Log Write Utilization In Percent',
            avg(active_session_count) AS 'Average # of Sessions',
            max(active_session_count) AS 'Maximum # of Sessions',
            avg(active_worker_count) AS 'Average # of Workers',
            max(active_worker_count) AS 'Maximum # of Workers'
        FROM sys.resource_stats 
        WHERE database_name = 'userdb1' AND start_time > DATEADD(day, -7, GETDATE());
    
3. 各リソース指標の平均と最大値に関する上記の情報があれば、選択したパフォーマンス レベルに作業負荷が適合する様子を評価できます。 ほとんどの場合、sys.resource_stats からの平均値が目標サイズに対する有効な基準となります。 これを主要なものさしとしてください。 たとえば、S2 パフォーマンス レベルで Standard サービス層を使用しているとき、CPU、読み取り、書き込みの平均利用率が 40% を下回り、ワーカーの平均数が 50 を下回り、セッションの平均数が 200 を下回る場合、作業負荷は S1 パフォーマンス レベルが最適かもしれません。 データベースがワーカーとセッションの制限内に収まるかどうかが簡単にわかります。 CPU、読み取り、書き込みに関して、データベースが下位のパフォーマンス レベルに適合するかどうかを確認するには、下位パフォーマンス レベルの DTU 数を現在のパフォーマンス レベルの DTU 数で割り、その計算結果に 100 を掛けます。
    
    **S1 DTU / S2 DTU * 100 = 20 / 50 * 100 = 40**
    
    この結果は、2 つのパフォーマンス レベルの間の相対的パフォーマンス差異を百分率で表したものになります。 利用率がこの割合を超えていない場合、その作業負荷には下位のパフォーマンス レベルが適しているかもしれません。 ただし、リソース利用率の値を全範囲で見て、割合の観点で、どのくらいの頻度でデータベースの作業負荷が下位のパフォーマンス レベルに適合するかを判断する必要もあります。 次のクエリは、上で計算された 40% のしきい値に基づき、リソース次元別の適合率を出力します。
    
        SELECT 
            (COUNT(database_name) - SUM(CASE WHEN avg_cpu_percent >= 40 THEN 1 ELSE 0 END) * 1.0) / COUNT(database_name) AS 'CPU Fit Percent'
            ,(COUNT(database_name) - SUM(CASE WHEN avg_log_write_percent >= 40 THEN 1 ELSE 0 END) * 1.0) / COUNT(database_name) AS 'Log Write Fit Percent'
            ,(COUNT(database_name) - SUM(CASE WHEN avg_physical_data_read_percent >= 40 THEN 1 ELSE 0 END) * 1.0) / COUNT(database_name) AS 'Physical Data Read Fit Percent'
        FROM sys.resource_stats
        WHERE database_name = 'userdb1' AND start_time > DATEADD(day, -7, GETDATE());
    
    データベースのサービス レベル目標 (SLO) に基づき、作業負荷が下位のパフォーマンス レベルに適合するかどうかを判断できます。 データベース作業負荷 SLO が 99.9% で、上のクエリが 3 つすべてのリソース次元に対して 99.9 以上の値を返す場合、その作業負荷はおそらく下位のパフォーマンス レベルに適合します。
    
    適合率を見ると、SLO を満たすために上位のパフォーマンス レベルに移るべきかどうかもわかります。 たとえば、「userdb1」は先週の次の使用率を示しています。
    
    | 平均 CPU パーセント | 最大 CPU パーセント |
    |---|---|
    | 24.5 | 100.00 |
    
    平均 CPU はパフォーマンス レベルの上限の約 4 分の 1 になり、データベースのパフォーマンス レベルにうまく適合でしょう。 ただし、最大値はデータベースがパフォーマンス レベルの上限に到達することを示します。 次に上位のパフォーマンス レベルに移動する必要がありますか。 この場合も、作業負荷が 100% に到達する回数を見て、それをデータベース作業負荷 SLO と比較する必要があります。
    
        SELECT 
        (COUNT(database_name) - SUM(CASE WHEN avg_cpu_percent >= 100 THEN 1 ELSE 0 END) * 1.0) / COUNT(database_name) AS 'CPU Fit Percent'
        ,(COUNT(database_name) - SUM(CASE WHEN avg_log_write_percent >= 100 THEN 1 ELSE 0 END) * 1.0) / COUNT(database_name) AS 'Log Write Fit Percent’
        ,(COUNT(database_name) - SUM(CASE WHEN avg_physical_data_read_percent >= 100 THEN 1 ELSE 0 END) * 1.0) / COUNT(database_name) AS 'Physical Data Read Fit Percent'
        FROM sys.resource_stats
        WHERE database_name = 'userdb1' AND start_time > DATEADD(day, -7, GETDATE());
    
    上記のクエリが 3 つのリソース次元のいずれにも 99.9% 未満の値を返す場合、次に上位のパフォーマンス レベルに移動するか、アプリケーションの調整手法を利用し、Azure SQL Database の負荷を減らすことを検討してください。
    
4. 上の演習では、将来的に予測される作業負荷の増加も考慮する必要があります。

## アプリケーションの調整

従来のオンプレミス SQL Server では、初回の容量計画のプロセスは、多くの場合、アプリケーションを本稼働実行するプロセスとは分けられます。 言い換えると、SQL Server を実行するためのハードウェアと関連ライセンスの購入は前もって行われ、パフォーマンス調整は後で行われます。 Azure SQL Database を使用するとき、通常、アプリケーションの実行と調整のプロセスを交互に扱うことが推奨されます (毎月請求されるため、おそらくはこれが望ましくなります)。 オンデマンド容量の支払いモデルでは、アプリケーションの将来的な成長計画の推測に基づいてハードウェアに大規模な過剰プロビジョニングを行う代わりに (はるか先の将来まで予測する必要があるため、多くの場合、この方法は正しくありません)、現在必要とされる最小リソースを使用するようにアプリケーションを調整できます。 アプリケーションを調整せず、代わりにハードウェア リソースを過剰プロビジョニングするお客様もいることにご留意ください。 そのような手法は、ある重要なアプリケーションの利用が集中する期間にそのアプリケーションを変更が望まれない場合に有効です。 アプリケーションを調整することで、リソース要件を最小限に抑え、Azure SQL Database のサービス層を使用するとき、毎月の請求額を抑えます。 

### アプリケーションの特性

サービス層はアプリケーションのパフォーマンスを安定させ、予測精度を高めるように設計されています。この機能を最大限に活用するために、アプリケーションの調整方法には最良事例がいくつか存在します。 上位のパフォーマンス レベルまたはサービス層に切り替えることで、多くのアプリケーションでパフォーマンスが大幅に上がりますが、さらに調整しなければ効果が出ない場合もあります。 アプリケーションに次の特性がある場合、Azure SQL Database の使用時のパフォーマンスを改善する目的で、追加のアプリケーション調整も考慮してください。 

- **"Chatty な"動作によるパフォーマンスの低下を持つアプリケーション**: これには、ネットワークの待機時間を区別できる大量のデータ アクセス操作を実行するアプリケーションが含まれます。 そのようなアプリケーションでは、場合によっては、Azure SQL Database にデータ アクセスする操作の数を減らす修正が必要になります。 たとえば、アドホック クエリをまとめて処理したり、ストアド プロシージャにクエリを移動したりするなどの手法でアプリケーションが改善される可能性があります。 詳細については、後続の「クエリの一括処理」セクションを参照してください。
- **大量のワークロード全体の 1 台のコンピューターでサポートできないを持つデータベース**: 最高の Premium パフォーマンス レベルのリソースを超えるデータベースは適していません。 このようなデータベースは、作業負荷をスケールアウトすることで改善することがあります。 詳細については、後続の「データベース間のシャーディング」セクションと「機能的パーティション分割」セクションを参照してください。
- **最適化されていないクエリを含むアプリケーション**: アプリケーション、クエリをチューニングが不十分ないるデータ アクセス層で特にメリットがないが予期したとおりより高いパフォーマンス レベルを選択します。 たとえば、WHERE 句がない、インデックスが足りない、統計が古いクエリです。 このようなアプリケーションの場合、クエリ パフォーマンスの標準的な調整方法で効果が得られます。 詳細については、後続の「インデックスの不足」セクションと「クエリの調整/ヒント」を参照してください。
- **最適でないデータを格納しているアプリケーション アクセス デザイン**: デッドロックなど、本質的なデータ アクセス同時実行の問題のあるアプリケーションのメリットがないより高いパフォーマンス レベルを選択します。 アプリケーションの開発者は、Azure Caching サービスや他のキャッシング技術を利用し、クライアント側でデータをキャッシュすることで Azure SQL Database に対するラウンドトリップを減らすことを検討してください。 後続の「アプリケーション層のキャッシング」セクションを参照してください。

## 調整技法
このセクションでは、 Azure SQL Database を調整し、アプリケーションから最良のパフォーマンスを引き出し、可能な限り下位のパフォーマンス レベルで実行するための手法について説明します。 多くの手法が従来の SQL Server 調整の最良事例と同じものですが、一部は Azure SQL Database に固有です。 従来の SQL Server 手法を拡大し、Azure SQL Database に応用することもできます。その場合、データベースに利用されるリソースを調べ、さらに細かく調整するべき領域を見つけます。

### Query Performance Insight と Index Advisor
SQL Database は Azure クラシック ポータルでデータベースのパフォーマンス問題を分析し、解消するための 2 つのツールを提供します。

- [Query Performance Insight](sql-database-query-performance.md)
- [Index Advisor](sql-database-index-advisor.md)

各ツールの概要とその使用方法については、前のリンクを参照してください。 インディクスの不足とクエリの調整に関する次の 2 つのセクションでは、同様のパフォーマンス問題を手動で見つけ、修正するためのその他の方法を提供します。 最初にポータルのツールを試し、より効率的に診断し、問題を解消することをお勧めします。 特別なケースで手動の調整方法を利用してください。

### インデックスの不足
OLTP データベースのパフォーマンスの一般的問題は物理的なデータベース設計に関連します。 多くの場合、データベース スキーマは (負荷またはデータ量の) 規模の面で試験することなく設計され、出荷されます。 残念ながら、クエリ プランのパフォーマンスは小規模で許容される場合がありますが、実稼働レベルのデータ量に直面したときに大幅が低下する可能性があります。 この問題の最も一般的な原因は、適切なインデックスがなく、クエリのフィルターまたはその他の制約を満たせないことにあります。 多くの場合、これはインデックス シークで足りるとき、テーブル スキャンとして現れます。

次の例では、シークで足りるとき、選択したクエリ プランにスキャンが含まれます。

    DROP TABLE dbo.missingindex;
    CREATE TABLE dbo.missingindex (col1 INT IDENTITY PRIMARY KEY, col2 INT);
    DECLARE @a int = 0;
    SET NOCOUNT ON;
    BEGIN TRANSACTION
    WHILE @a < 20000
    BEGIN
        INSERT INTO dbo.missingindex(col2) VALUES (@a);
        SET @a += 1;
    END
    COMMIT TRANSACTION;
    GO
    SELECT m1.col1 
    FROM dbo.missingindex m1 INNER JOIN dbo.missingindex m2 ON(m1.col1=m2.col1) 
    WHERE m1.col2 = 4;

![インデックス不足のクエリ プラン](./media/sql-database-performance-guidance/query_plan_missing_indexes.png)

Azure SQL Database には、データベース管理者が一般的なインデックス不足状態を発見し、修正するときに役立つ機能があります。 Azure SQL Database に組み込まれている動的管理ビュー (DMV) には、クエリ コンパイルが表示されます。クエリを実行するために見積もられたコストをクエリで大幅に削減できる場合があります。 クエリの実行中、各クエリ プランが実行される頻度と、実行クエリ プランとそのインデックスが存在した想定クエリ プランの間で見積もられるギャップが追跡記録されます。 それにより、データベース管理者は、所与のデータベースとその実際の作業負荷に対して、全体的な作業負荷コストを改善できる可能性がある物理的データベース設計変更をすばやく推測できます。

>[AZURE.NOTE] Dmv を使用して検索する前に欠落したインデックスは、最初のセクションを参照 [クエリのパフォーマンスに関する考察し、Index Advisor](query-performance-insight-and-index-advisor.md)します。

次のクエリは潜在的なインデックス不足の評価に使用できます。

    SELECT CONVERT (varchar, getdate(), 126) AS runtime, 
        mig.index_group_handle, mid.index_handle, 
        CONVERT (decimal (28,1), migs.avg_total_user_cost * migs.avg_user_impact * 
                (migs.user_seeks + migs.user_scans)) AS improvement_measure, 
        'CREATE INDEX missing_index_' + CONVERT (varchar, mig.index_group_handle) + '_' + 
                  CONVERT (varchar, mid.index_handle) + ' ON ' + mid.statement + ' 
                  (' + ISNULL (mid.equality_columns,'') 
                  + CASE WHEN mid.equality_columns IS NOT NULL 
                              AND mid.inequality_columns IS NOT NULL 
                         THEN ',' ELSE '' END + ISNULL (mid.inequality_columns, '')
                  + ')' 
                  + ISNULL (' INCLUDE (' + mid.included_columns + ')', '') AS create_index_statement, 
        migs.*, 
        mid.database_id, 
        mid.[object_id]
    FROM sys.dm_db_missing_index_groups AS mig
    INNER JOIN sys.dm_db_missing_index_group_stats AS migs 
        ON migs.group_handle = mig.index_group_handle
    INNER JOIN sys.dm_db_missing_index_details AS mid 
        ON mig.index_handle = mid.index_handle
    ORDER BY migs.avg_total_user_cost * migs.avg_user_impact * (migs.user_seeks + migs.user_scans) DESC

この例では、次のインデックスが提案されました。

    CREATE INDEX missing_index_5006_5005 ON [dbo].[missingindex] ([col2])  

作成後、その同じ SELECT ステートメントが今度は、スキャンの代わりに、シークを使用する別の計画を選択します。次のクエリ プランのように、より効率的に実行されます。

![インデックスが修正されたクエリ プラン](./media/sql-database-performance-guidance/query_plan_corrected_indexes.png)

重要なことは、共有される商品システムの IO 容量は一般的に専用サーバー コンピューターより限られるということです。 そのため、不必要な IO を最小限に抑え、Azure SQL Database のサービス層の各パフォーマンス レベルの DTU 内でシステムを最大限に活用することが有効です。 物理データベースに適切な設計を選択すると、個々のクエリの待ち時間とスケール単位で処理可能な同時要求のスループットを大幅に改善し、クエリを満たすために必要なコストを最小限に抑えることができます。 欠落インデックス Dmv の詳細については、次を参照してください。 [sys.dm_db_missing_index_details](https://msdn.microsoft.com/library/ms345434.aspx)します。

### クエリ調整/ヒント
Azure SQL Database 内のクエリ オプティマイザーは従来の SQL Server クエリ オプティマイザーと非常に似ています。 クエリを調整し、クエリ オプティマイザーの推論モデル制約を理解する最良事例の多くは Azure SQL Database にも適用されます。 Azure SQL Database のクエリを調整すると、総リソース要求を減らせる場合があります。また、下位のパフォーマンス レベルで実行できるため、調整されている場合に比べ、低コストでアプリケーションを実行できます。

SQL Server で観察される共通例で、Azure SQL Database にも適用できるものの 1 つは、コンパイル中、より最適なプランを作成するためにパラメーターを「sniffed (探り出す)」方法に関連します。 パラメーター スニッフィングは、より最適なクエリ プランを作成する目的でクエリをコンパイルするとき、クエリ オプティマイザーがパラメーターの現在値を考慮するプロセスです。 この方針で、多くの場合、パラメーター値に関する知識なしでコンパイルされたプランより大幅に速いクエリ プランが作成されますが、現在の SQL Server/Azure SQL Database の動作は完全ではありません。パラメーターを探り出せない場合があります。また、パラメーターが検索されても、ある作業負荷のフルセットのパラメーター値に対し、生成されたプランは次善となる場合があります。 Microsoft はクエリ ヒント (指示) を追加しています。それを利用すれば、意図をより慎重に指定し、パラメーター スニッフィングの既定動作を上書きできます。 多くの場合、SQL Server/Azure SQL Database の既定の動作ではお客様の作業負荷に完全に対応できない問題を解消するのにヒントが役立ちます。

次の例は、パフォーマンス要件とリソース要件の両方で次善となるプランをクエリ プロセッサが生成するしくみと、Azure SQL Database でクエリ ヒントを利用し、クエリ ランタイムを短縮し、リソース要件を減らすしくみを示しています。

次はサンプル セットアップです。

    DROP TABLE psptest1;
    CREATE TABLE psptest1(col1 int primary key identity, col2 int, col3 binary(200));
    
    DECLARE @a int = 0;
    SET NOCOUNT ON;
    BEGIN TRANSACTION
    WHILE @a < 20000
    BEGIN
        INSERT INTO psptest1(col2) values (1);
        INSERT INTO psptest1(col2) values (@a);
        SET @a += 1;
    END
    COMMIT TRANSACTION
    CREATE INDEX i1 on psptest1(col2);
    GO
    
    CREATE PROCEDURE psp1 (@param1 int)
    AS
    BEGIN
        INSERT INTO t1 SELECT * FROM psptest1 
        WHERE col2 = @param1
        ORDER BY col2;
    END
    GO
    
    CREATE PROCEDURE psp2 (@param2 int)
    AS
    BEGIN
        INSERT INTO t1 SELECT * FROM psptest1 WHERE col2 = @param2
        ORDER BY col2
        OPTION (OPTIMIZE FOR (@param2 UNKNOWN))
    END
    GO
    
    CREATE TABLE t1 (col1 int primary key, col2 int, col3 binary(200));
    GO

このセットアップ コードでは、傾斜データ分布を含むテーブルが作成されます。 最適なクエリ プランは、選択されているパラメーターによって異なります。 残念ながら、プラン キャッシング動作は常に最も一般的なパラメーター値に基づいてクエリを再コンパイルするとは限りません。つまり、別のプランのほうが平均的プランとしてより良い選択になる場合でも、次善プランがキャッシュされ、多くの値に使用される可能性があります。 次に、そのうちの 1 つに特殊なクエリ ヒントが含まれることを除いて、同じストアド プロシージャが 2 つ作成されます (理由は後続で説明されます)。

**例 (パート 1):**

    -- Prime Procedure Cache with scan plan
    EXEC psp1 @param1=1;
    TRUNCATE TABLE t1;
    
    -- Iterate multiple times to show the performance difference
    DECLARE @i int = 0;
    WHILE @i < 1000
    BEGIN
        EXEC psp1 @param1=2;
        TRUNCATE TABLE t1;
        SET @i += 1;
    END

**例 (パート 2 – この部分を試す前に 10 分間お待ちください。結果的に生成されるテレメトリ データが明らかに変わります。):**

    EXEC psp2 @param2=1;
    TRUNCATE TABLE t1;
    
    DECLARE @i int = 0;
    WHILE @i < 1000
    BEGIN
        EXEC psp2 @param2=2;
        TRUNCATE TABLE t1;
        SET @i += 1;
    END

この例の各パートで、(テスト データ セットに十分な関連負荷を生成するために) パラメーター化された挿入ステートメントが 1000 回実行されます。 ストアド プロシージャを実行するとき、クエリ プロセッサは、その最初のコンパイル中にプロシージャに渡されるパラメーター値を調べます (これがパラメーターの「スニッフィング」です)。 結果的に生成されたプランがキャッシュされ、パラメーター値が異なる場合でも、後の呼び出しで使用されます。 その結果、最適なプランが使用されないことがあります。 クエリが最初にコンパイルされたときのケースではなく、平均的ケースに最適なプランを選択するようにお客様がオプティマイザーを調整しなければならないこともあります。 この例では、最初のプランは、パラメーターに一致する各値を見つけるためにすべての行を読み込む「スキャン」プランを生成します。

![クエリ調整](./media/sql-database-performance-guidance/query_tuning_1.png)

値 1 でプロシージャを実行したので、結果的に生成されたプランは 1 に対して最適になるが、テーブルにあるその他すべての値に対しては次善となります。 各プランを無作為に選択した場合、結果として得られる動作は希望の動作とは異なるものになります。そのプランがゆっくり実行され、多くのリソースを使用するためです。

「SET STATISTICS IO ON」でテストを実行すると、内部でこの例で行われた論理スキャン作業が表示されます。このプランで 1148 件の読み取りが行われたことがわかります (平均的なケースで返される行がたった 1 つの場合、これは効率的ではありません)。

![クエリ調整](./media/sql-database-performance-guidance/query_tuning_2.png)

例の 2 つ目の部分では、クエリ ヒントを利用し、コンパイル プロセス中に特定の値を使用するようにオプティマイザーに伝えます。 この場合、パラメーターとして渡される値を無視し、代わりに「UNKNOWN」を想定するようにクエリ プロセッサに強制します。つまり、テーブルの平均頻度を持つ値です (傾斜を無視します)。 結果的に生成されるプランはシーク ベースのプランであり、例のパート 1 のプランに比べて概して速く、使用するリソースが少なくなります。

![クエリ調整](./media/sql-database-performance-guidance/query_tuning_3.png)

確認するにはこの効果がわかるように、 **sys.resource_stats** テーブル (注: があるテストを実行する時間の間に遅延をテーブルにデータを入力)。 この例の場合、パート 1 は 22:25:00 の時間枠で実行され、パート 2 は 22:35:00 の時間枠で実行されます。 早いほうの時間枠で遅いほうの時間枠に比べてその時間枠のリソースがより多く使用されることに注意してください (プランの効率性改善に起因)。

    SELECT TOP 1000 * 
    FROM sys.resource_stats 
    WHERE database_name = 'resource1' 
    ORDER BY start_time DESC

![クエリ調整](./media/sql-database-performance-guidance/query_tuning_4.png)

>[AZURE.NOTE] この例では、意図的に小規模、中に、準最適なパラメーターの影響が特に大規模なデータベースで非常に大きくなることができます。 極端なところ、速い場合は数秒単位、遅い場合は数時間単位になります。

調べることができます **sys.resource_stats** 、特定のテスト リソースが使用リソースが別のテストと比べて多いか少ないかどうかを決定します。 データを比較するときは、各いないグループ化されている同じ 5 分の時間] ウィンドウで十分な時間によってテスト、 **sys.resource_stats** 表示します。 また、演習の目標は使用される合計リソースを最小限に抑えることであり、ピーク リソース自体を最小限に抑えることではありません。 一般的に、待ち時間のコードの一部を最適化すると、リソース使用量も減ります。 アプリケーションで検討される変更は実際に必要なものであることを確認し、クエリ ヒントの利用時、アプリケーション利用者のカスタマー エクスペリエンスに悪影響を与えないようにしてください。

作業負荷に一連の繰り返しクエリが含まれる場合、大抵、そのようなプラン選択肢の最適性を記録し、検証すると有効です。おそらく、データベースをホストするために必要な最小リソース サイズ単位を推進します。 検証後、折に触れてこれらのプランを調べれば、劣化を回避できます。 クエリ ヒントの詳細については、次を参照してください。 [クエリ ヒント (TRANSACT-SQL)](https://msdn.microsoft.com/library/ms181714.aspx)します。

### データベース間のシャーディング
Azure SQL Database は汎用ハードウェアで実行されるため、従来のオンプレミス SQL Server インストールと比べ、1 台のデータベースに対して容量限度が一般的に低くなります。 そのため、Azure SQL Database でデータベース操作が 1 台のデータベースの上限に収まらないとき、多くのお客様がシャーディング手法を利用し、複数のデータベースにデータベース操作を分散しています。 現在、Azure SQL Database でシャーディング手法を利用するお客様の大半は、1 つの次元のデータを複数のデータベースで分割します。 この手法は、OLTP アプリケーションは、多くの場合、スキーマ内の 1 行またはほんの数行からなるグループにのみ適用されるトランザクションを実行することを理解した上で行われます。 

>[AZURE.NOTE] SQL データベースは、今すぐシャーディングを支援するライブラリを提供します。 詳細については、次を参照してください。 [エラスティック データベース クライアント ライブラリの概要](sql-database-elastic-database-client-library.md)します。

たとえば、(SQL Server 付属の従来のサンプル Northwind データベースのように) あるデータベースに顧客、注文、注文詳細が含まれる場合、注文と注文詳細が関連している顧客をグループにまとめ、1 つのデータベース内に留めることで、このデータを複数のデータベースに分割できます。 アプリケーションはデータベース間で顧客を分割し、効果的に負荷を分散します。 それにより、お客様がデータベース サイズの上限を回避できるだけでなく、個々のデータベースがその DTU に収まる限り、各パフォーマンス レベルの上限を大幅に超える作業負荷を Azure SQL Database で処理できます。

データベース シャーディングはソリューションの総リソース容量を減らしませんが、この手法は複数のデータベースにまたがる大規模ソリューションで非常に効果的であり、各データベースを異なるパフォーマンス レベルで実行し、リソース要件の高い、大規模で「効果的な」データベースをサポートできます。

### 機能的パーティション分割
SQL Server ユーザーは、多くの場合、1 台のデータベースのさまざまな機能を組み合わせます。 たとえば、アプリケーションに店舗の在庫を管理するロジックが含まれている場合、そのデータベースには、在庫に関連付けられているロジック、購買発注の追跡、ストアド プロシージャ、月末報告を管理するインデックス付きビュー/具体化されたビュー、その他の機能が含まれていることがあります。 この手法には、バックアップなどのデータベース操作を簡単に管理できるという利点がありますが、アプリケーションの機能全体でピーク負荷を処理できるようにハードウェアのサイズを調整する必要もあります。

Azure SQL Database 内で使用されるスケールアウト アーキテクチャ内では、多くの場合、アプリケーションの異なる機能を複数のデータベースに分割すると有効です。 それにより、各々を個別にスケール調整できます。 管理者は、アプリケーションがビジー状態になったとき (また、データベースの負荷が増えたとき)、アプリケーション内の機能ごとにパフォーマンス レベルを個別選択できます。 制約はありますが、複数のコンピューター間で負荷を分散することで、アプリケーションの処理能力を 1 台の汎用コンピューター以上に上げることがこのアーキテクチャで可能になります。 

### クエリの一括処理
頻繁にその場限りでクエリを実行し、データにアクセスするアプリケーションの場合、アプリケーション層と Azure SQL Database 層の間のネットワーク通信の応答に相当の時間が費やされます。 アプリケーションと Azure SQL Database が同じデータ センターに存在する場合でも、データ アクセス操作の数が多ければ、この 2 つの間のネットワーク待ち時間が長くなります。 このようなデータ アクセス操作のネットワーク ラウンド トリップを減らすために、アプリケーションの開発者は、アドホック クエリを一括処理するか、ストアド プロシージャにコンパイルすることを検討してください。 アドホック クエリを一括処理すると、複数のクエリを 1 つの大きなバッチとして 1 回のトリップで Azure SQL Database に送信できます。 アドホック クエリをストアド プロシージャにコンパイルすると、一括処理と同じ結果が得られます。 ストアド プロシージャを利用する場合、同じストアド プロシージャを後で実行するときのために、クエリ プランが Azure SQL Database にキャッシュされる機会が増えるという利点もあります。

一部のアプリケーションでは、書き込みが集中します。 場合によっては、書き込みを一括処理する方法を検討することで、データベースの IO 総負荷を減らせることがあります。 それは、多くの場合、ストアド プロシージャやアドホック バッチ内で、自動コミット トランザクションの代わりに、明示的トランザクションを使用するのと同じくらい単純になります。 使用できるさまざまな手法の評価は掲載されて [で、Azure SQL Database アプリケーションのバッチ処理手法](https://msdn.microsoft.com/library/windowsazure/dn132615.aspx)します。 独自の作業負荷を試し、一括処理に最適なモデルを探してください。モデルによっては、トランザクションの整合性がわずかに変わることがあります。 リソース使用を最小限に抑える作業負荷を見つけるには、整合性と性能の適度なバランスを見つける必要があります。 

### アプリケーション層のキャッシュ
データベース アプリケーションによっては、作業負荷の大半が読み取りになります。 キャッシュ層を利用すれば、データベースの負荷を減らすことができます。また、Azure SQL Database を利用するデータベースを支援するために必要なパフォーマンス レベルを下げられる可能性もあります。 [Azure Redis Cache](https://azure.microsoft.com/services/cache) 1 回のデータを読み取るには、読み取りの負荷のワークロードでカスタマー (または多くの場合の構成方法によって、アプリケーション層コンピューターごとに 1 回) し、Azure SQL データベースの外部には、そのデータを格納します。 それにより、データベースの負荷 (CPU と読み取り IO) を減らすことができますが、トランザクションの整合性が影響を受けます。キャッシュから読み込まれるデータはデータベースのデータよりも古いことがあるためです。 多くのアプリケーションでは一定の不整合が許容されますが、すべての作業負荷で許容されるとは限りません。 アプリケーション層のキャッシュ手法を採用する前に、あらゆるアプリケーション要件を完全に理解してください。

## まとめ

Azure SQL Database のサービス層を利用すると、クラウドに構築する各種アプリケーションの水準を上げることができます。 さらにアプリケーションの調整も頻繁に行うことで、アプリケーションのパフォーマンスが強力かつ予測可能となります。 このドキュメントでは、特定のパフォーマンス レベルに問題なく適合するようにデータベースのリソース利用を最適化するための推奨手法について説明します。 クラウド モデルにおいては調整は継続的に実施するものであり、それにより、各種のサービス層とそのパフォーマンス レベルにおいて、管理者はパフォーマンスを最大限に引き出し、同時に Microsoft Azure Platform のコストを最小限に抑えることができます。

