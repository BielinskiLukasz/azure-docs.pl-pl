<properties
   pageTitle="Reliable Collection | Microsoft Azure"
   description="Service Fabric ステートフル サービスは、可用性と拡張性が高く、待機時間が短いクラウド アプリケーションの記述を可能にする Reliable Collection を提供します。"
   services="service-fabric"
   documentationCenter=".net"
   authors="mcoskun"
   manager="timlt"
   editor="masnider,jessebenson"/>

<tags
   ms.service="service-fabric"
   ms.devlang="dotnet"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="required"
   ms.date="11/11/2015"
   ms.author="mcoskun"/>


# Service Fabric ステートフル サービスの Reliable Collection の概要

Reliable Collection では、高可用性、拡張性が高くと低待機時間を記述できます。
1 台のコンピューターのアプリケーションを作成しているものとしては、クラウドのアプリケーションを実行します。
内のクラス、 `Microsoft.ServiceFabric.Data.Collections` 名前空間の既定のセットを提供します。
高可用性の状態が自動的に構成するコレクションです。
開発者のみが必要なプログラムの Reliable Collection Api を Reliable Collection
レプリケートされたローカルの状態を管理します。

Reliable Collection とその他の高可用性テクノロジの主な違い
(たとえば Redis、Azure テーブル サービス、および Azure キュー サービス) の状態があるは
実現している高可用性、サービス インスタンスにローカルに保持されます。
これは、次のことを意味します。

1. すべての読み取りはローカルで実行されるため、待機時間が短くスループットが高い読み取りになります。
2. すべての書き込みではネットワーク IO 回数が最小に抑えられるため、待機時間が短くスループットが高い書き込みになります。

![コレクションの進化のイメージです。](media/service-fabric-reliable-services-reliable-collections/ReliableCollectionsEvolution.png)

Reliable Collection は自然に進化したもの、 `System.Collections`
クラス: 新しい一連のクラウドおよび複数のコンピューター用に作成されたコレクション
開発者の複雑さを増大させることがなくアプリケーションです。
そのため Reliable Collection には次の特長があります。

1. レプリケートされる: 状態の変更がレプリケートされるため、高可用性を実現できる。
2. 永続化される: データがディスクに永続化されるため、大規模な障害 (例: データセンターの電源障害) が発生しても影響を受けない。
3. 非同期: API は 非同期であるため、IO の実行時にスレッドがブロックされない。
4. トランザクション: API ではトランザクションの抽象化が使用できるため、サービス内で複数の Reliable Collection を簡単に管理できる。

Reliable Collection での順序で特別な強力な一貫性を保証を提供します。
やすくするために理由については、アプリケーションの状態。
トランザクション全体の後にのみ完全なトランザクションがコミットされるようにすることで強力な一貫性を実現します。
プライマリを含むレプリカのクォーラムに適用されています。
弱い整合性、アプリケーションがクライアントに応答できる/要求元
前に、非同期コミットを返します。

Reliable Collection Api は同時実行コレクション Api の進化
(で見つかった、 `System.Collections.Concurrent` 名前空間)。

1. 非同期: 同時実行コレクションとは異なり、操作がレプリケートおよび永続化されるため、タスクを返します。
2. Out パラメーターを使用しない: を使用して `ConditionalResult < T >` bool 型の値と出力パラメーターの代わりに値を返します。`ConditionalResult < T >` のように、 `Nullable < T >` 、構造体にするのには「T は必要ありません。
3. トランザクション: トランザクション オブジェクトを使用することで、トランザクション内で複数の Reliable Collection に対してユーザーがグループ操作を実行できます。

現在、`Microsoft.ServiceFabric.Data.Collections` には次の 2 つのコレクションが含まれています。

1. [Reliable Dictionary](https://msdn.microsoft.com/library/azure/dn971511.aspx): レプリケートされた、トランザクション、および非同期キー/値ペアのコレクションを表します。 `ConcurrentDictionary` のように、キーと値のいずれにも任意の型を使用できます。
2. [Reliable Queue](https://msdn.microsoft.com/library/azure/dn971527.aspx): レプリケートされた、トランザクション、および非同期厳密な先入れ先出し (FIFO) キューを表します。 `ConcurrentQueue` のように、値には任意の型を使用できます。

## 分離レベル

分離レベルは、達成された分離の程度を示します。
分離では、トランザクションが、システムのみが許可されるのと同様に動作することを意味します。
指定された任意の時点で実行中である 1 つのトランザクション。

Reliable Collection を使用する分離レベルを自動的に選択する、指定されました。
読み取り操作と、レプリカのロールに合わせて操作。

Reliable Collection では、次の 2 つの分離レベルがサポートされています。

- **Repeatable Read**:"ステートメントが変更されたが他のトランザクションによってコミットされていないデータを読み取ることができないし、他のトランザクションはデータを変更、現在のトランザクションが完了するまで、現在のトランザクションによって読み取られたことを指定します。 (https://msdn.microsoft.com/library/ms173763.aspx)"
- **スナップショット**: "トランザクションの任意のステートメントによって読み取られたデータが、トランザクションの開始時に存在していた、トランザクション全体を通じて整合性のあるバージョンのデータになることを指定します。 トランザクションで認識されるのは、トランザクション開始前にコミットされたデータ変更のみです。 現在のトランザクションの開始後に他のトランザクションによって行われたデータ変更は、現在のトランザクションで実行されているステートメントには認識されません。 それはつまり、トランザクションの開始時に存在していたコミット済みデータのスナップショットを、トランザクション内のステートメントが取得しているかのように機能するということです。 (https://msdn.microsoft.com/library/ms173763.aspx)"

Reliable Dictionary と Reliable Queue では、Read Your Writes がサポートされます。
つまり、トランザクション内ですべての書き込みが読み取る次を参照できます。
同じトランザクションに所属します。

### Reliable Dictionary

| 操作\ロール| プライマリ| セカンダリ|
| --------------------- | :--------------- | :--------------- |
| 1 つのエンティティの読み取り| 反復可能読み取り| スナップショット|
| 列挙\カウント| スナップショット| スナップショット|

### Reliable Queue

| 操作\ロール| プライマリ| セカンダリ|
| --------------------- | :--------------- | :--------------- |
| 1 つのエンティティの読み取り| スナップショット| スナップショット|
| 列挙\カウント| スナップショット| スナップショット|

## 永続性モデル

Reliable State Manager および Reliable Collection は、ログとチェックポイントと呼ばれる永続性モデルに従います。
このモデルでは、各状態の変更がディスクにログ記録され、メモリにのみ適用されます。
完全な状態が永続化されるのはごくまれです ( チェックポイントとしても知られています)。
このモデルを使用する利点は次のとおりです。

- 差分がディスクに対する追加専用のシーケンシャル書き込みに変換されるため、パフォーマンスが向上する。

ログとチェックポイント モデルをよく理解するために、まず無限のディスクのシナリオを見てみましょう。
Reliable State Manager が、すべての操作をレプリケートされる前にログ記録します。
これにより、Reliable Collection はメモリにおいてのみ操作を適用できます。
信頼できる状態マネージャーのログが保存される、レプリカが失敗し、再起動する必要がある場合でも、ため
レプリカが失われたすべての操作を再生するには、そのログに十分な情報があります。
ディスクは無限であるためログ レコードを削除する必要はなく、Reliable Collection が実行する必要があるのは、メモリ内にある状態を管理することだけです。

次に、有限のディスクのシナリオを見ていきましょう。
ある時点で、Reliable State Manager が使用するディスク領域が不足します。
そのような不足が発生する前に、Reliable State Manager は、ログを切り捨てて新しいレコードを格納する領域を確保する必要があります。
このとき Reliable State Manager は、メモリ内の状態をチェックポイントとしてディスクに記録するように Reliable Collection に要求します。
その時点までの状態を永続化するのは Reliable Collection の役目です。
Reliable Collection がチェックポイントを完了すると、Reliable State Manager はログを切り捨ててディスク領域を解放できます。
これにより、レプリカを再起動する必要があるとき Reliable Collection は回復の
チェックポイントが設定された状態と、Reliable State Manager は回復し、発生したすべての状態変更の再生
チェックポイント以降。

## ロック

Reliable Collection は、すべてのトランザクションは 2 段階: トランザクションを解放しません。
取得したが、トランザクションが中止またはコミットして終了するまでロックされます。

Reliable Collection は、常に排他ロックを取得します。
読み取りの場合、ロックはいくつかの要因によって使用方法が異なります。
スナップショット分離を使用して行う読み取り操作ではロックは使用されません。
反復可能読み取り操作では、既定で共有ロックを取得します。
ただし、反復可能読み取りをサポートする操作を読み取る任意のユーザーを求めること、
共有ロックではなくロックを更新します。
更新ロックは、一般的な形式のデッドロックを防ぐために使用した非対称ロックします。
複数のトランザクションは後で潜在的な更新プログラムのリソースをロックすると発生します。

次に示すのは、ロックの互換性対応表です。

| 要求\許可| なし| 共有| 更新| 排他的|
| ----------------- | :----------- | :----------- | :---------- | :----------- |
| 共有| 競合なし| 競合なし| 競合| 競合|
| 更新| 競合なし| 競合なし| 競合| 競合|
| 排他的| 競合なし| 競合| 競合| 競合|

デッドロック検出のために、Reliable Collection API の timeout 引数が使用されることに注意してください。
たとえば、2 つのトランザクション (T1 と T2) が K1 を読み取って更新しようとしているとします。
いずれも共有ロックを取得することになるため、両方にデッドロックが発生する可能性があります。
この場合、一方または両方の操作がタイムアウトになります。

上記のデッドロックのシナリオは、デッドロックを更新ロックによって回避する良い例です。

## 推奨事項

- **しないで** 読み取り操作によって返されるカスタム型のオブジェクトを変更 (例: `TryPeekAsync` または `TryGetAsync`)。 Reliable Collection は、同時実行コレクションのように、コピーではなくオブジェクトへの参照を返すからです。
- 返されたカスタム型のオブジェクトは、変更する前に**詳細コピー**してください。 構造体型と組み込み型は値渡しであるため、詳細コピーを実行する必要はありません。
- **しないで** を使用して `TimeSpan.MaxValue` のタイムアウト。 タイムアウトはデッドロックの検出に使用してください。
- **しないで** 別のトランザクション内でトランザクションを作成 `を使用して` ステートメント デッドロックを引き起こす可能性があるためです。

次の点に注意してください。

- すべての Reliable Collection API の既定のタイムアウトは 4 秒です。 ほとんどの場合において、ユーザーがこれをオーバーライドすることはお勧めしません。
- すべての Reliable Collection API で、既定のキャンセル トークンは `CancellationToken.None` です。
- Reliable Dictionary のキー タイプ パラメーター (TKey) では、GetHashCode() と Equals() が正しく実装されている必要があります。 キーは不変である必要があります。
- 列挙体は、コレクション内で整合性のあるスナップショットです。 ただし、複数コレクションの列挙体にはコレクション間での整合性はありません。
- Reliable Collection で高可用性を実現するには、各サービスに少なくとも 1 つのターゲットと、最低 3 台で構成されるレプリカ セットが必要です。

## 次のステップ

- [信頼性の高いサービスのクイック スタート](service-fabric-reliable-services-quick-start.md)
- [Service Fabric Web API サービスの概要](service-fabric-reliable-services-communication-webapi.md)
- [Reliable Services プログラミング モデルの使用方法の詳細](service-fabric-reliable-services-advanced-usage.md)
- [Reliable Collection の開発者向けリファレンス](https://msdn.microsoft.com/library/azure/microsoft.servicefabric.data.collections.aspx)





