<properties
   pageTitle="高信頼アクターのライフサイクル | Microsoft Azure"
   description="Service Fabric 高信頼アクターのライフサイクルとガベージ コレクションについて説明します"
   services="service-fabric"
   documentationCenter=".net"
   authors="jessebenson"
   manager="timlt"
   editor=""/>

<tags
   ms.service="service-fabric"
   ms.devlang="dotnet"
   ms.topic="article"
   ms.tgt_pltfrm="NA"
   ms.workload="NA"
   ms.date="08/05/2015"
   ms.author="amanbha"/>


# アクターのライフサイクルとガベージ コレクション
アクターは最初の呼び出し時にアクティブ化されます。 一定期間使用されていない場合、アクターは非アクティブ化されます (アクター ランタイムによってガベージ コレクトされる)。 この期間を構成するには、以下のアクターのガベージ コレクションに関するセクションを参照してください。

アクターをアクティブ化する場合:

- アクターが呼び出し時にまだアクティブになっていない場合は、新しいアクターが作成されます。
- アクターの状態が読み込まれます (ステートフル アクターの場合)。
- `OnActivateAsync` メソッド (アクターの実装でオーバーライドできる) が呼び出されます。
- アクターは、アクティブ アクター テーブルに追加されます。

アクターを非アクティブ化する場合:

- アクターは、一定期間使用されていない場合、アクティブ アクター テーブルから削除されます。
- `OnDeactivateAsync` メソッド (アクターの実装でオーバーライドできる) が呼び出されます。 呼び出されると、アクターのタイマーをすべてクリアします。

> [AZURE.TIP] Fabric アクター ランタイムは、いくつか出力 [アクターのアクティブ化と非アクティブ化に関連するイベント](service-fabric-reliable-actors-diagnostics.md#actor-activation-and-deactivation-events)です。 これらは、診断やパフォーマンスの監視に役立ちます。

## アクターのガベージ コレクション
アクター ランタイムは、一定期間使用されていないアクターを定期的にスキャンし、そのアクターを非アクティブ化します。 アクターは非アクティブ化されると、共通言語ランタイム (CLR) でガベージ コレクトすることができます。

ガベージ コレクションの目的で、次のような状態は「使用中」と見なされます。

- 呼び出しを受信する
- `IRemindable.ReceiveReminderAsync` メソッドが呼び出されている (アクターがアラームを使用する場合にのみ適用可)

アクターがタイマーを使用して、そのタイマーのコールバックが呼び出される場合は、行われていることに注意して **いない** 「使用中」とカウントします。

ガベージ コレクションの詳細に入る前に、次の用語を定義することが重要です。

- *スキャン間隔*します。 これは、アクター ランタイムがアクティブ アクター テーブルで、ガベージ コレクトできるアクターをスキャンする間隔です。 この既定値は 1 分です。
- *アイドル タイムアウト*します。 これは、ガベージ コレクションの前に、アクターを未使用 (アイドル) のままにしておく必要がある時間です。 この既定値は 60 分です。

通常は、これらの既定値を変更する必要はありません。 ただし、必要に応じて、`ActorGarbageCollection` 属性を使用して、これらの間隔をそのアセンブリ内のすべてのアクター型のアセンブリ レベルまたはアクター型レベルで変更することはできます。 次の例は、HelloActor のガベージ コレクション間隔の変更を示しています。

```csharp
[ActorGarbageCollection(IdleTimeoutInSeconds = 10, ScanIntervalInSeconds = 2)]
class HelloActor : Actor, IHello
{
    public Task<string> SayHello(string greeting)
    {
        return Task.FromResult("You said: '" + greeting + "', I say: Hello Actors!");
    }
}
```

アセンブリ レベルで `ActorGarbageCollection` 属性の既定値を変更するには、次のスニペットを `AssemblyInfo.cs` に追加します。

```csharp
[assembly: ActorGarbageCollection(IdleTimeoutInSeconds = 10, ScanIntervalInSeconds = 2)]
```

アクティブ アクター テーブル内の各アクターについて、アクター ランタイムはアイドル (つまり、未使用) 状態だった時間を追跡します。 アクター ランタイムは、`ScanIntervalInSeconds` ごとにアクターをそれぞれチェックして、ガベージ コレクションが可能かどうかを確認し、`IdleTimeoutInSeconds` の間アイドル状態だった場合はアクターを収集します。

アクターが使用されるたびに、そのアイドル時間は 0 にリセットされます。 その後、アクターをガベージ コレクトできるのは、再び `IdleTimeoutInSeconds` の間アイドル状態のままになった場合のみです。 アクター インターフェイス メソッドまたはアクター アラーム コールバックが実行された場合、アクターは使用されていると見なされることを思い出してください。 アクターは、 **いない** そのタイマーのコールバックが実行された場合に使用されていると見なされます。

次の図には、これらの概念を説明するための例が含まれています。

![アイドル時間の例][1]

この例は、アクティブ アクター テーブルに 1 つだけアクティブ アクターがあることを前提としています。 この例では、このアクターの有効期間に対するアクター メソッドの呼び出し、アラームおよびタイマーの影響を示しています。 この例では次の点に注意する必要があります。

- ScanInterval は 5、IdleTimeout は 10 にそれぞれ設定されます。 (概念の説明のみが目的であるため、ここでは単位は重要ではありません)。
- ガベージ コレクションの対象となるアクターのスキャンは、5 のスキャン間隔で定義されると、T=0、5、10、15、20、25 で行われます。
- 定期的なタイマーは T=4、8、12、16、20、24 で開始され、そのコールバックが実行されます。 アクターのアイドル時間に影響はありません。
- T=7 のアクター メソッド呼び出しは、アイドル時間を 0 にリセットし、アクターのガベージ コレクションを遅らせます。
- アクター アラームのコールバックは T=14 で実行され、アクターのガベージ コレクションをさらに遅らせます。
- T=25 のガベージ コレクションのスキャン中に、アクターのアイドル時間は最終的に 10 のアイドル タイムアウトを超え、アクターはガベージ コレクトされます。

メソッドの実行にどれだけ時間がかかっても、メソッドのいずれかが実行されている間にアクターがガベージ コレクトされることはないことに注意してください。 前述のように、アクター インターフェイス メソッドとアラームのコールバックを実行すると、アクターのアイドル時間が 0 にリセットされるため、ガベージ コレクションが行われなくなります。 タイマー コールバックの実行では、アイドル時間は 0 にリセットされません。 ただし、タイマー コールバックの実行が完了するまで、アクターのガベージ コレクションは遅延されます。

<!--Image references-->
[1]: ./media/service-fabric-reliable-actors-lifecycle/garbage-collection.png


