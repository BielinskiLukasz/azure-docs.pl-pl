<properties
   pageTitle="API 設計ガイダンス | Microsoft Azure"
   description="適切に設計された API の作成方法についてのガイダンス。"
   services=""
   documentationCenter="na"
   authors="dragon119"
   manager="masimms"
   editor=""
   tags=""/>

<tags
   ms.service="best-practice"
   ms.devlang="rest-api"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="na"
   ms.date="04/28/2015"
   ms.author="masashin"/>

# API 設計ガイダンス

![](media/best-practices-api-design/pnp-logo.png)

このガイダンスの一部のトピックは審議中であり、今後変更される場合があります。 ご意見をお待ちしております。


## 概要

現代の多くの Web ベース ソリューションでは、Web サーバーによりホストされる Web サービスを使用することで、リモート クライアント アプリケーションの機能を提供します。 Web サービスにより公開される操作によって Web API が構成されています。 適切に設計された Web API には、次をサポートする目的があります。

- **プラットフォームに依存しない**します。 クライアント アプリケーションは、API により公開されるデータや操作の物理的な実装方法を要求することなく、Web サービスが提供する API を利用できる必要があります。 そのためには、API が共通基準を順守し、クライアント アプリケーションおよび Web サービスが、使用するデータ形式や、クライアント アプリケーションと Web サービスの間で交換されるデータ構造に同意できるようにする必要があります。

- **サービスの進化**します。 Web サービスはクライアント アプリケーションから独立して進化し、機能を追加 (または削除) できる必要があります。 Web サービスにより提供される機能は変化するため、既存のクライアント アプリケーションは変化せずに操作を継続できる必要があります。 すべての機能も検出可能で、クライアント アプリケーションで十分に利用できるようにする必要があります。

このガイダンスでは、Web API を設計するときに考慮する問題について説明します。

## Representational State Transfer (REST) の概要

ロイ・フィールディングは 2000 年に著した論文で、Web サービスにより公開される操作を構築する、代わりとなるアーキテクチャ アプローチを提唱しました。それが REST です。 REST はハイパーメディアに基づき分散システムを構築するアーキテクチャ スタイルです。 REST モデルの主な利点は、オープン スタンダードに基づいており、それにアクセスするモデルやクライアント アプリケーションの実装を、特定の実装に結びつけないという点です。 たとえば、REST Web サービスは Microsoft ASP.NET Web API を使用して実装でき、クライアント アプリケーションは任意の言語および HTTP 要求の生成と HTTP 応答の解析を行うことができるツールセットを使用して開発できます。

> [AZURE.NOTE]: 残りの部分は、実際には、基になるプロトコルに依存しない HTTP に必ずしも関連付けられていません。 とはいえ、REST に基づくシステムを実装する際には、要求を送受信するアプリケーション プロトコルとして HTTP を利用するのが最も一般的です。 本文書では、HTTP を使用して操作するように設計されているシステムに REST の原則をマッピングすることに重点を置いて説明します。

REST モデルでは、ナビゲーション スキームを使用して、ネットワーク経由でのオブジェクトとサービスを表す (と呼ばれる _リソース_)。 通常、REST を実装する多くのシステムでは、これらのリソースにアクセスするための要求を送信するのに HTTP プロトコルを使用します。 これらのシステムでクライアント アプリケーションは、リソースを識別する URI、およびそのリソースで実行する操作を示す HTTP メソッド (最も一般的なのは GET、POST、PUT、DELETE) の形式で要求を送信します。  HTTP 要求の本文には、操作を実行するのに必要なデータが含まれています。 REST はステートレスの要求モデルを定義することを理解することは重要です。 HTTP 要求は独立している必要があり、任意の順序で起こる場合があります。そのため、要求間の遷移状態の情報を保持しようとすることはできません。  情報の格納場所はリソース自体のみであり、それぞれの要求はアトミックな操作である必要があります。 実用上、REST モデルは Finite State Machine を実装し、要求によって、リソースは適切に定義された非遷移状態から別の状態に切り替えられます。

> [AZURE.NOTE] REST モデルの個々 の要求のステートレスな性質により、拡張性の高いするこれらの原則に従って構築されたシステム。 一連の要求を行うクライアント アプリケーションと、それらの要求を処理する特定の Web サーバーの関係を保持する必要は一切ありません。

効率的な REST モデルを実装するうえで他にも重要な点は、モデルによりアクセスが提供されるさまざまなリソース間のリレーションシップを理解することです。 通常、これらのリソースはコレクションおよびリレーションシップとして構成されます。 たとえば、電子商取引システムの迅速な分析により、クライアント アプリケーションが関心を持つ可能性の高い、注文と顧客という 2 つのコレクションがあることが示されると想定してください。 それぞれの注文と顧客には、特定するための独自の一意なキーがある必要があります。 注文のコレクションにアクセスする URI は、単純なものである可能性があります _/orders_, と同様にすべての顧客を取得する URI _/customers_します。 HTTP GET 要求を発行する、 _/orders_ URI と HTTP 応答としてエンコードされたコレクションのすべての注文を表すリストを返す必要があります。

```HTTP
GET http://adventure-works.com/orders HTTP/1.1
...
```

以下に示す応答は、注文を XML リスト構造でエンコードします。 このリストには、7 件の注文が含まれています。

```HTTP
HTTP/1.1 200 OK
...
Date: Fri, 22 Aug 2014 08:49:02 GMT
Content-Length: ...
<OrderList xmlns:i="..." xmlns="..."><Order><OrderID>1</OrderID><OrderValue>99.90</OrderValue><ProductID>1</ProductID><Quantity>1</Quantity></Order><Order><OrderID>2</OrderID><OrderValue>10.00</OrderValue><ProductID>4</ProductID><Quantity>2</Quantity></Order><Order><OrderID>3</OrderID><OrderValue>16.60</OrderValue><ProductID>2</ProductID><Quantity>4</Quantity></Order><Order><OrderID>4</OrderID><OrderValue>25.90</OrderValue><ProductID>3</ProductID><Quantity>1</Quantity></Order><Order><OrderID>7</OrderID><OrderValue>99.90</OrderValue><ProductID>1</ProductID><Quantity>1</Quantity></Order></OrderList>
```
個々 の注文を取得するからの注文の識別子を指定することが必要、 _注文_ リソースなど _/注文/2_:

```HTTP
GET http://adventure-works.com/orders/2 HTTP/1.1
...
```

```HTTP
HTTP/1.1 200 OK
...
Date: Fri, 22 Aug 2014 08:49:02 GMT
Content-Length: ...
<Order xmlns:i="..." xmlns="...">
<OrderID>2</OrderID><OrderValue>10.00</OrderValue><ProductID>4</ProductID><Quantity>2</Quantity></Order>
```

> [AZURE.NOTE] わかりやすいようには、これらの例は、XML テキスト データとして返される応答に情報を表示します。 ただし、バイナリ情報や暗号化情報など HTTP によりサポートされている他の種類のデータをリソースに一切含めるべきでない理由はありません。HTTP 応答の content-type では種類を指定する必要があります。 また、REST モデルは XML や JSON など、異なる形式の同じデータを返すことができる場合があります。 この場合、Web サービスは要求を行うクライアントとのコンテント ネゴシエーションを実行できる必要があります。 要求を含めることができます、 _Accept_ ヘッダーで、クライアントが受信するよう、この形式を使用可能であればべきでは、web サービスと優先形式を指定します。

REST 要求からの応答では標準 HTTP 状態 コードが使用されていることに注意してください。 たとえば、有効なデータを返す要求には HTTP 応答コード 200 (OK) を含める必要があり、指定したリソースの確認および削除に失敗した要求は HTTP 状態コード 404 (Not Found) を含む応答を返す必要があります。

## RESTful Web API の設計と構造

正常な Web API を設計するポイントは、単純さと一貫性です。 Web API がこれらの 2 つの要素を備えていると、API を消費する必要があるクライアント アプリケーションを簡単に構築できます。

RESTful Web API は一連の接続されたリソースを公開し、アプリケーションがこれらのリソースを操作してリソース間を簡単にナビゲートできるようにするコア操作を提供することに重点を置いています。 このため、一般的な RESTful Web API を構成する URI は、公開するデータ指向でなければならず、このデータを操作するために HTTP により提供される機能を使用する必要があります。 オブジェクトおよびクラスの動作に促される傾向がある オブジェクト指向 API の一連のクラスを設計する場合、このアプローチには一般的に採用されている考え方とは異なる考え方が必要です。 さらに、RESTful Web API はステートレスで、特定のシーケンスで呼び出される操作に依存しない必要があります。 次のセクションでは、RESTful Wb API を設計するときに考慮する必要があるポイントをまとめます。

### リソースに関係する Web API の構成

> [AZURE.TIP] REST web サービスにより公開される Uri は名詞に基づいている必要があります (web API アクセスを提供するデータ) および (アプリケーションで何ができますデータ) 動詞されません。

Web API が公開するビジネス エンティティに注目して説明します。 たとえば、前に説明した電子商取引システムをサポートするために設計された Web API で、主エンティティは顧客と注文です。 発注行為などのプロセスは、注文情報を取り込み、それを顧客の注文リストに追加する HTTP POST 操作を指定することで行うことができます。 内部ではこの POST 操作により、在庫レベルの確認や顧客への請求などのタスクを実行できます。 HTTP 応答は、発注が正常に行われたかどうかを示すことができます。 リソースは単一の物理データ項目に基づく必要はないことにも注意してください。 たとえば注文リソースは、リレーショナル データベースの複数のテーブルに分散する多くの行から集計した情報を使用して内部的に実装されるものの、クライアントには単一のエンティティとして表示される場合があります。

> [AZURE.TIP] ミラー化または公開するデータの内部構造に依存する REST インターフェイスを設計しないでください。 REST は、リレーショナル データベースの個別のテーブルに対して単純な CRUD (作成、取得、更新、削除) 操作を実行するだけのものではありません。 REST の目的は、ビジネス エンティティおよびアプリケーションがそれらのエンティティに実行できる操作を、それらのエンティティの物理実装にマッピングすることですが、これらの物理的詳細をクライアントに公開すべきではありません。

個々のビジネス エンティティはまれに分離して存在していますが (ただし、いくつかのシングルトン オブジェクトが存在する場合があります)、むしろ共にコレクションにグループ化される傾向にあります。 REST 用語では、各エンティティおよび各コレクションはリソースです。 RESTful web API で、各コレクションには Web サービス内に独自の URIがあり、コレクションの URI に対して HTTP GET 要求を実行することで、そのコレクションの項目の一覧を取得します。 個々の項目にも独自の URI があり、アプリケーションはその URI を使用して別の HTTP GET 要求を送信することで、その項目の詳細を取得できます。 コレクションと項目の URI は階層的に整理してください。 電子商取引システムで、URI _/customers_ 顧客のコレクションを表しますと _/customers/5_ このコレクションから ID 5 の単一の顧客の詳細を取得します。 この方法は、Web API を直感的に保つのに役立ちます。

> [AZURE.TIP] Uri で一貫性のある名前付け規則を採用します。一般にコレクションを参照する Uri の複数形の名詞を使用すると役立ちます。

異なる種類のリソース間のリレーションシップ、およびこの関連を公開する方法を検討する必要もあります。 たとえば、顧客の発注が 0 またはそれ以上である場合があります。 このリレーションシップを表す自然な方法がなどの URI を使用するよう _/customers/5/orders_ 顧客 5 のすべての注文を検索します。 などの URI より、特定の顧客に、注文からの関連を表すことも検討 _/orders/99/customer_ 注文 99 も遠すぎてこのモデルがこの実装が煩雑になることができますを拡張するための顧客を検索します。 より優れたソリューションは、注文のクエリを実行するときに返される HTTP 応答メッセージの本文に、顧客など関連するリソースに誘導できるリンクを記載することです。 このメカニズムの詳細については、本ガイダンスの「関連リソースへのナビゲーションを可能にする HATEOAS アプローチの使用」のセクションで後に説明します。

複雑なシステムである可能性があります多くの種類のエンティティ、およびいくつかのレベルのリレーションシップをナビゲートするクライアント アプリケーションを有効にする Uri を提供するがち _/customers/1/orders/99/products_ 注文 99 は顧客 1 により発注の製品の一覧を取得します。 ただし、将来的にリソース間のリレーションシップが変わる場合、このレベルの複雑さを維持するのは難しく、柔軟性がありません。 むしろ、URI を比較的シンプルに維持するようにします。 一度アプリケーションもリソースへの参照が備わると、この参照を使用してそのリソースに関連する項目を検索できることに注意してください。 上記のクエリは、URI で置き換えることが _/customers/1/orders_ 顧客 1 のすべての注文を検索し、uri _/orders/99/products_ (注文 99 は顧客 1 により発注されたと仮定して) 次の順序での製品を検索します。

> [AZURE.TIP] 複雑なリソース Uri を要求しないでください _コレクション/項目/コレクション_します。

考慮すべき別の点は、すべての Web 要求は Web サーバーに負荷を与えるため、要求回数が多くなるほど負荷も大きくなることです。 定義するリソースが、大量の小さなリソースを公開する「おしゃべりな」Web API にならないようにしてください。 そのような API では、クライアント アプリケーションが必要なすべてのデータを検索するために、複数の要求を送信する必要がある場合があります。 データを非正規化し、1 回の要求を発行して取得できる大きなリソースに関連情報を一緒に組み合わせることが有益な場合があります。 ただし、このアプローチでは、クライアントが頻繁には必要としないデータ取得のオーバーヘッドに対してバランスを取る必要があります。 ラージ オブジェクトを取得すると、追加データをあまり使用しない場合は要求の待機時間が延長し、追加の帯域幅コストが発生する可能性があり、メリットはほとんどありません。

Web API と、構造、種類、または基となるデータ ソースの間の依存性を導入しないようにしてください。 たとえば、データがリレーショナル データベースにある場合、Web API はそれぞれのテーブルをリソースのコレクションとして公開する必要はありません。 Web API をデータベースの抽象化と捉え、必要に応じてデータベースと Web API 間のマッピング レイヤーを導入します。 この方法により、データベースの設計や実装が変更されても (正規化されたテーブルのコレクションを含むリレーショナル データベースから、ドキュメント データベースなどの非正規化された NoSQL ストレージ システムへの移行など)、クライアント アプリケーションはこれらの変更による影響を受けません。
> [AZURE.TIP] Web API を支えるデータのソースがデータ ストア; する必要はありません。別のサービスがある可能性があります。 または基幹業務アプリケーションまたはを実行している従来のアプリケーション、オンプレミス組織内でします。

最後に、Web API により実装されるすべての操作を特定のリソースにマッピングできない場合があります。 などを処理できる _非リソース_ 機能の 1 つを呼び出し、結果を HTTP 応答メッセージとして返す HTTP GET 要求を通じてシナリオです。 加算や減算などの単純な電卓スタイルの操作を実装する Web API は、これらの操作を疑似リソースとして公開し、クエリ文字列を使用して必要なパラメーターを指定する URI を提供できます。 URI に GET 要求など _/add ですか? operand1 = 99 & operand2 = 1_ 本文に、値 100 を含む応答メッセージを返すし、URI に要求を取得する可能性があります _/subtract? operand1 1 = 50 & operand2 = 20_ 本文に、値 30 を含む応答メッセージを返すことができます。 ただし、これらの形式の URI は常に慎重に使用してください。

### HTTP メソッドに関する操作の定義

HTTP プロトコルにより、要求にセマンティックな意味を割り当てる多くのメソッドが定義されます。 ほとんどの RESTful Web API により使用される一般的な HTTP メソッドは次のとおりです。

- **取得**, 、指定された URI にリソースのコピーを取得します。 応答メッセージの本文には、要求されたリソースの詳細が含まれています。

- **POST**, 、指定された URI で新しいリソースを作成します。 応答メッセージの本文には、新しいリソースの詳細が記載されています。 POST は実際にはリソースを作成しない操作をトリガーするのにも使用できます。

- **PUT**, を置換または指定された URI にリソースを更新します。 応答メッセージの本文では、変更するリソースおよび適用する値が指定されています。

- **削除**, 、指定した URI のリソースを削除します。

> [AZURE.NOTE] HTTP プロトコルも他のあまり一般的に使用されるメソッドを定義などを使用してリソースを選択的更新を要求、HEAD 要求により、クライアントが情報をサーバーでサポートされる通信オプションに関する情報を取得するためのオプションは、リソースの説明に使用される修正プログラムを適用し、これにより、テストや診断目的で使用できる情報を要求するクライアントのトレースします。

特定の要求に対する影響は、適用されるリソースがコレクションまたは個別 の項目であるかによって異なります。 以下の表では、電子商取引の例を使用しながら、ほとんどの RESTful の実装で使用される一般的な規則をまとめています。 これらの要求がすべて実装されない場合があります。具体的なシナリオにより異なります。

| **リソース** | **POST** | **GET** | **PUT** | **削除** |
|--------------|----------|---------|---------|------------|
| /customers | 新しい顧客を作成 | すべての顧客を取得 | 顧客の一括更新 (_実装されている場合_) | すべての顧客を削除 |
| /customers/1 | エラー | 顧客 1 の詳細を取得 | 存在する場合に顧客 1 の詳細を更新。その他の場合はエラーを返す | 顧客 1 を削除 |
| /customers/1/orders | 顧客 1 の新しい注文を作成 | 顧客 1 のすべての注文を取得 | 顧客 1 の注文の一括更新 (_実装されている場合_) | 顧客 1 のすべての注文を削除 (_実装されている場合_) |

GET および DELETE 要求の目的は比較的単純ですが、POST および PUT 要求の目的および影響については混乱するかもしれません。

POST 要求は、要求の本文に含まれるデータで新しいリソースを作成します。 REST モデルでは、コレクションであるリソースに POST 要求を適用することがよくあります。新しいリソースがコレクションに追加されます。

> [AZURE.NOTE] 一部の機能をトリガーする (およびを必ずしもデータを返さない) POST 要求を定義することもでき、これらの種類の要求をコレクションに適用できます。 たとえば POST 要求を使用することで、給与支払い処理サービスにタイムシートを渡し、計算した税金が応答として返されます。

PUT 要求は既存のリソースを変更します。 指定されたリソースが存在しない場合、PUT 要求はエラーを返すことができます (場合によっては、実際にリソースを作成することがあります)。 PUT 要求は、個々の項目 (特定の顧客や注文など) であるリソースに適用されることが最も多いとはいえ、実装の頻度は低いもののコレクションに適用できます。 PUT 要求はべき等ですが、POST 要求はそうでないことに注意してください。あるアプリケーションが同じ PUT 要求を複数回送信すると結果は常に同じになるはずですが (同じリソースが同じ値で変更される)、あるアプリケーションが同じ POST 要求を繰り返しても、複数のリソースが作成されます。

> [AZURE.NOTE] 厳密に言えば、HTTP PUT 要求は、要求の本文に指定されたリソースで、既存のリソースを置き換えます。 リソースのプロパティの選択を変更するものの、他のプロパティは変更しない場合は、HTTP PATCH 要求を使用して実装します。 とはいえ、多くの RESTful の実装ではこの規則が緩和され、どちらの状況でも PUT が使用されます。

### HTTP 要求の処理
多くの HTTP 要求でクライアント アプリケーションにより含められるデータや、Web サーバーからの対応する応答メッセージは、さまざまな形式 (またはメディアの種類) で表示できます。 たとえば、顧客または注文の詳細を指定するデータは、XML、JSON、または他のエンコードおよび圧縮された形式として提供できます。 要求を送信するクライアント アプリケーションの要求に従い、RESTful Web API は異なるメディアの種類をサポートします。

クライアント アプリケーションがメッセージの本文でデータを返す要求を送信する場合、要求の Accept ヘッダーで処理可能なメディアの種類を指定できます。 次のコードは顧客 1 の詳細を取得し、結果が JSON として返されることを要求する HTTP GET 要求を示しています (クライアントは引き続き、応答に含まれるデータのメディアの種類を確認し、返されるデータの形式を確認する必要があります)。

```HTTP
GET http://adventure-works.com/orders/2 HTTP/1.1
...
Accept: application/json
...
```

Web サーバーがこのメディアの種類をサポートしている場合、メッセージの本文にデータの形式を指定する Content-Type ヘッダーを含む応答により、応答できます。

> [AZURE.NOTE] 最大の相互運用性は、Accept および Content-type ヘッダーで参照されている型でなければなりませんメディアは、いくつかのカスタム メディアの種類ではなくに MIME の種類を認識します。

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
Content-Length: ...
{"OrderID":2,"ProductID":4,"Quantity":2,"OrderValue":10.00}
```

Web サーバーが要求されたメディアの種類をサポートしていない場合、異なる形式でデータを送信できます。 すべてのケースでは、メディアの種類を指定する必要があります (よう _テキスト/xml_) Content-type ヘッダーにします。 応答メッセージを解析し、メッセージ本文内の結果を適切に解釈することはクライアント アプリケーションの役割です。

この例では、Web サーバーが要求されたデータを正常に取得し、応答ヘッダーで状態コード 200 を渡すことで成功を示しています。 一致するデータが見つからない場合は、代わりに状態コード 404 (見つかりません) が返され、応答メッセージの本文には追加情報を含めることができます。 この情報の形式は、次の例で示されるように Content-Type ヘッダーにより指定されます。

```HTTP
GET http://adventure-works.com/orders/222 HTTP/1.1
...
Accept: application/json
...
```

注文 222 が存在しないため、応答メッセージは次のようになります。

```HTTP
HTTP/1.1 404 Not Found
...
Content-Type: application/json; charset=utf-8
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
Content-Length: ...
{"Message":"No such order"}
```

アプリケーションがリソースを更新するために HTTP PUT 要求を送信すると、リソースの URI が指定され、要求メッセージの本文で変更されるデータが提供されます。 Content-Type ヘッダーを使用して、このデータの形式を指定する必要もあります。 テキスト ベースの情報を使用する一般的な形式は _アプリケーション/x-www-form-urlencoded_, で区切られた名前/値ペアのセットで構成される、& の文字。 次の例は、注文 1 の情報を変更する HTTP PUT 要求を示しています。

```HTTP
PUT http://adventure-works.com/orders/1 HTTP/1.1
...
Content-Type: application/x-www-form-urlencoded
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
Content-Length: ...
ProductID=3&Quantity=5&OrderValue=250
```

正常に変更が行われる場合、プロセスが正常に処理されたものの、応答本文にはそれ以上の情報が含まれないことを示す HTTP 204 状態コードで応答するのが理想的です。 応答の Location ヘッダーには、新しく更新されたリソースの URI が含まれています。

```HTTP
HTTP/1.1 204 No Content
...
Location: http://adventure-works.com/orders/1
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
```

> [AZURE.TIP] HTTP PUT 要求メッセージ内のデータには、日付と時刻の情報が含まれている場合は、web サービスが日付を受け入れるし、時間の範囲には、ISO 8601 標準に従って書式設定を確認します。

更新するリソースが存在しない場合、Web サーバーは前に説明したように、Not Found 応答により応答できます。 または、サーバーが実際にはオブジェクト自体を作成する場合、状態コード HTTP 200 (OK) または HTTP 201 (Created) が返され、応答本文には新しいリソースのデータが含まれます。 要求の Content-Type ヘッダーが Web サーバーで処理できないデータ形式を指定する場合は、HTTP 状態コード 415 (Unsupported Media Type) で応答します。

> [AZURE.TIP] コレクション内の複数のリソースへの更新をバッチ処理できる一括 HTTP PUT 操作を実装することを検討してください。 PUT 要求はコレクションの URI を指定し、要求本文は変更するリソースの詳細を指定する必要があります。 この方法によりおしゃべりを減らし、パフォーマンスを向上させることができます。

新しいリソースを作成する HTTP POST 要求の形式は PUT 要求と類似しています。メッセージ本文に、追加する新しいリソースの詳細が含まれています。 ただし、URI は通常、リソースの追加先となるコレクションを指定します。 以下の例では新しい注文を作成し、注文コレクションにそれを追加しています。

```HTTP
POST http://adventure-works.com/orders HTTP/1.1
...
Content-Type: application/x-www-form-urlencoded
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
Content-Length: ...
ProductID=5&Quantity=15&OrderValue=400
```

要求が成功する場合、Web サーバーは HTTP 状態コード 201 (Created) を含むメッセージ コードで応答します。 Location ヘッダーには新しく作成されたリソースの URI が含まれ、応答の本文には新しいリソースのコピーが含まれます。Content-Type ヘッダーは次のデータの形式を指定します。

```HTTP
HTTP/1.1 201 Created
...
Content-Type: application/json; charset=utf-8
Location: http://adventure-works.com/orders/99
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
Content-Length: ...
{"OrderID":99,"ProductID":5,"Quantity":15,"OrderValue":400}
```

> [AZURE.TIP] PUT または POST 要求によって提供されたデータが有効でない場合は、web サーバーが HTTP ステータス コード 400 (Bad Request) でのメッセージで応答する必要があります。 このメッセージの本文には、要求の問題および想定される形式に関する追加情報を含めるか、詳細が記載された URL のリンクを含めることができます。

リソースを削除するには、HTTP DELETE 要求によって、削除するリソースの URI を単に提供します。 次の例では注文 99 を削除しようとしています。

```HTTP
DELETE http://adventure-works.com/orders/99 HTTP/1.1
...
```

削除操作が成功すると、Web サーバーは HTTP 状態コード 204 で応答します。このコードは、プロセスが正常に処理されたものの、応答本文にはそれ以上の情報が含まれないことを示します (これは正常な PUT 操作によって返されるのと同じ応答ですが、リソースがもう存在しないため Location ヘッダーがありません)。削除が非同期的に実行される場合、DELETE 要求で HTTP 状態コード 200 (OK) または 202 (Accepted) を返すこともできます。

```HTTP
HTTP/1.1 204 No Content
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
```

リソースが見つからない場合、Web サーバーは代わりに 404 (Not Found) メッセージを返します。

> [AZURE.TIP] コレクション内のすべてのリソースは、削除する場合に、アプリケーションでは、コレクションから各リソースをさらに削除するのではなく、コレクションの URI に指定される HTTP DELETE 要求を有効にします。

### データのフィルター処理と改ページ

URI をシンプルで直感的に保つように努める必要があります。 この点で単一の URI を使用してリソースのコレクションを公開することは役に立ちますが、情報のサブセットしか必要ではないときに、アプリケーションが大量のデータを取得する可能性があります。 膨大な量のトラフィックを生成することは Web サーバーのパフォーマンスおよび拡張性に影響を与えるだけでなく、データを要求しているクライアント アプリケーションの応答性にも悪影響を与えます。

たとえば、注文に、注文に対して支払った料金が含まれている場合、特定の値に対してコストがあるすべての注文を取得する必要があるクライアント アプリケーションがからすべての注文を取得する必要があります、 _/orders_ URI とし、フィルターこれらの注文をローカルにします。 明らかにこのプロセスの効率はあまり良くありません。Web API をホストするサーバー上のネットワーク帯域幅および処理能力を無駄にします。

などの URI スキームを指定する 1 つのソリューションが _/orders/ordervalue_greater_than_n_ 、 _n_ 注文価格が価格の限られた数は、この方法は実用的なありません。 さらに、他の条件に基づいて注文のクエリを実行する必要がある場合、直感的でない可能性がある名前が記載された長い URI リストが最終的に提供されます。

など、web API に渡されるクエリ文字列内のフィルター条件を指定するデータのフィルター処理するより良い方法は、 _/orders? ordervaluethreshold = n_します。 この例では、Web API の対応する操作はクエリ文字列の `ordervaluethreshold` パラメーターの解析および処理を行い、HTTP 応答でフィルター処理された結果を返します。

コレクション リソースに対する一部の単純な HTTP GET 要求では、多数の項目が返される可能性があります。 これが起こる可能性を解決するため、任意の単一な要求により返されるデータの量を制限するように Web API を設計する必要があります。 これを実現するには、取得する項目の最大数 (それ自体が、サービス拒否の攻撃を防ぐのに役立つ上限に依存) と、コレクションへの開始オフセットをユーザーが指定できるようにするクエリ文字列をサポートします。 URI でクエリ文字列など、 _/orders? 制限 = 25 & offset = 50_ 注文コレクションで見つかる 50 注文から始まる 25 件の注文を取得する必要があります。 データのフィルター処理と同様、Web API で GET 要求を実装する操作は、クエリ文字列の `limit` および `offset` パラメーターの解析および処理を担います。 クライアント アプリケーションを支援するには、改ページ調整されたデータを返す GET 要求に、コレクションで利用できるリソースの合計を示す何らかの形式のメタデータも含まれるようにします。 その他のインテリジェントなページング方法; も検討します。詳細については、次を参照してください [API の設計に関する注記: スマート ページング。](http://bizcoder.com/api-design-notes-smart-paging)

同様の方法で取得される時はデータの並べ替えを行うことができます。など、値としてフィールド名を取得する並べ替えパラメーターを指定することが _/orders? 並べ替え ProductID =_です。 とはいえ、この方法はキャッシュに有害な影響を与える可能性があることに注意してください (クエリ文字列パラメーターは、キャッシュされたデータのキーとして多くのキャッシュ実装により使用されるリソース識別子の一部を形成します)。

単一のリソース項目に大量のデータが含まれる場合、返されるフィールドを制限 (計画) するように、この方法を拡張できます。 などのフィールドのコンマ区切りの一覧を受け取るクエリ文字列パラメーターを使用するなど、 _/orders? フィールド = ProductID, Quantity_します。

> [AZURE.TIP] クエリ文字列内のすべての省略可能なパラメーターの意味のある既定の設定を提供します。 たとえば、改ページ調整を実装する場合は `limit` パラメーターを 10、`offset` パラメーターを 0 に設定し、順序付けを実装する場合はリソースのキーに並べ替えパラメーターを設定し、プロジェクションをサポートする場合は`fields` パラメーターをリソースのすべてのフィールドに設定します。

### 大きなバイナリ  リソースの処理

単一のリソースに、ファイルやイメージなど、大きなバイナリ フィールドが含まれている可能性があります。 信頼性が低く断続的な接続であることが原因となっている伝送の問題を克服し、応答時間を向上させるには、そのようなリソースをクライアント アプリケーションがチャンクで取得できるようにする操作を提供することを検討してください。 そのためには、Web API が大きなリソースの GET 要求で Accept-Ranges ヘッダーをサポートし、理想的にはこれらのリソースの HTTP HEAD 要求を実装するようにします。 Accept-Ranges ヘッダーは、GET 操作が一部の結果をサポートし、クライアント アプリケーションがバイト数の範囲として指定されたリソースのサブセットを返す GET 要求を送信できることを示します。 HEAD 要求は GET 要求に似ていますが、リソースおよび空のメッセージ本文を記述するヘッダーのみを返す点が異なります。 クライアント アプリケーションは HEAD 要求を発行し、部分的 GET 要求を使用して、リソースを取得するかどうかを判断します。 次の例は、製品イメージに関する情報を取得する HEAD 要求を示しています。

```HTTP
HEAD http://adventure-works.com/products/10?fields=ProductImage HTTP/1.1
...
```

応答メッセージには、リソースのサイズ  (4,580 バイト)  が含まれるヘッダー、および対応する GET 操作が部分的な結果をサポートする Accept-Ranges ヘッダーが含まれます。

```HTTP
HTTP/1.1 200 OK
...
Accept-Ranges: bytes
Content-Type: image/jpeg
Content-Length: 4580
...
```

クライアント アプリケーションはこの情報を使用して、より小さいチャンクのイメージを取得する一連の GET 要求を作成できます。 最初の要求では、Range ヘッダーを使用して最初の 2,500 バイトを取得します。

```HTTP
GET http://adventure-works.com/products/10?fields=ProductImage HTTP/1.1
Range: bytes=0-2499
...
```

応答メッセージは、HTTP 状態コード 206 を返すことで、これが部分的な応答であることを示します。 Content-Length ヘッダーはメッセージ本文で返される実際のバイト数を指定し (リソースのサイズではない)、Content-Range ヘッダーはこれがどの部分のリソースであるかを示します (4,580 のうち 0 ～ 2499 バイト): 

```HTTP
HTTP/1.1 206 Partial Content
...
Accept-Ranges: bytes
Content-Type: image/jpeg
Content-Length: 2500
Content-Range: bytes 0-2499/4580
...
_{binary data not shown}_
```

クライアント アプリケーションのその後の要求により、適切な Range ヘッダーを使用することで残りのリソースを取得できます。

```HTTP
GET http://adventure-works.com/products/10?fields=ProductImage HTTP/1.1
Range: bytes=2500-
...
```

対応する結果メッセージは、次のように表示されます。

```HTTP
HTTP/1.1 206 Partial Content
...
Accept-Ranges: bytes
Content-Type: image/jpeg
Content-Length: 2080
Content-Range: bytes 2500-4580/4580
...
```

## 関連リソースへのナビゲーションを可能にする HATEOAS アプローチの使用

REST の背後にある主な動機の 1 つは、URI スキームの事前知識を必要とせずに、リソースのセット全体を移動できることです。 各 HTTP GET 要求は応答に含まれるハイパーリンクより、要求したオブジェクトに直接関連するリソースを検索するのに必要な情報を返し、これらの各リソースで使用可能な操作を記述する情報も提供されます。 この原則は HATEOAS、つまり アプリケーション状態のエンジンとしてのハイパーテキストとして知られます。 システムは効率的に Finite State Machine であり、各要求への応答には、ある状態を別の状態に移すのに必要な情報が含まれています。他の情報は必要ありません。

> [AZURE.NOTE] 現在はありません、HATEOAS の原則をモデル化する方法を定義する標準や仕様です。 このセクションで示されている例は、可能性のある一つのソリューションを示しています。

例として、顧客と注文のリレーションシップを処理するには、特定の注文の応答で返されるデータに、注文を行った顧客を識別するハイパーリンク形式の URI、およびその顧客に対して実行できる操作 を含めます。

```HTTP
GET http://adventure-works.com/orders/3 HTTP/1.1
Accept: application/json
...
```

応答メッセージの本文に含まれる、 `Links` (コード例で強調表示されます)、関係の特性を指定する配列 (_顧客_)、顧客の URI (_http://adventure-works.com/customers/3_)、この顧客の詳細を取得する方法 (_取得_) とこの情報を取得する web サーバーをサポートする MIME の種類 (_テキスト/xml_ と _アプリケーション/json_)。 クライアント アプリケーションが顧客の詳細を取得するのに必要な情報はこれですべてです。 さらに Links アレイには、PUT (Web サーバーがクライアントに提供を期待する形式とともに顧客を変更する) や DELETE など、実行可能な他の操作のリンクも含まれます。

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
{"OrderID":3,"ProductID":2,"Quantity":4,"OrderValue":16.60,"Links":[(some links omitted){"Relationship":"customer","HRef":" http://adventure-works.com/customers/3", "Action":"GET","LinkedResourceMIMETypes":["text/xml","application/json"]},{"Relationship":"
customer","HRef":" http://adventure-works.com /customers/3", "Action":"PUT","LinkedResourceMIMETypes":["application/x-www-form-urlencoded"]},{"Relationship":"customer","HRef":" http://adventure-works.com /customers/3","Action":"DELETE","LinkedResourceMIMETypes":[]}]}
```

完全を期すために、Links アレイには取得したリソースに関する自己参照型の情報も含めるようにします。 これらのリンクは、以前の例から省略されていますが、次のコードでは強調表示されています。 これらのリンクの関係でことに注意して _self_ 操作によって返されるリソースへの参照であることを示すために使用されています。

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
{"OrderID":3,"ProductID":2,"Quantity":4,"OrderValue":16.60,"Links":[{"Relationship":"self","HRef":" http://adventure-works.com/orders/3", "Action":"GET","LinkedResourceMIMETypes":["text/xml","application/json"]},{"Relationship":" self","HRef":" http://adventure-works.com /orders/3", "Action":"PUT","LinkedResourceMIMETypes":["application/x-www-form-urlencoded"]},{"Relationship":"self","HRef":" http://adventure-works.com /orders/3", "Action":"DELETE","LinkedResourceMIMETypes":[]},{"Relationship":"customer",
"HRef":" http://adventure-works.com /customers/3", "Action":"GET","LinkedResourceMIMETypes":["text/xml","application/json"]},{"Relationship":" customer" (customer links omitted)}]}
```

この方法を効率的にするために、クライアント アプリケーションでこの追加情報を取得および解析する準備を行う必要があります。

## RESTful Web API のバージョン管理

最も単純な状況を除き、すべての状況では Web API が静的であることはほとんどありません。 ビジネスの要求は変化するため、新しいリソースのコレクションが加わり、リソース間のリレーションシップが変化し、リソース内のデータ構造が修正される可能性があります。 新しいまたは異なる要件を処理するために Web API を更新することは比較的簡単なプロセスですが、そのような変化が Web API を消費するクライアント アプリケーションに対して与える影響を考慮する必要があります。 問題なのは、Web API を設計および実装している開発者はその API を完全に制御できるものの、リモートで操作しているサードパーティの組織により構築されたクライアント アプリケーションを、その開発者が同程度には制御できないことです。 まず必要なのは、新しいクライアント アプリケーションが新しい機能やリソースを活用できるようにしながら、既存のアプリケーションに変更なく機能を続行させることです。

バージョン管理により Web API は公開する機能およびリソースを示すことができ、クライアント アプリケーションは特定のバージョンの機能またはリソースへの要求を送信できます。 次のセクションではいくつかの方法について説明しますが、それぞれに独自の利点とトレードオフがあります。

### バージョン管理なし

これは最も単純な方法で、一部の内部 API で許容されます。 大きな変更は新しいリソースまたは新しいリンクとして示されます。  既存のリソースにコンテンツを追加しても、このコンテンツの表示を想定していないクライアント アプリケーションはそれを無視するだけであるため、重大な変更はありません。

たとえば、URI に要求 _http://adventure-works.com/customers/3_ を含む単一の顧客の詳細を返す必要があります `Id`, 、`Name`, 、および `Address` クライアント アプリケーションで必要なフィールド。

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
[{"Id":3,"Name":"Contoso LLC","Address":"1 Microsoft Way Redmond WA 98053"}]
```

> [AZURE.NOTE] 簡潔でわかりやすくするためには、このセクションで示す応答の例では HATEOAS リンクは含まれません。

`DateCreated` フィールドが顧客リソースのスキーマに追加される場合、応答は次のようになります。

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
[{"Id":3,"Name":"Contoso LLC","DateCreated":"2014-09-04T12:11:38.0376089Z","Address":"1 Microsoft Way Redmond WA 98053"}]
```

既存のクライアント アプリケーションが認識されていないフィールドを無視できる場合は、正常に機能を続行する場合がありますが、新しいクライアント アプリケーションではこの新しいフィールドを処理するように設計できます。 とはいえ、リソースのスキーマにさらに重大な変更があるか (フィールドの削除や名前の変更など)、リソース間のリレーションシップが変更される場合、これらは既存のクライアント アプリケーションが正常に機能できなくなる重大な変更となる可能性があります。 このような状況では、次の方法のいずれかを検討してください。

### URI のバージョン管理

Web API を変更するか、リソースのスキーマを変更するたびに、バージョン番号を各リソースの URI に追加します。 既存の URI はこれまでと同様に動作を続け、元のスキーマに準拠するリソースを返します。

ある場合は、前の例を拡張、 `Address` フィールドは、アドレスの各構成部分を含むサブフィールドに再編成 (など `StreetAddress`, 、`City`, 、`State`, 、および `ZipCode`)、このバージョンのリソースを http://adventure-works.com/v2/customers/3 などのバージョン番号を含む URI より公開できます。

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
[{"Id":3,"Name":"Contoso LLC","DateCreated":"2014-09-04T12:11:38.0376089Z","Address":{"StreetAddress":"1 Microsoft Way","City":"Redmond","State":"WA","ZipCode":98053}}]
```

このバージョン管理メカニズムは非常に単純ですが、適切なエンドポイントに要求をルーティングするサーバーにより変わります。 とはいえ、Web API は何度も繰り返すことで成熟し、サーバーは多くの異なるバージョンをサポートする必要があるため、扱いにくくなる可能性があります。 また、純正主義者の観点からすると、すべての場合でクライアント アプリケーションは同じデータを取得しているため (顧客 3)、URI はバージョンによってそれほど異なるべきではありません。 すべてのリンクで URI にバージョン番号が含まれる必要があるため、このスキームによっても HATEOAS の実装が複雑になります。

### クエリ文字列のバージョン管理

複数の Uri を提供するのではなくなどの HTTP 要求に追加されたクエリ文字列内のパラメーターを使用してリソースのバージョンを指定することができます _http://adventure-works.com/customers/3?version=2_します。 バージョン パラメーターがより古いクライアント アプリケーションで省略される場合、1 などの有効な値を既定にします。

この方法には同じリソースからは常に同じ URI が取得されるというセマンティックな利点がありますが、クエリ文字列を解析し、適切な HTTP 応答を返送する要求を処理するコードにより異なります。 この方法は、URI のバージョン管理メカニズムとして HATEOAS を実装する同様の複雑さによっても影響されます。

> [AZURE.NOTE] 一部の古い web ブラウザーおよび web プロキシは、クエリ文字列を URL に含める要求に対する応答をキャッシュしません。 これは、Web API を使用し、そのような Web ブラウザー内から実行する Web アプリケーションのパフォーマンスに悪影響を与える可能性があります。

### ヘッダーのバージョン管理

バージョン番号をクエリ文字列パラメーターとして追加するのではなく、リソースのバージョンを示すカスタム ヘッダーを実装できます。 この方法ではクライアント アプリケーションにより任意の要求に適切なヘッダーを追加する必要がありますが、バージョン ヘッダーが省略されている場合、クライアントの要求を処理するコードは既定値 (バージョン 1) を使用できます。 次の例では、名前付きカスタム ヘッダーを使用する _Custom-header_します。 このヘッダーの値は、Web API のバージョンを示します。

バージョン 1: 

```HTTP
GET http://adventure-works.com/customers/3 HTTP/1.1
...
Custom-Header: api-version=1
...
```

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
[{"Id":3,"Name":"Contoso LLC","Address":"1 Microsoft Way Redmond WA 98053"}]
```

バージョン 2: 

```HTTP
GET http://adventure-works.com/customers/3 HTTP/1.1
...
Custom-Header: api-version=2
...
```

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
[{"Id":3,"Name":"Contoso LLC","DateCreated":"2014-09-04T12:11:38.0376089Z","Address":{"StreetAddress":"1 Microsoft Way","City":"Redmond","State":"WA","ZipCode":98053}}]
```

前の 2 つの方法と同様、HATEOAS の実装では任意のリンクに適切なカスタム ヘッダーを追加することが必要です。

### メディアの種類のバージョン管理

クライアント アプリケーションが Web サーバーに HTTP GET 要求を送信する場合、このガイダンスで既に説明したように、Accept ヘッダーを使用して処理できるコンテンツの書式を指定する必要があります。 目的では多くの場合、 _Accept_ ヘッダーは、応答の本文が XML、JSON、またはクライアントが解析可能なその他の一般的な形式にするかどうかを指定するクライアント アプリケーションを許可するようにします。 とはいえ、想定しているリソースのバージョンをクライアント アプリケーションが示すことができるようにする情報を含むカスタム メディアの種類を定義できます。 次の例では、指定する要求、 _Accept_ 、値を持つヘッダー _application/vnd.adventure-works.v1+json_します。  _指示します works.v1_ 、リソースのバージョン 1 を返すように、web サーバーに要素を示します中に、 _json_ 要素は応答本文の形式が JSON であることを指定します。

```HTTP
GET http://adventure-works.com/customers/3 HTTP/1.1
...
Accept: application/vnd.adventure-works.v1+json
...
```

要求を処理しているコードは、処理を担当する、 _Accept_ ヘッダーをできる限り (クライアント アプリケーションで複数の書式指定、 _Accept_ ヘッダー、その場合 web サーバーが応答本文の最も適切な形式を選択できます)。 Web サーバーは次のように Content-Type ヘッダーを使用することで、応答本文のデータの形式を確認します。

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/vnd.adventure-works.v1+json; charset=utf-8
...
Content-Length: ...
[{"Id":3,"Name":"Contoso LLC","Address":"1 Microsoft Way Redmond WA 98053"}]
```

Accept ヘッダーにより既知のメディアの種類が指定されない場合、Web サーバーは HTTP 406 (Not Acceptable) 応答メッセージを生成するか、既定のメディアの種類でメッセージを返すことができます。

この方法が最も純粋と思われるバージョン管理メカニズムで、当然ながら HATEOAS で役立ち、リソース リンクの関連データの MIME の種類を含めることができます。

> [AZURE.NOTE] バージョン化戦略を選択すると web サーバーでのキャッシュに特にのパフォーマンスに関する影響についてもを考慮する必要があります。 同じ URI/クエリ文字列の組み合わせは同じデータを毎回参照するため、URI バージョン管理および Query String バージョン管理スキームはキャッシュに適しています。

> 通常、Header バージョン管理および Media Type バージョン管理メカニズムでは、カスタム ヘッダーまたは Accept ヘッダーの値を確認するのに追加のロジックが必要です。 大規模な環境では、多くのクライアントで異なるバージョンの Web API が使用されているため、サーバー側のキャッシュの重複データ量が著しく増加します。 この問題が深刻になるのは、クライアント アプリケーションがキャッシュを実装するプロキシを経由して Web サーバーと通信する場合です。また、キャッシュに要求されたデータのコピーが現在保持されていない場合は Web サーバーに要求の転送のみ行います。

## 詳細情報

-  [RESTful Cookbook](http://restcookbook.com/) RESTful Api の構築の概要について説明します。
- Web [API Checklist](https://mathieu.fenniak.net/the-api-checklist/) 役立つ設計、および Web API を実装するときに考慮すべき項目の一覧が含まれています。

