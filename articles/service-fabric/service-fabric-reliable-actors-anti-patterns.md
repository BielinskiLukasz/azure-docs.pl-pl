<properties
   pageTitle="いくつかの Azure Service Fabric アクターのアンチパターン"
   description="Azure Service Fabric アクターを学習しているお客様が陥りやすいいくつかの問題点"
   services="service-fabric"
   documentationCenter=".net"
   authors="vturecek"
   manager="timlt"
   editor=""/>

<tags
   ms.service="service-fabric"
   ms.devlang="dotnet"
   ms.topic="article"
   ms.tgt_pltfrm="NA"
   ms.workload="NA"
   ms.date="08/11/2015"
   ms.author="vturecek"/>

# 高信頼アクターの設計パターン: いくつかアンチ パターン

Service Fabric 高信頼アクターを学習しているお客様が陥りやすい問題点を次に示します。

* 高信頼アクターをトランザクション システムとして扱う。 Service Fabric 高信頼アクターは、ACID を提供する 2 フェーズのコミット ベース システムではありません。 オプションの永続化を実装せず、アクターが実行されているマシンが強制終了された場合、その現在の状態も共に失われます。 アクターは非常に迅速に別のノードに切り替わりますが、永続化のサポートを実装していない限り、その状態は失われます。 ただし、再試行、重複フィルター処理、およびべき等設計を活用する間に、高レベルの信頼性と一貫性を実現できます。

* ブロック。 高信頼アクターで実行するすべての操作は、非同期である必要があります。 現在、Microsoft プラットフォームでは非同期 API が豊富に提供されているため、このような操作は通常は簡単です。 ただし、何らかの理由で、ブロッキング API のみを提供するシステムと対話する必要がある場合は、.NET スレッド プールを明示的に使用するラッパー内にこのシステムを配置する必要があります。

* 過剰なアーキテクト。 環境を活用してください。 同時の収集やロックについて心配したり、ツールを使用して XML からオブジェクトをコンパイルしたりすることに慣れている開発者にとって、変数への値の割り当てや作業のスケジュール設定など、単純な操作を行うクラスを単にコーディングすることには抵抗があるかもしれません。 スケジュールされたタスクが既に組み込まれています。 ロックは必要はありません。 状態は重要な問題とはなりません。 大規模な環境でサーバー側の作業を多量に行ってきた多くのユーザーにとっては、多少の慣れが必要です。

* 単一のアクターをボトルネックにする。 数百万ものアクターを別のアクターの単一のインスタンスに集中させることで、このような状況に陥りがちです。 示した集計アプローチを使用して、 [分散計算のデザイン パターン](service-fabric-reliable-actors-pattern-distributed-computation.md)します。

* エンティティ モデルを無条件にマップする。 これは、エンティティとそのリレーションシップを使用して問題がモデル化されるリレーショナル環境にいた開発者が陥りやすい問題点です。 このアプローチは、サブジェクト ドメインを理解するために今なお役立ちますが、サービス指向の考え方と組み合わせ、動作と調和させる必要があります。

