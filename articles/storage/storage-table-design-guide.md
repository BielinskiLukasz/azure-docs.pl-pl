<properties
   pageTitle="Azure ストレージ テーブル設計ガイド | Microsoft Azure"
   description="Azure テーブル ストレージでスケーラビリティとパフォーマンスに優れたテーブルを設計する"
   services="storage"
   documentationCenter="na"
   authors="jasonnewyork" 
   manager="tadb"
   editor=""/>

<tags
   ms.service="storage"
   ms.devlang="na"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="storage"
   ms.date="12/03/2015"
   ms.author="jahogg"/>

# Azure ストレージ テーブルの設計ガイド: スケーラブルな設計とハイパフォーマンスなテーブル

## 概要

スケーラビリティとパフォーマンスに優れたテーブルを設計するにあたっては、さまざまな事柄を考慮する必要があります。具体的にはパフォーマンス、スケーラビリティ、コストなどですが、 過去にリレーショナル データベースのスキーマを設計した経験がある方なら、こうした考慮事項はご存じであると思われます。しかし、Azure Table サービス ストレージ モデルとリレーショナル モデルには類似の要素が多いとはいえ、重要な違いが多数あるのも事実です。 こうした相違点は、リレーショナル データベースの扱いに慣れた方には直感的にわかりづらかったり、扱いづらかったりする設計につながりがちですが、Azure Table サービスなどの NoSQL キー/値ストアを設計する場合には好都合です。 設計の相違点の多くは、Table  サービスが何十億ものデータ エンティティ (リレーショナル データベース用語では行) を含むクラウド アプリケーションをサポートするためのデータや、大量のデータトランザクションをサポートするよう設計されている 点を考慮します。そのため、データの格納方法や Table サービスの動作方法について違った考え方が必要になります。 NoSQL データ ストアを適切に設計すれば、リレーショナル データベースを使うソリューションよりも、ソリューションのスケーラビリティが大幅に高まり、コストも抑えられます。 このガイドでは、これらのトピックについて説明します。  

## Azure テーブル サービス

このセクションでは、パフォーマンスとスケーラビリティを重視した設計に関連する Table サービスの主要機能を取り上げます。 最初に読んだ Azure Storage と Table サービスに慣れていない場合 [Microsoft Azure Storage の概要](storage-introduction.md) と [.NET からテーブル ストレージを使用する方法](storage-dotnet-how-to-use-tables.md) この記事の残りの部分を読み取る前にします。 このガイドで主に取り上げるのは Table サービスについてですが、Azure のキューや BLOB サービスと、それらのサービスをソリューションで Table サービスと共に使用する方法についても触れます。  

Table サービスとは 名前が示すとおり、Table サービスではデータの格納にテーブル形式を使います。 標準的な定義では、テーブルの各行はエンティティを表し、そのエンティティの各種プロパティは列に格納されます。 各エンティティは、それ自体を一意に識別するためのキーのペアと、Table サービスがエンティティの最終更新日時をトラッキングするためのタイムスタンプ列を持ちます (エンティティの更新は自動的に行われます。タイムスタンプを任意の値を使って手動で上書きすることはできません)。 Table サービスでは、この最終更新日時のタイムスタンプ (LMT) を使ってオプティミスティック同時実行を管理します。  

>[AZURE.NOTE] Table サービス REST API 操作を返すことも、 **ETag** 最終更新タイムスタンプ (LMT) から派生する値。 このドキュメントでは、ETag と LMT という用語を区別なく使います。基となる同じデータを表しているためです。  

次の例は、従業員と部署のエンティティを格納する、シンプルなテーブル設計を示しています。 このガイドで紹介する例の多くは、このシンプルな設計が基になっています。  

<table>
<tr>
<th>PartitionKey</th>
<th>RowKey</th>
<th>タイムスタンプ</th>
<th></th>
</tr>
<tr>
<td>Marketing</td>
<td>00001</td>
<td>2014-08-22T00:50:32Z</td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>電子メール</th>
</tr>
<tr>
<td>Don</td>
<td>Hall</td>
<td>34</td>
<td>donh@contoso.com</td>
</tr>
</table>
</tr>
<tr>
<td>Marketing</td>
<td>00002</td>
<td>2014-08-22T00:50:34Z</td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>電子メール</th>
</tr>
<tr>
<td>Jun</td>
<td>Cao</td>
<td>47</td>
<td>junc@contoso.com</td>
</tr>
</table>
</tr>
<tr>
<td>Marketing</td>
<td>学科</td>
<td>2014-08-22T00:50:30Z</td>
<td>
<table>
<tr>
<th>DepartmentName</th>
<th>EmployeeCount</th>
</tr>
<tr>
<td>Marketing</td>
<td>153</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>Sales</td>
<td>00010</td>
<td>2014-08-22T00:50:44Z</td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>電子メール</th>
</tr>
<tr>
<td>Ken</td>
<td>Kwok</td>
<td>23</td>
<td>kenk@contoso.com</td>
</tr>
</table>
</td>
</tr>
</table>


今のところ、リレーショナル データベースのテーブルと非常によく似ており、異なるキーが必須の列となっていて、同じテーブルに複数の種類のエンティティを格納できます。 さらなどのユーザー定義プロパティの各 **FirstName** または **年齢** リレーショナル データベース内の列のように、整数や文字列だけなど、データ型があります。 ただし、リレーショナル データベースとは違って、Table サービスにはスキーマがないため、エンティティごとにプロパティのデータ型は同じである必要ありません。 1 つのプロパティに複雑なデータ型を格納するには、JSON や XML などのシリアル化された形式を使う必要があります。 テーブルなど、サポートされているサービスのデータ型、日付の範囲、名付け規則、およびサイズの制限の詳細については、次を参照してください。 [テーブル サービス データ モデルについて](http://msdn.microsoft.com/library/azure/dd179338.aspx) MSDN にします。

確認するため、好みの **PartitionKey** と **RowKey** は優れたテーブル設計の基盤です。 テーブルに格納されているすべてのエンティティの一意の組み合わせを持つ必要があります **PartitionKey** と **RowKey**します。 リレーショナル データベース テーブル内のキーと同様、 **PartitionKey** と **RowKey** 値が高速ルックアップをできるようにするクラスター化インデックスを作成するインデックスが作成で、テーブル サービスは作成できず任意のセカンダリ インデックスが 2 つのインデックス付きプロパティ (後で説明したパターンの一部を表示するこの明確な制限を回避することができますできる方法)。  

テーブルが 1 つまたは複数のパーティションの構成し、適切な選択を確認するために決定したデザインの多くなります **PartitionKey** と **RowKey** ソリューションを最適化するためにします。 ソリューションによっては、すべてのエンティティがパーティションを使って整理された 1 つのテーブルだけで構成されるものもありますが、通常は複数のテーブルが含まれます。 テーブルを使えばエンティティを論理的に整理できるほか、アクセス制御リストを使ってデータへのアクセスを管理できます。また、1 回のストレージ操作でテーブル全体を削除できます。  

### テーブルのパーティション  
アカウント名、テーブル名と **PartitionKey** 組み合わせ、テーブル サービスがエンティティを格納するストレージ サービス内のパーティションを識別します。 パーティションをエンティティのアドレス指定スキームの一部であると同時には、トランザクションのスコープを定義し (を参照してください [エンティティ グループ トランザクション](#entity-group-transactions) の下)、テーブル サービスのスケーリングの基礎となります。 パーティションの詳細については、次を参照してください。 [Azure ストレージのスケーラビリティおよびパフォーマンスのターゲット](http://msdn.microsoft.com/library/azure/dn249410.aspx)します。  

Table サービスでは、個々のノードが 1 つ以上の完全なパーティションを提供し、サービスのスケーリングはノード間でパーティションの負荷を動的に分散させることで行われます。 ノードは、負荷の下では、テーブル サービスが *分割* を別のノードには、そのノードによって処理されたパーティションの範囲は、トラフィックが収まると、サービスのことが可能 *マージ* パーティション範囲をクワイエット ノードからは、1 つのノードに戻します。  

詳細については、内部的な詳細と特定のテーブル サービスのサービスでは、パーティションを管理、方法を参照してください、ホワイト ペーパー [Microsoft Azure Storage: A を高可用性
クラウド ストレージ サービスを強力な一貫性](http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx)します。  

### エンティティ グループ トランザクション
エンティティ グループ トランザクション (EGT) は、Table サービスで複数のエンティティ間でアトミックな更新を行うための唯一の組み込みのメカニズムです。 Egt とも呼ばれる *バッチ トランザクション* 一部のドキュメントでします。 EGT では、同じパーティションに格納されたエンティティしか処理できないため (特定のテーブルで同じパーティション キーを共有)、複数のエンティティにまたがるアトミックなトランザクションが必要な場合は、それらのエンティティを同じパーティションに格納する必要があります。 これが、異なる種類のエンティティに複数のテーブルを使わずに、異なる種類のエンティティを同じテーブル (とパーティション) に格納する主な理由です。 単一の EGT で最大 100 個のエンティティを処理できます。  複数並行処理 Egt を送信する場合、それら Egt は、それ以外の場合の処理を遅延できますとして Egt 間の共通であるエンティティに対しては動作せずを確認する必要があります。

EGT により、設計で評価が必要なトレードオフが生じる可能性もあります。使用するパーティションが増えると、ノード間で要求を負荷分散しやすくなるため、アプリケーションのスケーラビリティが向上するものの、アプリケーションでアトミックなトランザクションを実行し、データの強力な一貫性を維持する力が限られるおそれがあります。 さらに、固有のスケーラビリティ ターゲットにある 1 つのノードを期待できるトランザクションのスループットを制限するパーティションのレベル: Azure ストレージ アカウントと table サービスのスケーラビリティ ターゲットに関する詳細については、次を参照してください。 [Azure ストレージのスケーラビリティおよびパフォーマンスのターゲット](http://msdn.microsoft.com/library/azure/dd179338.aspx) MSDN にします。 このガイドの後のセクションでは、このようなトレードオフを管理しやすくするさまざまな設計戦略を紹介すると共に、クライアント アプリケーションの固有の要件に基づいてパーティション キーを選択する最適な方法についても説明します。  

### 容量に関する考慮事項
次の表に、Table サービス ソリューションの設計時に考慮する必要のある主要な値をまとめます。  

|Azure ストレージ アカウントの合計容量|500 TB|
|------------------------------------------|------|
|Azure のストレージ アカウントのテーブルの数 | ストレージ アカウントの容量のみによる制限 |
|テーブルのパーティションの数 | ストレージ アカウントの容量のみによる制限 |
|パーティション内のエンティティの数 | ストレージ アカウントの容量のみによる制限|
|個別のエンティティのサイズ | 最大 1 MB、最大で 255 個のプロパティ (を含め、 **PartitionKey**, 、**RowKey**, 、および **タイムスタンプ**) |
|サイズ、 **PartitionKey** | 最大 1 KB の文字列 |
| サイズ、 **RowKey** | 最大 1 KB の文字列 |
|エンティティ グループ トランザクションのサイズ | トランザクションには最大で 100 個のエンティティを含めることができ、ペイロードは 4 MB 未満にする必要があります。 EGT では 1 回に 1 つのエンティティしか更新できません。 |

詳細については、次を参照してください。 [テーブル サービス データ モデルについて](http://msdn.microsoft.com/library/azure/dd179338.aspx) MSDN にします。  

### コストに関する考慮事項  
テーブル ストレージは比較的安価ですが、テーブル ストレージを使うソリューションの評価の一環として、容量の使用とトランザクションの量を踏まえてコストを見積もる必要があります。 ただし、多くのシナリオでは、ソリューションのパフォーマンスとスケーラビリティを向上させるために、非正規化されたデータまたは重複するデータを格納するのも有効です。 料金の詳細については、次を参照してください。 [ストレージの料金詳細](http://azure.microsoft.com/pricing/details/storage/)します。  

### Azure テーブルと SQL Azure の比較  
Azure SQL Database (リレーショナル データベース サービス) と Table サービスの間で比較では、次を参照してください。 [Microsoft Azure テーブル ストレージと Microsoft Azure SQL データベース - 比較](http://msdn.microsoft.com/library/azure/jj553018.aspx) MSDN にします。  

## テーブル設計のガイドライン  
これらのリストにはテーブルを設計する際の主要なガイドラインがまとめられており、これらガイドは後ほど詳細にテーブルへの対処方法を説明します。 これらのガイドラインは、リレーショナル データベースの設計のために通常参照するガイドラインと、非常に異なります。  

テーブル サービスのソリューションを設計 *読み取り* 効率。

-   ***読み取りが多いアプリケーションでクエリを実行するための設計です。***テーブルを設計するときは、エンティティの更新方法について考える前に、実行するクエリ (特に、待機時間に影響を受けやすいもの) を検討してください。 これは通常、効率的でパフォーマンスの高いソリューションになります。  
-   ***クエリで PartitionKey と RowKey の両方を指定します。****ポイント クエリ* これらは、最も効率的な table サービスのクエリなどです。  
-   ***エンティティの重複コピーを格納することを検討してください。***テーブル ストレージは安価であるため、クエリの効率を上げるため、(異なるキーを持つ) 同じエンティティを複数回格納することをご検討ください。  
-   ***データを非正規化を検討してください。***テーブル ストレージは安価であるため、データの非正規化を検討してください。 たとえば、概要エンティティを格納すると、統計データ用クエリは単一のエンティティにアクセスするだけで済みます。  
-   ***複合キーの値を使用します。***ある唯一のキーが **PartitionKey** と **RowKey**します。 たとえば、複合キーの値を使用してエンティティへの代替キー付きアクセス パスを有効にします。  
-   ***クエリ プロジェクションを使用します。***必要なフィールドだけを選択するクエリを使用して、ネットワーク経由で転送するデータ量を削減できます。  

テーブル サービスのソリューションを設計 *書き込み* 効率。  

-   ***ホット パーティションは作成されません。***任意の時点で、複数のパーティションで要求を分散できるキーを選択します。  
-   ***トラフィックの急増を回避します。***適切な期間でトラフィックの流れをスムーズにし、トラフィックの急増を回避します。
-   ***エンティティの種類ごとに個別のテーブルを作成とは限りませんしないでください。***複数のエンティティ種類でアトミック トランザクションが必要なときに、同じテーブル内の同じパーティションにこれら複数のエンティティ種類を格納できます。
-   ***最大のスループットを実現する必要を検討してください。***テーブル サービスのスケーラビリティ ターゲットを確認し、それを超えない設計にする必要があります。  

このガイドでは、これらの原則を実装した例を紹介します。  

## クエリに対応した設計  
Table サービス ソリューションでは、読み取り、書き込み、またはその両方の負荷が高くなることがあります。 このセクションでは、読み取り操作を効率的に行える Table サービスを設計する際に注意する必要のある事柄を中心に取り上げます。 通常は、読み取り操作を効率的にサポートする設計は、書き込み操作についても効率が高くなります。 ただし、書き込み操作をサポートするために設計する際に留意する追加の考慮事項がありますが、次のセクションでは、 [データ変更のためのデザイン](#design-for-data-modification), 、について説明します。

データを効率的に読み取ることのできる Table サービス ソリューションを設計する際には、まず "必要なデータを Table サービスから取得するには、アプリケーションでどのようなクエリを実行する必要があるか" を考えてみてください。  

>[AZURE.NOTE] テーブル サービスでは、好みのデザイン正しい前もって困難であり、後で変更にコストのかからないとなっている必要があります。 たとえば、リレーショナル データベースなら、既存のデータベースにインデックスを追加するだけでパフォーマンスの問題に対処できることが多いものの、Table サービスではそうはいきません。  

このセクションでは、クエリに対応したテーブルを設計する際に対処する必要のある主要な問題を中心に取り上げます。 このセクションで取り上げるトピックは次のとおりです。

- [PartitionKey と RowKey の選択がクエリのパフォーマンスに与える影響](#how-your-choice-of-partitionkey-and-rowkey-impacts-query-performance)
- [適切な PartitionKey を選ぶ](#choosing-an-appropriate-partitionkey)
- [Table サービスのキー値ストアによるクエリの最適化](#optimizing-queries-with-a-key-value-store-for-the-table-service)
- [Table サービスのキー値ストアでデータを並べ替える](#sorting-data-in-a-key-value-store-in-the-table-service)

### PartitionKey と RowKey の選択がクエリのパフォーマンスに与える影響  

次の例では、テーブル サービスが、次の構造を持つ従業員エンティティを格納する前提としています (例のほとんどを省略、 **タイムスタンプ** わかりやすくするためのプロパティ)。  

|*列名* |*データ型*|
|--------------|-----------|
|**PartitionKey** (部門名)|String|
|**RowKey** (従業員 Id)|String|
|**FirstName**|String|
|**LastName**|String|
|**Age**|Integer|
|**EmailAddress**|String|

前のセクション [Azure Table サービスの概要](#azure-table-service-overview) クエリの設計に直接影響を与える Azure Table サービスの主な機能の一部について説明します。 ここから、Table サービスのクエリを設計する際には、次のような一般的なガイドラインが考えられます。 詳細については「Table サービス REST API ものは、次の例で使用されるフィルター構文 [Query Entities](http://msdn.microsoft.com/library/azure/dd179421.aspx) MSDN にします。  

-   A ***ポイント クエリ*** を使用する最も効率的な検索は、大量のルックアップや最も短い待機時間が求められる参照に使用することをお勧めします。 このようなクエリが両方を指定することによって、個々 のエンティティを非常に効率よく検索する、インデックスを使用して、 **PartitionKey** と **RowKey** 値。 次に例を示します。
$filter=(PartitionKey eq 'Sales') and (RowKey eq '2')  
-   2 番目に良い方法は、 ***範囲クエリ*** を使用して、 **PartitionKey** およびフィルターの範囲に **RowKey** 値を 1 つ以上のエンティティを返します。  **PartitionKey** 値は、特定のパーティションを識別し、 **RowKey** 値は、そのパーティション内のエンティティのサブセットを識別します。 次に例を示します。
$filter=PartitionKey eq 'Sales' and RowKey ge 'S' and RowKey lt 'T'  
-   3 番目に良い方法は、 ***パーティション スキャン*** を使用して、 **PartitionKey** と他の非キー プロパティのフィルターは、複数のエンティティを返すことができます。  **PartitionKey** 値は、特定のパーティションを識別し、プロパティ値はそのパーティション内のエンティティのサブセットを選択します。 次に例を示します。
$filter=PartitionKey eq 'Sales' and LastName eq 'Smith'  
-   A ***Table Scan*** を含まない、 **PartitionKey** とは、さらに、一致するエンティティのテーブルを構成するパーティションのすべてを検索するため、非常に効率的です。 フィルターを使用するかどうかに関係なくテーブル スキャンが実行されます、 **RowKey**します。 次に例を示します。
$filter=LastName eq 'Jones'  
-   複数のエンティティを返すクエリで並べ替えて返します **PartitionKey** と **RowKey** 順序です。 クライアントでエンティティを選択した手段をとるように、 **RowKey** 最も一般的な並べ替え順序を定義します。  

使用して、"**または**"に基づくフィルターを指定する **RowKey** パーティション スキャンの結果を値であり、範囲クエリとして扱われません。 そのため、
$filter=PartitionKey eq 'Sales' and (RowKey eq '121' or RowKey eq '322') のようなフィルターを使うクエリは避けてください。  

ストレージ クライアント ライブラリを使って効率的なクエリを実行するクライアント側コードの例については、  

-   [ストレージ クライアント ライブラリを使って 1 つのエンティティを取得する](#retrieving-a-single-entity-using-the-storage-client-library)
-   [LINQ を使って複数のエンティティを取得する](#retrieving-multiple-entities-using-linq)
-   [サーバー側のプロジェクション](#server-side-projection)  

同じテーブルに格納された複数の種類のエンティティを処理できるクライアント側コードの例については、  

-   [異なる種類のエンティティを操作する](#working-with-heterogeneous-entity-types)  

### 適切な PartitionKey を選ぶ  

好みの **PartitionKey** バランスを取る必要があります (スケーラブルなソリューションを) の複数のパーティションでエンティティを配布する要件に対し (一貫性を保つため) Egt の使用を有効にする必要があります。  

すべてのエンティティを 1 つのパーティションに格納することも可能ですが、そうするとソリューションのスケーラビリティが制限され、Table サービスで要求を負荷分散できなくなる可能性があります。 逆に、パーティションごとに 1 つのエンティティを格納することもできます。このようにすると、スケーラビリティが高まり、Table サービスで要求を負荷分散できるようになるものの、エンティティ グループ トランザクションは使用できなくなります。  

理想的な **PartitionKey** 効率的なクエリを使用することができ、ソリューションのスケーラビリティを確保できるパーティションのある 1 つです。 通常、エンティティには、十分な数のパーティションにエンティティを分散できるだけのプロパティがあります。

>[AZURE.NOTE] たとえば、ユーザーまたは従業員に関する情報を格納するシステムでユーザー Id があります適切な PartitionKey。 パーティション分割キーとして所定の UserID を使用する複数のエンティティを使用できます。 あるユーザーに関するデータを保存するそれぞれのエンティティは 1 つのパーティションにグループ化されるため、高い拡張性を確保しながら、エンティティ グループ トランザクションを介してこれらのエンティティにアクセスできます。

選択した追加の検討事項がある **PartitionKey** 方法を挿入、更新、およびエンティティの削除に関連した: セクションを参照して [データ変更のためのデザイン](#design-for-data-modification) 下です。  

### クエリを Table サービス向けに最適化する  

自動的にインデックスを使用してエンティティがテーブル サービス、 **PartitionKey** と **RowKey** 1 つのクラスター化インデックス内の値、そのためポイント クエリが最も効率的なを使用します。 ただし、それ以外のクラスター化インデックスのインデックスのにない、 **PartitionKey** と **RowKey**します。

多くの設計は、複数の条件に基づいてエンティティをルックアップできるようにするという要件を満たす必要があります。 たとえば、電子メール、従業員 ID、姓に基づいて従業員エンティティを特定する場合などです。 セクションの次のパターン [テーブルの設計パターン](#table-design-patterns) これらの要件の種類に対応し、Table サービスがセカンダリ インデックスを提供していないことを回避する方法について説明します。  

-   [パーティション内セカンダリ インデックス パターン](#intra-partition-secondary-index-pattern) -異なるを使用して各エンティティの複数コピーを格納 **RowKey** 値 (同じパーティション内) を有効にする高速で効率的な検証と代替の並べ替え順序を使用して異なる **RowKey** 値。  
-   [パーティション内セカンダリ インデックス パターン](#inter-partition-secondary-index-pattern) - を可能に別個のパーティションまたは別のテーブルに異なる RowKey 値を使用して各エンティティの複数のコピーを格納して、効率的な検証と代替の並べ替え順序が異なるを使用して順序 **RowKey** 値。  
-   [インデックス エンティティ パターン](#index-entities-pattern) -をエンティティの一覧を返す、効率的な検索を有効にするインデックス エンティティを保持します。  

### Table サービスでデータを並べ替える  

テーブル サービスに基づいた昇順で並べ替え、エンティティを返す **PartitionKey** 次 **RowKey**します。 これらのキーは文字列値であり、数値を正しく並べ替えるには、固定長の値に変換し、ゼロ パディングを施す必要があります。 たとえば、従業員 id の値として使用する場合、 **RowKey** 、整数値では、従業員 id に変換する必要があります **123** に **00000123**します。  

さまざまな順序 (名前、入社日など) で並べ替えられたデータを使う必要のあるアプリケーションは多数あります。 セクションの次のパターン [テーブルの設計パターン](#table-design-patterns) エンティティの並べ替え順序を代替する方法について説明します。  

-   [パーティション内セカンダリ インデックス パターン](#intra-partition-secondary-index-pattern) - 高速に有効にする (同じパーティション) 内の異なる RowKey 値を使用して各エンティティの複数のコピーを格納して、異なる RowKey 値を使用して効率的な検証と代替の並べ替え順序です。  
-   [パーティション内セカンダリ インデックス パターン](#inter-partition-secondary-index-pattern) - を可能に個別のテーブルの別個のパーティションの異なる RowKey 値を使用して各エンティティの複数のコピーを格納して、異なる RowKey 値を使用して効率的な検証と代替の並べ替え順序です。
-   [ログ テール パターン](#log-tail-pattern) の取得、 *n* を使用してパーティションに最も最近追加された、 **RowKey** 逆の日付と時間順でソートする値。  

## データの変更に対応した設計
このセクションでは、挿入、更新、削除の操作を最適化するための設計上の考慮事項を示します。 場合によっては、リレーショナル データベースの設計と同様に、クエリ向けの最適化とデータ変更向けの最適化のトレードオフを評価する必要があります (設計のトレードオフを管理する手法はリレーショナル データベースでは異なります)。 セクションでは、 [テーブルの設計パターン](#table-design-patterns) テーブル サービスの詳細な設計パターンをいくつか説明し、これらのトレードオフに注目します。 実際のところ、クエリ向けに最適化された設計の多くは、エントリの変更にも適していることがおわかりになると思います。  

### 挿入、更新、削除の操作のパフォーマンスを最適化する  

更新またはエンティティを削除する、する必要がありますを使用して識別するために、 **PartitionKey** と **RowKey** 値。 この点で、選択した **PartitionKey** と **RowKey** のエンティティを変更するのような条件をできるだけ効率的にエンティティを識別するために、ポイント クエリをサポートするために選択に従う必要があります。 検出のために、エンティティを検索する非効率的なパーティションまたはテーブル スキャンを使用したくない、 **PartitionKey** と **RowKey** 値が更新または削除する必要があります。  

セクションの次のパターン [テーブルの設計パターン](#table-design-patterns) パフォーマンスや挿入、更新、最適化に対処し、削除操作。  

-   [大量削除パターン](#high-volume-delete-pattern) の独立したテーブルを同時削除用のすべてのエンティティを格納することによって大量のエンティティの削除を有効にするには、テーブルを削除して、エンティティを削除します。  
-   [データ系列パターン](#data-series-pattern) -要求の数を最小限に抑えるには 1 つのエンティティで完全なデータ系列を格納します。  
-   [ワイド エンティティ パターン](#wide-entities-pattern) -複数の物理エンティティを使用して、252 を超えるプロパティを持つ論理エンティティを格納します。  
-   [大型エンティティ パターン](#large-entities-pattern) -大きなプロパティ値を格納する blob ストレージを使用します。  

### 格納されたエンティティの一貫性を確保する  

データの変更を最適化するためのキーの選択を左右する要因として、アトミックなトランザクションを使って一貫性を確保する方法も挙げられます。 同じパーティションに格納されたエンティティを操作する場合は、EGT を使用します。  

セクションの次のパターン [テーブルの設計パターン](#table-design-patterns) 整合性の管理を説明します。  

-   [パーティション内セカンダリ インデックス パターン](#intra-partition-secondary-index-pattern) -異なるを使用して各エンティティの複数コピーを格納 **RowKey** 値 (同じパーティション内) を有効にする高速で効率的な検証と代替の並べ替え順序を使用して異なる **RowKey** 値。  
-   [パーティション内セカンダリ インデックス パターン](#inter-partition-secondary-index-pattern) - を可能に別個のパーティションまたは別のテーブルに異なる RowKey 値を使用して各エンティティの複数のコピーを格納して、効率的な検証と代替の並べ替え順序が異なるを使用して順序 **RowKey** 値。  
-   [最終的に一貫性のあるトランザクション パターン](#eventually-consistent-transactions-pattern) -Azure キューを使用してパーティションの境界または記憶域システムの境界を越えて最終的に一貫性のある動作を実現します。
-   [インデックス エンティティ パターン](#index-entities-pattern) -をエンティティの一覧を返す、効率的な検索を有効にするインデックス エンティティを保持します。  
-   [非正規化パターン](#denormalization-pattern) -関連する結合データ、1 つのポイント クエリで必要なすべてのデータを取得するために 1 つのエンティティです。  
-   [データ系列パターン](#data-series-pattern) -要求の数を最小限に抑えるには 1 つのエンティティで完全なデータ系列を格納します。  

エンティティ グループ トランザクションについては、セクションを参照してください。 [エンティティ グループ トランザクション](#entity-group-transactions)します。  

### 効率的な変更に対応した設計によるクエリの効率化  

効率的なクエリに適した設計は変更の効率も高いのが普通ですが、自分のシナリオにもそれが当てはまるかどうかは必ず評価する必要があります。 セクションのパターンのいくつか [テーブルの設計パターン](#table-design-patterns) に明示的にクエリを実行して、エンティティを変更する間のトレードオフを評価する必要が常を考慮して各種の操作の数。  

セクションの次のパターン [テーブルの設計パターン](#table-design-patterns) 間の効率的なデータ変更の設計と効率的なクエリ設計のトレードオフに対応します。  

-   [複合キー パターン](#compound-key-pattern) -使用する複合 **RowKey** を単一のポイント クエリを持つ関連データを検索するクライアントを有効にする値。  
-   [ログ テール パターン](#log-tail-pattern) の取得、 *n* を使用してパーティションに最も最近追加された、 **RowKey** 逆の日付と時間順でソートする値。  

## テーブル データの暗号化    
     
.NET Azure Storage クライアント ライブラリでは、挿入および置換操作の文字列エンティティ プロパティの暗号化がサポートされます。 暗号化された文字列はバイナリ プロパティとしてサービスで保存され、復号化された後、文字列に変換されて戻されます。    

テーブルの場合、暗号化ポリシーに加え、ユーザーは暗号化するプロパティを指定する必要があります。 これを実行するには、[EncryptProperty] 属性を指定するか (TableEntity から派生した POCO エンティティ用)、または要求オプションで暗号化リゾルバーを指定します。 暗号化リゾルバーは、パーティション キー、行キー、プロパティ名を取得するデリゲートで、プロパティを暗号化するかどうかを示すブール値を返します。 暗号化時、クライアント ライブラリはこの情報を使用して、ネットワークへの書き込み時にプロパティを暗号化するかどうかを決定します。 また、デリゲートは、プロパティの暗号化方法に関するロジックを使用する可能性にも備えます。 (X の場合、プロパティ A を暗号化し、それ以外の場合はプロパティ A および B を暗号化するなど。)エンティティの読み込み中、またはクエリの実行中は、この情報を指定する必要はありません。

現在、マージはサポートされていません。 別のキーを使用してプロパティのサブセットが以前に暗号化されている場合、新しいプロパティをマージしたり、メタデータを更新したりするとデータ損失が発生します。 マージでは、追加のサービス呼び出しをして既存のエンティティをサービスから読み込むか、プロパティごとに新しいキーを使用する必要があります。いずれの方法も、パフォーマンス上の理由でお勧めできません。     

テーブルのデータを暗号化する方法については、次を参照してください。 [クライアント側の暗号化と Microsoft Azure Storage の Azure Key Vault](storage-client-side-encryption.md)します。  

## リレーションシップのモデル化  

複雑なシステムの設計において、ドメイン モデルの作成は重要なステップです。 通常は、ビジネス ドメインについて理解し、システムの設計を伝えるための方法として、モデル化プロセスを使用してエンティティとエンティティどうしのリレーションシップを特定します。 このセクションでは、ドメイン モデル内の一般的なリレーションシップの種類を Table サービス向けの設計に変換する方法を中心に説明します。 論理データ モデルから物理的な NoSQL ベースのデータ モデルへのマッピング プロセスは、リレーショナル データベースの設計時に使われるプロセスとは大きく異なります。 リレーショナル データベースの設計は、通常、冗長性を最小限に抑えるために最適化されたデータの正規化プロセスと、データベースの動作の実装方法を抽象化する宣言によるクエリ機能があることを前提としています。  

### 一対多のリレーションシップ  

ビジネス ドメイン オブジェクトの間で一対多のリレーションシップが存在することはよくあります。たとえば、1 つの部署に多数の従業員が存在する場合などです。 特定のシナリオにおいて、長短それぞれあるものの、Table サービスに一対多のリレーションシップを実装する方法はいくつかあります。  

何万もの部署と従業員のエンティティがある大規模な多国籍企業の例を考えてみてください。各部署には多数の従業員が在籍しており、各従業員は 1 つの特定の部署に関連付けられています。 次のように、部署のエンティティと従業員のエンティティを分けて格納する方法もあります。  

![][1]

この例に基づく種類における暗黙の一対多リレーションシップを示しています、 **PartitionKey** 値。 各部署に多数の従業員が存在する可能性があります。  

この例は、部署エンティティと、同じパーティションに含まれる関連の従業員エンティティも示しています。 別のエンティティの種類として、別のパーティション、テーブル、またはストレージ アカウントを使うこともできます。  

別の方法として、次の例に示すように、データを非正規化し、非正規化された部署データと共に従業員エンティティのみを格納する方法もあります。 このシナリオで部署のマネージャーの詳細を変更できるようにする必要がある場合は、この非正規化の方法は最適ではない可能性があります。部署内のすべての従業員を更新する必要が生じるためです。  

![][2]

詳細については、次を参照してください。、 [非正規化パターン](#denormalization-pattern) このガイドで後述します。  

次の表に、上記で概要を示した一対多のリレーションシップを持つ従業員エンティティと部署エンティティを格納するアプローチについて、それぞれの長所と短所をまとめます。 また、各種操作をどの程度の頻度で実行する見込みかも検討する必要があります。コストの高い操作であっても、実行頻度が高くなければ設計に含めてもかまいません。  

<table>
<tr>
<th>アプローチ</th>
<th>長所</th>
<th>短所</th>
</tr>
<tr>
<td>エンティティの種類は別、パーティション、テーブルは同じ</td>
<td>
<ul>
<li>1 回の操作で部署エンティティを更新できる。</li>
<li>従業員エンティティを更新、挿入、削除するたびに部署エンティティを変更する必要がある場合は、一貫性を維持するために EGT を使用できます。 たとえば、部署ごとの従業員数を管理する場合などです。</li>
</ul>
</td>
<td>
<ul>
<li>場合によっては、一部のクライアント アクティビティで、従業員エンティティと部署エンティティの両方を取得する必要がある。</li>
<li>ストレージ操作が同じパーティションで行われる。 トランザクションの量が多いときにホットスポットが生じる可能性がある。</li>
<li>EGT を使用して従業員を新しい部署に移動できない。</li>
</ul>
</td>
</tr>
<tr>
<td>エンティティの種類は別、パーティション、テーブル、ストレージ アカウントは別</td>
<td>
<ul>
<li>1 回の操作で部署エンティティと従業員エンティティを更新できる。</li>
<li>トランザクションの量が多いときに、負荷をより多くのパーティションに分散させることができる。</li>
</ul>
</td>
<td>
<ul>
<li>場合によっては、一部のクライアント アクティビティで、従業員エンティティと部署エンティティの両方を取得する必要がある。</li>
<li>従業員を更新、挿入、削除し、部署を更新するときに、一貫性を維持するために EGT を使用できる。 たとえば、部署エンティティ内の従業員数を更新する場合などです。</li>
<li>EGT を使用して従業員を新しい部署に移動できない。</li>
</ul>
</td>
</tr>
<tr>
<td>単一のエンティティの種類への非正規化</td>
<td>
<ul>
<li>必要なすべての情報を 1 回の要求で取得できる。</li>
</ul>
</td>
<td>
<ul>
<li>部署の情報を更新する必要がある場合、一貫性の維持のコストが高くなる可能性がある (部署のすべての従業員を更新する必要があるため)。</li>
</ul>
</td>
</tr>
</table>

これらの選択肢のうちのどれを選ぶかや、どの長所と短所の影響が最も大きいかは、アプリケーションのシナリオによって異なります。 たとえば、部署エンティティを変更する頻度、すべての従業員クエリに追加の部署情報が必要かどうか、パーティションまたはストレージ アカウントのスケーラビリティの制限までどのくらいかなどです。  

### 一対一のリレーションシップ  

ドメイン モデルにはエンティティ間の一対一のリレーションシップが含まれることもあります。 Table サービスで一対一のリレーションシップを実装する必要がある場合は、2 つの関連するエンティティを取得する必要があるときにそれらをリンクする方法も選択する必要があります。 このリンクの形式でのリンクを格納することで暗黙的なキーの値の規則に基づいてまたは明示的なを指定できます **PartitionKey** と **RowKey** 、関連するエンティティには、各エンティティの値。 同じパーティションに関連するエンティティを格納するかどうかの詳細については、セクションを参照してください。 [一対多リレーションシップ](#one-to-many-relationships)します。  

実装上の検討内容に応じて、Table サービスで一対一のリレーションシップを実装する必要が生じることもあります。  

-   ラージ エンティティの処理 (詳細については、次を参照してください。 [大規模なエンティティの操作](#working-with-large-entities))。  
-   アクセス制御を実装する (詳細については、次を参照してください。 [共有アクセス署名によるアクセス制御](#controlling-access-with-shared-access-signatures))。  

### クライアントでの結合  

Table サービスでのリレーションシップのモデル化には何とおりかの方法があるものの、Table サービスを使う主な理由はスケーラビリティとパフォーマンスの 2 つであることを忘れないでください。 ソリューションのパフォーマンスとスケーラビリティを損なう多数のリレーションシップをモデル化しようとしていることに気が付いた場合は、そのすべてのデータ リレーションシップをテーブル設計に組み込む必要があるかどうかを確認する必要があります。 クライアント アプリケーションで必要な結合が実行されるようにすると、設計を簡素化し、ソリューションのスケーラビリティとパフォーマンスを向上させることができます。  

たとえば、変更頻度の高くないデータが格納された小さなテーブルがある場合は、そのデータを取得した後でクライアント上にキャッシュできます。 そうすると、何度も同じデータを取得する必要がなくなります。 このガイドで見てきた例では、小規模な組織の部署のセットは小さく、変更頻度も低いことが多いので、データをクライアント アプリケーションでダウンロードしてからルックアップ データとしてキャッシュするのに適しています。  

### 継承リレーションシップ  

クライアント アプリケーションでビジネス エンティティを表す継承リレーションシップの一部を構成するクラスのセットを使用する場合は、それらのエンティティを Table サービスで簡単に保持できます。 たとえば、次の一連のクライアント アプリケーションで定義されているクラスがあります、 **人** 抽象クラスです。

![][3]

エンティティを次のように扱う 1 つの Person テーブルを使えば、2 つの具象クラスのインスタンスを Table サービスで維持できます。  

![][4]

クライアント コードで同じテーブル内の複数のエンティティ種類の作業の詳細については、セクションを参照してください。 [異なる種類のエンティティ型の使用](#working-with-heterogeneous-entity-types) このガイドで後述します。 クライアント コードでエンティティの種類を認識する方法の例が示されています。  

## テーブル設計のパターン
前のセクションでは、クエリを使用してエンティティ データを取得する場合と、エンティティ データを挿入、更新、削除する場合の両方のテーブル設計を最適化する方法について詳しく説明しました。 このセクションでは、Table サービス ソリューションで使用するのに適したパターンをいくつか紹介します。 また、このガイドで前に提起された問題とトレードオフの一部に実際に対処する方法を説明しています。 次の図は、さまざまなパターンの関係をまとめたものです。  

![][5]

上記のパターン マップには、このガイドに記載されているパターン (青) とアンチパターン (オレンジ) の関係の一部が示されています。 もちろん、検討する価値があるパターンは他にもたくさんあります。 たとえばを格納するテーブル サービスの主なシナリオの 1 つは [具体化されたビュー](https://msdn.microsoft.com/library/azure/dn589782.aspx) から、 [コマンド クエリ責務分離](https://msdn.microsoft.com/library/azure/jj554200.aspx) (CQRS) パターンです。  

### パーティション内セカンダリ インデックス パターン
異なるを使用して各エンティティの複数コピーを格納 **RowKey** 値 (同じパーティション内) を有効にする高速で効率的な検証と代替の並べ替え順序を使用して異なる **RowKey** 値。 コピー間の更新の一貫性は、EGT を使用して保つことができます。  

#### コンテキストと問題
自動的にインデックスを使用してエンティティがテーブル サービス、 **PartitionKey** と **RowKey** 値。 そのため、クライアント アプリケーションでは、これらの値を使用してエンティティを効率的に取得できます。 たとえば、次のようなテーブル構造を使用して、クライアント アプリケーション、ポイント クエリを使用して部署名と従業員 id を使用して、個々 の従業員エンティティを取得 (、 **PartitionKey** と **RowKey** 値)。 また、各部署内の従業員 ID で並べ替えたエンティティを取得することも可能です。

![][6]

また、電子メール アドレスなど、他のプロパティの値に基づいて従業員エンティティを検索できるようにする場合は、効率の劣るパーティション スキャンを使用して、一致するエンティティを検索する必要があります。 これは、Table サービスではセカンダリ インデックスが提供されないためです。 さらとは異なる順序で並べ替えられた従業員の一覧を要求するオプションはありません **RowKey** 順序です。  

#### 解決策
セカンダリ インデックスの不足を回避するには、異なる各コピーを使用して各エンティティの複数のコピーを格納 **RowKey** 値。 次のような構造体を持つエンティティを格納する場合は、電子メール アドレスや従業員 ID に基づく複数の 従業員エンティティを効率的に取得できます。 プレフィックスの値、 **RowKey**, 、「empid _」、「email _」を使用すると、1 人の従業員または一連の従業員の電子メール アドレスまたは従業員 id の範囲を使用してクエリを実行します。  

![][7]

次の 2 つのフィルター条件 (従業員 ID で検索するフィルター条件と電子メール アドレスで検索するフィルター条件) ではどちらもポイント クエリを指定しています。  

-   $filter = (PartitionKey eq 'Sales') と (RowKey eq 'empid_000223')  
-   $filter = (PartitionKey eq 'Sales') と (RowKey eq 'email_jonesj@contoso.com')  

範囲の従業員エンティティを照会する場合は、従業員 id の順に並べ替えられたか、適切なプレフィックスを持つエンティティを照会して、電子メール アドレス順で並べ替えられた範囲を指定することができます、 **RowKey**します。  

-   Sales 部署で従業員 ID が 000100 ～ 000199 の範囲のすべての従業員を検索するには、次の条件を使用します。
$filter = (PartitionKey eq 'Sales') と (RowKey ge 'empid_000100') と (RowKey le 'empid_000199')  
-   Sales 部署で 'a' の使用という文字で始まる電子メール アドレスを持つすべての従業員を検索。
$filter = (PartitionKey eq 'Sales') と (RowKey ge 'email_a') と (RowKey lt 'email_b')  

 詳細については「Table サービス REST API ものは、上記の例で使用されるフィルター構文 [Query Entities](http://msdn.microsoft.com/library/azure/dd179421.aspx) MSDN にします。  

#### 問題と注意事項  

このパターンの実装方法を決めるときには、以下の点に注意してください。  

-   テーブル ストレージは比較的低コストで利用できるため、重複するデータを格納してもコストは大きな問題になりません。 ただし、必ず、予想されるストレージ要件に基づいて設計のコストを見積もり、クライアント アプリケーションが実行するクエリで使用するエンティティのみを複製する必要があります。  
-   セカンダリ インデックス エンティティは元のエンティティと同じパーティションに格納されるため、個々のパーティションのスケーラビリティ ターゲットを超えないようにする必要があります。  
-   EGT を使用してエンティティの 2 つのコピーをアトミックに更新することで、重複するエンティティどうしの一貫性を保つことができます。 そのためには、エンティティのすべてのコピーを同じパーティションに格納する必要があります。 詳細については、セクションを参照してください。 [エンティティ グループ トランザクションの使用](#entity-group-transactions)します。  
-   使用する値、 **RowKey** 各エンティティに対して一意である必要があります。 複合キー値の使用を検討してください。  
-   数値でのパディング、 **RowKey** 有効な並べ替えとフィルターに基づいて上限と下限 (たとえば、従業員 id 000223)。  
-   必ずしもエンティティのすべてのプロパティを複製する必要はありません。 などの場合、クエリで検索する電子メールを使用してエンティティのアドレス、 **RowKey** 、従業員の年齢は必要ありません、これらのエンティティは、次の構造を持っている可能性があります。

![][8]

-   通常は、エンティティの検索と必要なデータの検索にそれぞれ異なるクエリを使用するよりも、重複するデータを格納し、必要なすべてのデータを単一のクエリで取得できるようにすることをお勧めします。  

#### このパターンを使用する状況  

クライアント アプリケーションで異なるさまざまなキーを使用してエンティティを取得する必要がある場合、クライアントで異なる順序で並べ替えたエンティティを取得する必要がある場合、さまざまな一意の値を使用して各エンティティを識別できる場合に、このパターンを使用します。 ただし、必ずを超えないようにパーティションのスケーラビリティの制限、さまざまなを使用して、エンティティ参照を実行している **RowKey** 値。  

#### 関連のあるパターンとガイダンス  

このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  

-   [パーティション間セカンダリ インデックス パターン](#inter-partition-secondary-index-pattern)
-   [複合キー パターン](#compound-key-pattern)
-   [エンティティ グループ トランザクション](#entity-group-transactions)
-   [異なる種類のエンティティを操作する](#working-with-heterogeneous-entity-types)

### パーティション間セカンダリ インデックス パターン
異なるを使用して各エンティティの複数コピーを格納 **RowKey** 値が別々 のパーティションまたは異なるを有効にする高速で効率的な検証と代替の並べ替え順序を使用してテーブルを別個の **RowKey** 値。  

#### コンテキストと問題
自動的にインデックスを使用してエンティティがテーブル サービス、 **PartitionKey** と **RowKey** 値。 そのため、クライアント アプリケーションでは、これらの値を使用してエンティティを効率的に取得できます。 たとえば、次のようなテーブル構造を使用して、クライアント アプリケーション、ポイント クエリを使用して部署名と従業員 id を使用して、個々 の従業員エンティティを取得 (、 **PartitionKey** と **RowKey** 値)。 また、各部署内の従業員 ID で並べ替えたエンティティを取得することも可能です。  

![][9]

また、電子メール アドレスなど、他のプロパティの値に基づいて従業員エンティティを検索できるようにする場合は、効率の劣るパーティション スキャンを使用して、一致するエンティティを検索する必要があります。 これは、Table サービスではセカンダリ インデックスが提供されないためです。 さらとは異なる順序で並べ替えられた従業員の一覧を要求するオプションはありません **RowKey** 順序です。  

これらのエンティティに対するトランザクションの量が膨大になることが予想される場合は、Table サービスによってクライアントが調整されるリスクを最小限に抑える必要があります。  

#### 解決策  
セカンダリ インデックスの不足を回避するには別にコピーを使用して各エンティティごとの複数コピーを格納 **PartitionKey** と **RowKey** 値。 次のような構造体を持つエンティティを格納する場合は、電子メール アドレスや従業員 ID に基づく複数の 従業員エンティティを効率的に取得できます。 プレフィックスの値、 **PartitionKey**, 、「empid _」、「email _」を使用するクエリに使用するインデックスを特定できます。  

![][10]

次の 2 つのフィルター条件 (従業員 ID で検索するフィルター条件と電子メール アドレスで検索するフィルター条件) ではどちらもポイント クエリを指定しています。  

-   $filter=(PartitionKey eq 'empid_Sales') and (RowKey eq '000223')
-   $filter=(PartitionKey eq 'email_Sales') and (RowKey eq 'jonesj@contoso.com')  

範囲の従業員エンティティを照会する場合は、従業員 id の順に並べ替えられたか、適切なプレフィックスを持つエンティティを照会して、電子メール アドレス順で並べ替えられた範囲を指定することができます、 **RowKey**します。  

-   従業員 id の範囲の Sales 部署のすべての従業員を検索する **000100** に **000199** 従業員 id 順の使用に並べ替えられます。
$filter = (PartitionKey eq ' empid_Sales') と (RowKey ge '000100') と (RowKey le '000199')  
-   'A' で並べ替えられた電子メールで始まる電子メール アドレスを持つ、Sales 部署のすべての従業員を検索するには、アドレスの順序を使用します。
$filter = (PartitionKey eq ' email_Sales') と (RowKey ge 'a') と (RowKey lt 'b')  

詳細については「Table サービス REST API ものは、上記の例で使用されるフィルター構文 [Query Entities](http://msdn.microsoft.com/library/azure/dd179421.aspx) MSDN にします。  

#### 問題と注意事項  
このパターンの実装方法を決めるときには、以下の点に注意してください。  

-   おくと、重複するエンティティ互いに最終的に一貫性のあるを使用して、 [最終的に一貫性のあるトランザクション パターン](#eventually-consistent-transactions-pattern) プライマリとセカンダリ インデックス エンティティを維持します。  
-   テーブル ストレージは比較的低コストで利用できるため、重複するデータを格納してもコストは大きな問題になりません。 ただし、必ず、予想されるストレージ要件に基づいて設計のコストを見積もり、クライアント アプリケーションが実行するクエリで使用するエンティティのみを複製する必要があります。  
-   使用する値、 **RowKey** 各エンティティに対して一意である必要があります。 複合キー値の使用を検討してください。  
-   数値でのパディング、 **RowKey** 有効な並べ替えとフィルターに基づいて上限と下限 (たとえば、従業員 id 000223)。  
-   必ずしもエンティティのすべてのプロパティを複製する必要はありません。 などの場合、クエリで検索する電子メールを使用してエンティティのアドレス、 **RowKey** 、従業員の年齢は必要ありません、これらのエンティティは、次の構造を持っている可能性があります。

    ![][11]

-   通常は、セカンダリ インデックスを使用したエンティティの検索とプライマリ インデックス内の必要なデータの検索にそれぞれ異なるクエリを使用するよりも、重複するデータを格納し、必要なすべてのデータを単一のクエリで取得できるようにすることをお勧めします。  

#### このパターンを使用する状況  
クライアント アプリケーションで異なるさまざまなキーを使用してエンティティを取得する必要がある場合、クライアントで異なる順序で並べ替えたエンティティを取得する必要がある場合、さまざまな一意の値を使用して各エンティティを識別できる場合に、このパターンを使用します。 さまざまなを使用して、エンティティ参照を実行している場合、パーティションのスケーラビリティの制限を超えないようにする場合に、このパターンを使用して **RowKey** 値。  

#### 関連のあるパターンとガイダンス
このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  

-   [最終的に一貫性のあるトランザクション パターン](#eventually-consistent-transactions-pattern)  
-   [パーティション内セカンダリ インデックス パターン](#intra-partition-secondary-index-pattern)  
-   [複合キー パターン](#compound-key-pattern)  
-   [エンティティ グループ トランザクション](#entity-group-transactions)  
-   [異なる種類のエンティティを操作する](#working-with-heterogeneous-entity-types)  

### 最終的に一貫性のあるトランザクション パターン  

Azure キューを使用して、パーティションやストレージ システムの境界を越えて、最終的に一貫した動作を実現します。  

#### コンテキストと問題  

EGT を使用すると、同じパーティション キーを共有する複数のエンティティに対してアトミックなトランザクションを実行できます。 パフォーマンスやスケーラビリティの関係で、一貫性が必要なエンティティを別々のパーティションや別のストレージ システムに格納する場合があります。そのような場合は、EGT を使用して一貫性を保つことはできません。 たとえば、次の一貫性を最終的に確保する必要があるとします。  

-   同じテーブル内の 2 つの異なるパーティション、異なるテーブル、異なるストレージ アカウントに格納されているエンティティ。  
-   Table サービスに格納されているエンティティと BLOB サービスに格納されている BLOB。  
-   Table サービスに格納されているエンティティとファイル システム内のファイル。  
-   Table サービスに格納されているにもかかわらず、Azure Search サービスを使用してインデックスが作成されているエンティティ。  

#### 解決策  

Azure キューを使用すると、2 つ以上のパーティションまたはストレージ システム間で最終的に一貫性を確保するソリューションを実装できます。
この方法を説明するために、退職した従業員エンティティをアーカイブできるようにする必要があるとします。 退職した従業員エンティティはめったに照会されず、現在の従業員を対象にしたすべてのアクティビティから除外する必要があります。 この要件を実装するには、有効な従業員を格納する、 **現在** テーブルと古い従業員、 **アーカイブ** テーブルです。 エンティティを削除する従業員をアーカイブする必要があります、 **現在** テーブルし、エンティティを追加、 **アーカイブ** は、テーブルは、これら 2 つの操作を実行する EGT を使用できません。 エンティティが両方のテーブルに表示されることや、どちらのテーブルにも表示されないことがないように、アーカイブ操作は最終的に一貫性が確保される必要があります。 次のシーケンス図は、この操作の大まかな手順を示しています。 その下のテキストには、例外パスの詳細が示されています。  

![][12]

クライアントは、Azure キューにメッセージを配置することによって、アーカイブ操作を開始します。この例では、ID が 456 の従業員をアーカイブします。 worker ロールは、キューをポーリングして新しいメッセージの有無を確認します。メッセージを見つけると、そのメッセージを読み取り、隠しコピーをキューに残します。 ワーカー ロールは次に、エンティティからのコピーをフェッチ、 **現在** テーブルでのコピーを挿入、 **アーカイブ** テーブル、および、元からを削除、 **現在** テーブルです。 最後に、前の手順でエラーが発生しなければ、worker ロールはキューから隠しメッセージを削除します。  

この例では、手順 4 に従業員を挿入します。、 **アーカイブ** テーブルです。 BLOB サービスの BLOB またはファイル システム内のファイルに従業員を加えることもできます。  

#### エラーからの回復  

重要の手順で operations **4** と **5** する必要があります *アイデムポ テントな* ワーカー ロールがアーカイブ操作を再開する必要がある場合。 ステップのテーブル サービスを使用しているかどうかは **4** 「挿入または置換」操作を使用する必要があります。 手順 **5** を使用する必要があります、"場合は、削除が存在する"を使用しているクライアント ライブラリで操作します。 他のストレージ システムを使用する場合は、適切なべき等操作を使用する必要があります。  

ワーカー ロールが手順を完了しない場合 **6**, 、メッセージは、タイムアウトの後に再処理しようとする worker ロール準備完了のキューが表示されします。 worker ロールは、キュー上のメッセージを読み取った回数を確認し、必要に応じて、別のキューに送信することで、調査のために "有害" メッセージとしてフラグを設定できます。 キュー メッセージの読み取りとデキュー カウントのチェックに関する詳細については、次を参照してください。 [Get Messages](https://msdn.microsoft.com/library/azure/dd179474.aspx)します。  

Table サービスと Queue サービスのエラーには一時的なエラーもあります。クライアント アプリケーションには、そうしたエラーに対処する適切な再試行ロジックを組み込む必要があります。  

#### 問題と注意事項
このパターンの実装方法を決めるときには、以下の点に注意してください。  

-   このソリューションは、トランザクションを分離するためのソリューションではありません。 たとえば、クライアントが読み取る可能性があります、 **現在** と **アーカイブ** テーブルをワーカー ロールがステップ間が **4** と **5**, 、し、データの表示に矛盾を参照してください。 データは最終的に一貫性が確保されます。  
-   最終的に一貫性を確保するために、手順 4. と 5. がべき等になっていることを確認する必要があります。  
-   複数のキューと worker ロール インスタンスを使用して、ソリューションを拡張できます。  

#### このパターンを使用する状況  
別のパーティションまたはテーブルに存在するエンティティ間の一貫性を最終的に確保する必要がある場合に、このパターンを使用します。 このパターンを拡張して、Table サービスと BLOB サービスのほかにも、データベースやファイル システムなどの Azure 以外のストレージ データ ソース間の操作で最終的な一貫性を確保できます。  

#### 関連のあるパターンとガイダンス  
このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  
-   [エンティティ グループ トランザクション](#entity-group-transactions)  
-   [マージまたは置換](#merge-or-replace)  

>[AZURE.NOTE] トランザクションの分離がソリューションに重要な場合は、Egt を使用できるようにテーブルを再設計を検討してください。  

### インデックス エンティティ パターン
インデックス エンティティを保持して、エンティティの一覧を返す効率の良い検索を実現します。  

#### コンテキストと問題  

自動的にインデックスを使用してエンティティがテーブル サービス、 **PartitionKey** と **RowKey** 値。 そうすると、クライアント アプリケーションでポイント クエリを使用してエンティティを効率的に取得できます。 たとえば、次のようなテーブル構造を使用して、クライアント アプリケーション効率的に取得できます、個々 の従業員エンティティ部署名と従業員 id を使用して (、 **PartitionKey** と **RowKey**)。  

![][13]

また、姓など、一意ではない他のプロパティの値に基づいて従業員エンティティの一覧を取得できるようにする場合は、インデックスを使用して直接一致するエンティティを検索せずに、効率の劣るパーティション スキャンを使用して検索する必要があります。 これは、Table サービスではセカンダリ インデックスが提供されないためです。  

#### 解決策  

上のエンティティ構造の場合、姓で検索できるようにするには、従業員 ID の一覧を保持する必要があります。 Jones など、特定の姓を持つ従業員エンティティを取得するには、まず姓が Jones である従業員の従業員 ID の一覧を検索してから、それらの従業員エンティティを取得する必要があります。 従業員 ID の一覧を格納する方法は主に次の 3 つがあります。  

-   BLOB ストレージを使用する。  
-   従業員エンティティと同じパーティションにインデックス エンティティを作成する。  
-   別のパーティションまたはテーブルにインデックス エンティティを作成する。  

<u>オプション 1: blob ストレージの使用</u>  

最初のオプションをすべて一意の姓、および各 blob ストアの blob の一覧を作成、 **PartitionKey** (部署) と **RowKey** その姓の従業員用の (従業員 id) 値です。 従業員を追加または削除した場合は、関連する BLOB の内容と従業員エンティティの一貫性が最終的に確保されていることを確認する必要があります。  

<u>オプション 2:</u> 同じパーティションにインデックス エンティティを作成する  

2 番目の方法では、以下のデータを格納するインデックス エンティティを使用します。  

![][14]

 **EmployeeIDs** プロパティに格納されている姓を持つ従業員の従業員 id の一覧を含んでいる、 **RowKey**します。  

次の手順は、2 番目の方法を使用した場合に、新しい従業員を追加するときに従う必要がある手順の概要を示しています。 この例では、Sales 部署で ID が 000152、姓が Jones の従業員を追加します。  
1.  インデックス エンティティを取得、 **PartitionKey** 値"Sales"と **RowKey** 値"Jones" このエンティティの ETag を、手順 2. で使用するために保存します。  
2.  新しい従業員エンティティを挿入するエンティティ グループ トランザクション (つまり、バッチ操作) を作成 (**PartitionKey** 値"Sales"と **RowKey** 値「000152」)、インデックス エンティティを更新 (**PartitionKey** 値"Sales"と **RowKey** 値"Jones") を EmployeeIDs フィールドの一覧に新しい従業員 id を追加することで。 エンティティ グループ トランザクションの詳細については、次を参照してください。 [エンティティ グループ トランザクション](#entity-group-transactions)します。 
3.  オプティミスティック同時実行エラー (他のユーザーがインデックス エンティティを変更したこと) が原因でエンティティ グループ トランザクションが失敗した場合は、手順 1. からまたやり直す必要があります。  

2 番目の方法を使用する場合は、同じような方法で従業員を削除できます。 従業員の姓を変更するのは、3 つのエンティティ (従業員エンティティ、元の姓のインデックス エンティティ、新しい姓のインデックス エンティティ) を更新するエンティティ グループ トランザクションを実行する必要があるため、少し複雑です。 変更を加える前に、各エンティティを取得して、ETag 値を取得する必要があります。その ETag 値を使用して、オプティミスティック同時実行で更新を実行できます。  

次の手順は、2 番目の方法を使用した場合に、ある部署で特定の姓を持つすべての従業員を検索する必要があるときに従う必要がある手順の概要を示しています。 この例では、Sales 部署で姓が Jones のすべての従業員を検索します。  

1.  インデックス エンティティを取得、 **PartitionKey** 値"Sales"と **RowKey** 値"Jones"  
2.  EmployeeIDs フィールドで従業員 ID の一覧を解析します。  
3.  これらの従業員 (電子メール アドレスなど) の各に関する追加情報を実行する場合に、取得を使用して従業員エンティティの各 **PartitionKey** 値"Sales"と **RowKey** 手順 2. で取得した従業員の一覧の値。  

<u>オプション 3:</u> 別のパーティションやテーブルにインデックス エンティティを作成する  

3 番目の方法では、以下のデータを格納するインデックス エンティティを使用します。  

![][15]

 **EmployeeIDs** プロパティに格納されている姓を持つ従業員の従業員 id の一覧を含んでいる、 **RowKey**します。  

3 番目の方法では、インデックス エンティティが従業員エンティティとは別のパーティションにあるため、EGT を使用して一貫性を保つことはできません。 インデックス エンティティが従業員エンティティと最終的に一貫していることを確認する必要があります。  

#### 問題と注意事項  

このパターンの実装方法を決めるときには、以下の点に注意してください。  
-   このソリューションには、一致するエンティティを取得するには、少なくとも 2 つのクエリが必要です: 1 つのリストを取得するインデックス エンティティを照会する **RowKey** 値、およびし、一覧の各エンティティを取得するクエリ。  
-   個々のエンティティの最大サイズは 1 MB であるため、ソリューションの方法 2 と方法 3 では、特定の姓の従業員 ID の一覧が 1 MB を超えることがないと仮定しています。 従業員 ID の一覧のサイズが 1 MB を超える可能性がある場合は、方法 1 を使用して、BLOB ストレージにインデックス データを格納します。  
-   方法 2 を使用する (EGT を使用して、従業員の追加と削除、従業員の姓の変更を処理する) 場合は、トランザクションの量が特定のパーティションのスケーラビリティの限界に近づくかどうかを確認する必要があります。 限界に近づく場合は、キューを使用して更新要求を処理し、従業員エンティティとは別のパーティションにインデックス エンティティを格納でき、最終的に一貫性が確保されるソリューション (方法 1 または方法 3) を検討する必要があります。  
-   このソリューションの方法 2 では、部署内を姓で検索する (たとえば、Sales 部署で姓が Jones の従業員の一覧を取得する) 必要があると想定しています。 組織全体で姓が Jones のすべての従業員を検索できる必要がある場合は、方法 1 と方法 3 のどちらかを使用します。
-   最終的な一貫性を提供するキュー ベースのソリューションを実装することができます (を参照してください、 [最終的に一貫性のあるトランザクション パターン](#eventually-consistent-transactions-pattern) 詳細)。  

#### このパターンを使用する状況  

姓が Jones のすべての従業員など、特定のプロパティ値がすべて共通している一連のエンティティを検索する場合に、このパターンを使用します。  

#### 関連のあるパターンとガイダンス  

このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  
-   [複合キー パターン](#compound-key-pattern)  
-   [最終的に一貫性のあるトランザクション パターン](#eventually-consistent-transactions-pattern)  
-   [エンティティ グループ トランザクション](#entity-group-transactions)  
-   [異なる種類のエンティティを操作する](#working-with-heterogeneous-entity-types)  

### 非正規化パターン  

関連するデータを 1 つのエンティティに結合し、1 回のポイント クエリで必要なデータをすべて取得できるようにします。  

#### コンテキストと問題  

リレーショナル データベースでは、通常、重複を排除するためにデータを正規化します。その結果、クエリで複数のテーブルからデータを取得することになります。 Azure テーブルのデータを正規化した場合、関連するデータを取得するには、クライアント アプリケーションとサーバー間のラウンド トリップを複数回行う必要があります。 たとえば、以下のテーブル構造を使用した場合、部署の詳細を取得するためには、2 回ラウンド トリップを行う必要があります。1 回目のラウンド トリップでマネージャーの ID を含む部署エンティティをフェッチし、2 回目で従業員エンティティからマネージャーの詳細をフェッチします。  

![][16]

#### 解決策  

データを 2 つのエンティティに格納する代わりに、データを非正規化し、部署エンティティにマネージャーの詳細のコピーを保持します。 次に例を示します。  

![][17]

格納されている部署エンティティにはこれらのプロパティがあるため、ポイント クエリを使用して、部署に関する必要なすべての詳細を取得できます。  

#### 問題と注意事項  

このパターンの実装方法を決めるときには、以下の点に注意してください。  

-   一部のデータを重複して格納するため、多少コストがかかります。 通常、ストレージ コストの増加はわずかなため、(ストレージ サービスへの要求が減少することによる) パフォーマンス上のメリットが勝ります (このコストの一部は、部署の詳細をフェッチするために必要なトランザクションの数が減少することで相殺されます)。  
-   マネージャーに関する情報を格納する 2 つのエンティティの一貫性を維持する必要があります。 一貫性の問題は、EGT を使用して単一のアトミックなトランザクションで複数のエンティティを更新することで対処できます。この例では、部署エンティティと、部署マネージャーの従業員エンティティが同じパーティションに格納されています。  

#### このパターンを使用する状況
関連情報を頻繁に検索する必要がある場合に、このパターンを使用します。 このパターンを使用すると、クライアントが必要なデータを取得するために実行する必要があるクエリの数が減少します。  

#### 関連のあるパターンとガイダンス
このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  
-   [複合キー パターン](#compound-key-pattern)  
-   [エンティティ グループ トランザクション](#entity-group-transactions)  
-   [異なる種類のエンティティを操作する](#working-with-heterogeneous-entity-types)

### 複合キー パターン  

使用する複合 **RowKey** を単一のポイント クエリを持つ関連データを検索するクライアントを有効にする値。  

#### コンテキストと問題  

リレーショナル データベースでは、単一のクエリで関連するデータをクライアントに返すために、クエリでよく結合を使用します。 たとえば、従業員 ID を使用して、その従業員の業績と評価データが含まれている関連エンティティの一覧を検索する場合があります。  

次の構造を使用し、Table サービスに従業員エンティティを格納しているとします。  

![][18]

また、各年度の従業員の評価と業績に関する履歴データを格納し、この情報に年度別でアクセスできる必要もあります。 それには、次の構造でエンティティを格納する別のテーブルを作成するという方法があります。  

![][19]

この方法では、単一の要求でデータを取得できるようにするには、一部の情報 (姓や名など) を新しいエンティティに複製する必要があります。 ただし、EGT を使用しても 2 つのエンティティをアトミックには更新できないため、強力な整合性を保つことはできません。  

#### 解決策
次の構造のエンティティを使用して、元のテーブルに新しい種類のエンティティを格納します。  

![][20]

注意してください、 **RowKey** の従業員 id と、従業員のパフォーマンスを取得し、単一のエンティティの単一の要求でデータを確認することができます評価データの年で構成される複合キーになります。  

次の例では、Sales 部署の従業員 000123 など、特定の従業員のすべての評価データを取得する方法を示しています。  

$filter=(PartitionKey eq 'Sales')、(RowKey ge 'empid_000123')、(RowKey lt 'empid_000124')&$select=RowKey,Manager Rating,Peer Rating,Comments  

#### 問題と注意事項
このパターンの実装方法を決めるときには、以下の点に注意してください。  

-   簡単に解析する適切な区切り文字を使用する必要があります、 **RowKey** 値: たとえば、 **000123_2012**します。  
-   また、このエンティティは、同じ従業員の関連データを含む他のエンティティと同じパーティションに格納します。そうすると、EGT を使用して、強い整合性を維持できます。
-   このパターンが適切であるかどうかを判断には、データを照会する頻度を考慮する必要があります。  たとえば、評価データにはあまり頻度にアクセスせず、メインの従業員データには頻度にアクセスする場合は、それらのデータを別々のエンティティとして保持する必要があります。  

#### このパターンを使用する状況  

頻繁に照会する関連エンティティを 1 つ以上格納する必要がある場合に、このパターンを使用します。  

#### 関連のあるパターンとガイダンス  

このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  

-   [エンティティ グループ トランザクション](#entity-group-transactions)  
-   [異なる種類のエンティティを操作する](#working-with-heterogeneous-entity-types)  
-   [最終的に一貫性のあるトランザクション パターン](#eventually-consistent-transactions-pattern)  

### ログ テール パターン  

取得、 *n* を使用してパーティションに最も最近追加された、 **RowKey** 逆の日付と時間順でソートする値。  

#### コンテキストと問題  

よく、最近作成されたエンティティ (従業員が提出した経費請求を日時の新しいものから 10 件など) を取得できることが必要な場合があります。 Table クエリ サポート、 **$top** クエリ操作を最初に見つかった *n* セットからエンティティ: セット内の最後の n 件のエンティティの取得を同等のクエリ操作はありません。  

#### 解決策  

使用してエンティティを格納、 **RowKey** 当然ながら、そのため、最新のエントリを使用して逆の日付と時刻順で並べ替えるが常にあるテーブルの 1 つ目です。  

たとえば、従業員が提出した経費請求を日時の新しいものから 10 件取得できるようにする場合は、現在の日時から派生した逆順のティック値を使用できます。 次の c# コード サンプルがの適切な「逆タイマー刻み」値を作成する 1 つ方法を示して、 **RowKey** 最新から並べ替えを最も古いもの。  

`string invertedTicks = string.Format("{0:D19}", DateTime.MaxValue.Ticks - DateTime.UtcNow.Ticks);`  

次のコードを使用すると、日時値に戻すことができます。  

`DateTime dt = new DateTime(DateTime.MaxValue.Ticks - Int64.Parse(invertedTicks));`  

テーブル クエリは次のようになります。  

`https://myaccount.table.core.windows.net/EmployeeExpense(PartitionKey='empid')?$top=10`  

#### 問題と注意事項  

このパターンの実装方法を決めるときには、以下の点に注意してください。  

-   文字列値が正しく並び替わるように、逆順のティック値の先頭にゼロをパディングする必要があります。  
-   パーティション レベルのスケーラビリティ ターゲットに注意する必要があります。 ホット スポット パーティションが発生しないように注意してください。  

#### このパターンを使用する状況  

日時の逆順でエンティティにアクセスする必要がある場合、または追加日時の新しい順にエンティティにアクセスする必要がある場合に、このパターンを使用します。  

#### 関連のあるパターンとガイダンス  

このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  

-   [先頭または末尾に追加するアンチパターン](#prepend-append-anti-pattern)  
-   [エンティティを取得する](#retrieving-entities)  

### 大量削除パターン  

すべてのエンティティを同時削除用に独立したテーブルに格納することで、大量のエンティティを削除できるようにします。エンティティを削除するときは、テーブル自体を削除することになります。  

#### コンテキストと問題  

多くのアプリケーションでは、クライアント アプリケーションで使用する必要がなくなった古いデータや、他の記憶域メディアにアーカイブした古いデータを削除します。 通常は、日付でそうしたデータを特定します。たとえば、60 日以上前のすべてのログイン要求のレコードを削除する必要があるとします。  

1 つの利用可能な設計でのログイン リクエストの日時を使用する、 **RowKey**:  

![][21]

この方法では、アプリケーションが別のパーティションで各ユーザーのログイン エンティティを挿入したり削除したりできるため、パーティションのホット スポットを回避できます。 ただし、まず削除するすべてのエンティティを特定するためにテーブル スキャンを実行し、その後、古い各エンティティを削除する必要があるため、エンティティの数が多い場合、この方法ではコストと時間がかかる可能性があります。 複数の削除要求をバッチ処理として EGT にまとめることで、古いエンティティを削除するのに必要なサーバーへのラウンド トリップの回数を減らすことができます。  

#### 解決策  

ログイン試行の日付ごとに異なるテーブルを使用します。 上のエンティティのデザインを使用すると、エンティティを挿入する際にホットスポットを回避できます。毎日数百や数千もの個々のログイン エンティティを検索して削除する代わりに、毎日テーブルを 1 つ削除する (単一のストレージ操作) だけで古いエンティティを削除できます。  

#### 問題と注意事項  

このパターンの実装方法を決めるときには、以下の点に注意してください。  

-   特定のエンティティの検索、他のデータとのリンク、集計情報の生成など、データの他の用途もサポートするように設計していますか。  
-   新しいエンティティを挿入する際にホットスポットを回避するように設計していますか。  
-   テーブル名を削除した後に同じテーブル名を再利用する場合に遅延が必要であります。 常に一意のテーブル名を使用することをお勧めします。  
-   Table サービスではアクセス パターンを学習して、ノード全体にパーティションを分散しますが、最初に新しいテーブルを使用するときは何らかの調整が行われます。 新しいテーブルを作成する必要がある頻度を検討する必要があります。  

#### このパターンを使用する状況  

同時に削除する必要があるエンティティが大量にある場合に、このパターンを使用します。  

#### 関連のあるパターンとガイダンス  

このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  

-   [エンティティ グループ トランザクション](#entity-group-transactions)
-   [エンティティを変更する](#working-with-heterogeneous-entity-types)  

### データ系列パターン  

データ系列全体を単一のエンティティに格納し、要求の数を最小限に抑えます。  

#### コンテキストと問題  

一般的なシナリオとして、通常、アプリケーションで一度にすべて取得する必要があるデータ系列を格納するというものがあります。 たとえば、アプリケーションで 1 時間ごとに各従業員が送信した IM メッセージの数を記録し、後でその情報を使用して、各ユーザーが過去 24 時間以内に送信したメッセージの数をプロットするとします。 設計の 1 つとして、従業員ごとに 24 個のエンティティを格納します。  

![][22]

この設計では、アプリケーションでメッセージのカウント値を更新する必要があるときに、各従業員の更新するエンティティを簡単に検索して更新できます。 ただし、情報を取得して、過去 24 時間の活動のグラフをプロットするためには、24 個のエンティティを取得する必要があります。  

#### 解決策  

次のデザインを使用し、各時間のメッセージ数をそれぞれ別のプロパティに格納します。  

![][23]

この設計では、マージ操作を使用して、特定の時間の従業員のメッセージ数を更新できます。 これで、単一のエンティティに対する単一の要求を使用して、チャートをプロットするために必要なすべての情報を取得できます。  

#### 問題と注意事項  

このパターンの実装方法を決めるときには、以下の点に注意してください。  
-   データ系列全体が単一のエンティティに収まらない場合 (エンティティは最大 252 個のプロパティを持つことができます)、BLOB などの代わりのデータ ストアを使用します。  
-   エンティティの更新を同時に複数のクライアントがある場合は、使用する必要があります、 **ETag** オプティミスティック同時実行制御を実装します。 クライアントがたくさんある場合は、競合が大量に発生する可能性があります。  

#### このパターンを使用する状況  

個々のエンティティに関連付けられているデータ系列を更新したり取得したりする必要がある場合に、このパターンを使用します。  

#### 関連のあるパターンとガイダンス  

このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  

-   [ラージ エンティティ パターン](#large-entity-pattern)  
-   [マージまたは置換](#working-with-heterogeneous-entity-types)  
-   [最終的に一貫性のあるトランザクション パターン](#eventually-consistent-transactions-pattern) (かどうかするは、データ系列を blob に格納)  

### ワイド エンティティ パターン  

複数の物理エンティティを使用して、252 を超えるプロパティを持つ論理エンティティを格納します。  

#### コンテキストと問題  

個々のエンティティが持つことができるプロパティは、(必須のシステム プロパティを除き) 252 個までです。また、格納できるデータは合計で 1 MB までです。 リレーショナル データベースでは、通常、新しいテーブルを追加し、その新しいテーブルと 1 対 1 のリレーションシップを作成することによって、行のサイズに関するさまざまな制限を回避します。  

#### 解決策  

Table サービスを使用すると、複数のエンティティを格納して、252 を超えるプロパティを持つ単一の大きなビジネス オブジェクトを作成できます。 たとえば、過去 365 日の間に各従業員が送信した IM メッセージの数を格納する場合は、スキーマの異なる 2 つのエンティティを使用する次のデザインを使用できます。  

![][24]

両方のエンティティを更新しないとエンティティどうしの同期が維持されない変更を加える必要がある場合は、EGT を使用できます。 それ以外の場合は、単一のマージ操作を使用して、特定の日のメッセージ数を更新できます。 個々 の従業員のすべてのデータを取得するには、両方のエンティティでは、両方を使用する 2 つの効率的なリクエストを行うことができますを取得する必要があります、 **PartitionKey** と **RowKey** 値。  

#### 問題と注意事項  

このパターンの実装方法を決めるときには、以下の点に注意してください。  

-   論理エンティティ全体を取得するには、少なくとも 2 つのストレージ トランザクション (各物理エンティティを取得するトランザクション) が必要です。  

#### このパターンを使用する状況  

サイズやプロパティの数が Table サービスに個別のエンティティに対して制限を超えるエンティティを格納するときに、このパターンを使用する必要があります。  

#### 関連のあるパターンとガイダンス  

このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  

-   [エンティティ グループ トランザクション](#entity-group-transactions)
-   [マージまたは置換](#working-with-heterogeneous-entity-types)

### ラージ エンティティ パターン  

BLOB ストレージを使用して、大きなプロパティ値を格納します。  

#### コンテキストと問題  

個々のエンティティに格納できるデータは合計で 1 MB までです。 1 つまたは複数のプロパティに格納される値でエンティティの合計サイズが 1 MB を超える場合は、Table サービスにエンティティ全体は格納できません。  

#### 解決策  

1 つ以上のプロパティに大量のデータが含まれているためにエンティティのサイズが 1 MB を超える場合は、BLOB サービスにデータを格納し、エンティティのプロパティに BLOB のアドレスを格納できます。 たとえば、従業員の写真を blob ストレージに格納し、写真へのリンクを格納できます、 **フォト** 従業員エンティティのプロパティ。  

![][25]

#### 問題と注意事項  

このパターンの実装方法を決めるときには、以下の点に注意してください。  

-   Table サービス内のエンティティと Blob サービスのデータの間の最終的な一貫性を維持するために使用して、 [最終的に一貫性のあるトランザクション パターン](#eventually-consistent-transactions-pattern) エンティティを維持します。
-   エンティティ全体を取得するには、少なくとも 2 つのストレージ トランザクション (エンティティを取得するトランザクションと BLOB データを取得するトランザクション) が必要です。  

#### このパターンを使用する状況  

サイズが Table サービスの個々のエンティティの制限を超えるエンティティを格納する必要がある場合に、このパターンを使用します。  

#### 関連のあるパターンとガイダンス  

このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  

-   [最終的に一貫性のあるトランザクション パターン](#eventually-consistent-transactions-pattern)  
-   [ワイド エンティティ パターン](#large-entity-pattern)

### 先頭または末尾に追加するアンチパターン  

大量に挿入する場合に、挿入を複数のパーティションに分散させることで、スケーラビリティを向上させます。  

#### コンテキストと問題  

格納されているエンティティの先頭または末尾にエンティティを追加すると、通常は、連続するパーティションの最初または最後のパーティションに新しいエンティティが追加されます。 この場合、常に挿入はすべて同じパーティション内で行われるため、ホットスポットが発生し、Table サービスが複数のノードに挿入の負荷を分散できず、場合によっては、パーティションのスケーラビリティ ターゲットに達する可能性があります。 たとえば、従業員によるネットワークやリソースへのアクセスをログに記録するアプリケーションで以下に示すエンティティ構造を使用した場合、トランザクションの量が個々のパーティションのスケーラビリティ ターゲットに達すると、現在処理が行われているパーティションがホットスポットになる可能性があります。  

![][26]

#### 解決策  

代わりに次のエンティティ構造を使用すると、アプリケーションでイベントをログに記録する際に特定のパーティションのホットスポットを回避できます。  

![][27]

次の例は 2 での通知、 **PartitionKey** と **RowKey** 複合キーです。  **PartitionKey** 部署と従業員の両方の id を使用して複数のパーティションに、ログを配布します。  

#### 問題と注意事項  

このパターンの実装方法を決めるときには、以下の点に注意してください。  

-   挿入時のホット パーティションの発生を回避する代わりのキー構造でクライアント アプリケーションが実行するクエリを効率的にサポートしていますか。  
-   予想されるトランザクションの量から判断して、個々のパーティションのスケーラビリティ ターゲットに達し、ストレージ サービスによって調整される可能性がありますか。  

#### このパターンを使用する状況  

トランザクションの量により、ホット パーティションにアクセスするとストレージ サービスによって調整される可能性がある場合は、先頭または末尾に追加するアンチパターンを使用しないでください。  

#### 関連のあるパターンとガイダンス  

このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  

-   [複合キー パターン](#compound-key-pattern)  
-   [ログ テール パターン](#log-tail-pattern)  
-   [エンティティを変更する](#working-with-heterogeneous-entity-types)  

### ログ データのアンチパターン  

ログ データの格納には通常、Table サービスではなく BLOB サービスを使用します。  

#### コンテキストと問題  

ログ データを使用する局面として最も一般的なのが、特定の日付範囲または時間範囲のログ エントリを選択して取得するというものです。たとえば、特定の日の 15:04 から 15:06 までの間にアプリケーションが記録したエラー メッセージや重要なメッセージをすべて取得するなどの局面が挙げられます。 ログ メッセージの日時を使用して、ログのエンティティを保存するパーティションを特定したくない: 任意の時点ですべてのログ エンティティを共有するので、同じホット パーティションになります **PartitionKey** 値 (セクションを参照して [先頭または末尾に追加するアンチ パターン](#prepend-append-anti-pattern))。 たとえば、ログ メッセージに関する以下のエンティティ スキーマでは、アプリケーションが現在の日付や時刻についてパーティションにあらゆるログ メッセージを書き込むことになるため、ホット パーティションの問題が発生します。  

![][28]

この例では、 **RowKey** 日付と時刻順で並べ替えられたログ メッセージを保存することにログ メッセージの日時をインクルードし、複数のログ メッセージが同時日付けと時刻を共有する場合に、メッセージ id が含まれています。  

別の方法は、使用する、 **PartitionKey** により、アプリケーションがパーティションの範囲にわたってメッセージを書き込みます。 たとえば、ログ メッセージのソースで多数のパーティションにメッセージを配信できるようになっている場合には、以下のエンティティ スキーマを使用できます。  

![][29]

ただし、このスキーマには問題があります。特定のタイム スパンに記録されたログ メッセージをすべて取得するときには、テーブル内のパーティションを逐一検索する必要があるからです。

#### 解決策  

前のセクションでは、ログ エントリの保存先として Table サービスを使用した場合に生じる問題について説明し、その解決策として、完璧とは言いがたいものの 2 つの設計を紹介しました。 1 つ目に紹介した方法には、ホット パーティションが発生し、ログ メッセージの書き込みのパフォーマンスが低下するリスクがあります。これに対して 2 つ目の方法は、特定のタイム スパンについてログ メッセージを取得しようとした場合に、テーブル内のパーティションを逐一スキャンしなければならないため、クエリのパフォーマンスが低下するという問題がありました。 BLOB ストレージなら、ここで取り上げたシナリオについて前の 2 つよりも優れたソリューションとなることができます。このため、Azure Storage Analytics が収集したログ データを保存するときにも、この BLOB ストレージが使用されています。  

このセクションでは、Storage Analytics が BLOB ストレージにログ データを格納する流れの概要を説明し、範囲を指定してクエリを実行することが多いデータを保存する際にこのアプローチがどのように役立つかを見ていきます。  

Storage Analytics では、ログ メッセージを一定の形式で区切ったものを、複数の BLOB に格納します。 区切りに使用する形式は、クライアント アプリケーション側でログ メッセージのデータ解析を円滑に完了できるものになっています。  

Storage Analytics が BLOB に対して使用している名前付け規則は、検索対象のログ メッセージが含まれる BLOB の場所を特定できるようなものになっています。 たとえば、"queue/2014/07/31/1800/000001.log" という名前の BLOB であれば、2014 年 7 月 31 日の 18:00 から始まる時間の Queue サービスと関係があるログ メッセージが格納されています。 "000001" という部分は、この期間の最初のログ ファイルであることを示しています。 このほか、Storage Analytics では BLOB のメタデータの一環として、ファイルに保存されている最初と最後のログ メッセージのタイムスタンプを記録します。 BLOB ストレージの API では、一定の名前プレフィックスに基づいてコンテナー内の BLOB の場所を特定できるようになっています。18:00 から始まる時間についてキューのログ データを格納している BLOB をすべて検索する場合には、"queue/2014/07/31/1800" というプレフィックスを使用します。  

Storage Analytics は内部のバッファーにログ メッセージを保管したうえで、ログ エントリのバッチの最新版を使って定期的に BLOB を更新したり、新しい BLOB を作成したりします。 これによって、BLOB サービスに書き込みを実行する回数が少なくなります。  

アプリケーションにこれと似たソリューションを実装するときには、信頼性 (ログ エントリが発生するたびに BLOB ストレージに書き込む) と、コストとスケーラビリティ (アプリケーションに更新内容を一時的に保管し、バッチとして BLOB ストレージに書き込む) との間のトレードオフをどのようにするかについて、検討が必要になります。  

#### 問題と注意事項  

ログ データの保存方法を決めるときには、以下の点に注意する必要があります。  

-   ホット パーティションが発生しないような設計のテーブルを作成すると、ログ データに対するアクセス効率が低下することがあります。  
-   ログ データを処理するときには多くの場合、クライアント側で多くのレコードを読み込む必要があります。  
-   ログ データは構造化されていないことが多いものの、BLOB ストレージの方が優れたソリューションになることがあります。  

### 実装時の注意事項  

このセクションでは、ここまでのセクションで説明したパターンを実装する際に念頭に置く必要がある点をいくつか説明します。 このセクションで示したコード例は、ほとんどが C# で書かれ、ストレージ クライアント ライブラリ (本稿執筆時点のバージョンは 4.3.0) を使用しています。  

### エンティティを取得する  

セクションで説明したように [を照会するためのデザイン](#design-for-querying),、"最も効率的なクエリはポイント クエリです。 ただ、時として多数のエンティティを同時に取得することも必要になります。 このセクションでは、ストレージ クライアント ライブラリを使ってエンティティを取得するときによく使用される方法をいくつか紹介します。  

#### ストレージ クライアント ライブラリを使ってポイント クエリを実行する  

ポイント クエリを実行する最も簡単な方法を使用する、 **取得** テーブル操作を次の c# コード スニペットを持つエンティティを取得するように、 **PartitionKey** 値"Sales"と **RowKey** 値「212」の。  

    TableOperation retrieveOperation =
        TableOperation.Retrieve<EmployeeEntity>("Sales", "212");
    var retrieveResult = employeeTable.Execute(retrieveOperation);
    if (retrieveResult.Result != null)
    {
    EmployeeEntity employee = (EmployeeEntity)retrieveResult.Result;
    ...
    }  

この例が、エンティティを要求する方法に注意してください。 型を取得 **従業員**します。  

#### LINQ を使って複数のエンティティを取得する  

複数のエンティティを取得するにはストレージ クライアント ライブラリとともに LINQ を使用して、クエリを指定して、 **、** 句。 テーブル スキャンを回避するには、必ず、 **PartitionKey** where 値句、および可能な場合は、 **RowKey** 値テーブルとパーティションのスキャンを回避します。 Table サービスは、where 句で一部の比較演算子 (より大きい、以上、より小さい、以下、等しい、等しくない) のみサポートしています。 次の c# コード スニペットが"B"で始まるすべての従業員を検索 (と仮定すると、 **RowKey** 、姓を格納)、営業部門で (と仮定した場合、 **PartitionKey** 部署名を格納)。  

    TableQuery<EmployeeEntity> employeeQuery =
            employeeTable.CreateQuery<EmployeeEntity>();
    var query = (from employee in employeeQuery
                where employee.PartitionKey == "Sales" &&
                employee.RowKey.CompareTo("B") >= 0 &&
                employee.RowKey.CompareTo("C") < 0
                select employee).AsTableQuery();
    var employees = query.Execute();  

クエリが両方を指定する方法に注意してください、 **RowKey** と **PartitionKey** パフォーマンスを確保します。  

次のコード サンプルは、fluent API を使用して同等の機能を示しています (fluent Api の詳細については「一般に、 [Fluent API を設計するためのベスト プラクティス](http://visualstudiomagazine.com/articles/2013/12/01/best-practices-for-designing-a-fluent-api.aspx))。  

    TableQuery<EmployeeEntity> employeeQuery = new TableQuery<EmployeeEntity>().Where(
     TableQuery.CombineFilters(
        TableQuery.CombineFilters(
        TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales"),
      TableOperators.And,
      TableQuery.GenerateFilterCondition(
        "RowKey", QueryComparisons.GreaterThanOrEqual, "B")
    ),
    TableOperators.And,
    TableQuery.GenerateFilterCondition("RowKey", QueryComparisons.LessThan, "C")
     )
    );
    var employees = employeeTable.ExecuteQuery(employeeQuery);  


>[AZURE.NOTE] このサンプルで複数 **コンバイン** を 3 つのフィルター条件を含める方法です。  

#### 1 件のクエリで大量のエンティティを取得する  

最適なクエリに基づいて個別のエンティティを返す、 **PartitionKey** 値と **RowKey** 値。 ところが、場合によっては同じパーティション、ときには多数のパーティションから、多数のエンティティを返すことが必要になります。  

そのようなときには必ず、アプリケーションのパフォーマンスを綿密にテストする必要があります。  

Table サービスに対してクエリを実行した場合、一度に返されるエンティティの数は最大 1,000 件、クエリの実行時間は最大 5 秒間です。 結果として返されるエンティティが 1,000 件を超える場合、クエリが 5 秒以内に完了しなかった場合、またはクエリがパーティションの境界をまたいで実行される場合には、Table サービスによって継続トークンが返されます。クライアント アプリケーションはこのトークンを使って、続きとなるエンティティを要求します。 継続トークンの動作の詳細については、次を参照してください。 [クエリのタイムアウトと改ページ調整](http://msdn.microsoft.com/library/azure/dd135718.aspx) MSDN にします。  

ストレージ クライアント ライブラリを使用している場合には、Table サービスからエンティティが返されるたびに継続トークンが自動で処理されます。 以下の C# コード サンプルではストレージ クライアント ライブラリを使用しているため、Table サービスが応答で返した継続トークンが自動的に処理されます。  

    string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
    TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

    var employees = employeeTable.ExecuteQuery(employeeQuery);
    foreach (var emp in employees)
    {
        ...
    }  

以下の C# コード サンプルでは、継続トークンの処理を明示的に記述しています。  

    string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
    TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

    TableContinuationToken continuationToken = null;

    do
    {
        var employees = employeeTable.ExecuteQuerySegmented(
            employeeQuery, continuationToken);
    foreach (var emp in employees)
    {
     ...
    }
    continuationToken = employees.ContinuationToken;
    } while (continuationToken != null);  

継続トークンを明示的に使用すると、アプリケーションが次のセグメントに相当するデータを取得するタイミングを制御ができます。 たとえば、テーブルに格納されたエンティティをクライアント アプリケーションでページとして表示できるようにしている場合に、クエリで取得したエンティティをユーザーが最後まで見ないことがあります。そのようなとき、継続トークンを明示的に使用していれば、ユーザーが現在のセグメントのエンティティの最後のページに達した時点で、アプリケーションが継続トークンだけを使って次のセグメントを取得できます。 この方法には、いくつかの利点があります。  

-   Table サービスから取得するデータの量を制限したり、ユーザーがネットワークを移動したりできるようになります。  
-   .NET の非同期 IO を実行できるようになります。  
-   継続トークンをシリアル化して永続記憶装置に保存できるため、アプリケーションがクラッシュした場合でも処理を継続できるようになります。  

>[AZURE.NOTE] 少ない場合がありますが、継続トークンは通常 1,000 エンティティを含むセグメントを返します。 これも大文字と小文字を使用してクエリが返すをエントリの数を制限する場合 **を** を検索条件に一致する最初の n 件のエンティティを返す: テーブル サービスは、残りのエンティティを取得できるように継続トークンと合わせて n 件のエンティティよりも少ないを含むセグメントを返す可能性があります。  

以下の C# コードは、1 つのセグメントで返されるエンティティの数を変更するためのものです。  

    employeeQuery.TakeCount = 50;  

#### サーバー側のプロジェクション  

1 つのエンティティには最大で 255 個のプロパティを格納でき、エンティティの最大サイズは 1 MB です。 テーブルに対してクエリを実行してエンティティを取得する際、すべてのプロパティが必要ない場合は、データの不要な転送を避けることができます (遅延とコストの削減につながります)。 サーバー側のプロジェクションを使えば、必要なプロパティのみを転送できます。 次の例は取得だけ **電子メール** プロパティ (と共に **PartitionKey**, 、**RowKey**, 、**タイムスタンプ**, 、および **ETag**)、クエリによって選択されたエンティティからです。  

    string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
    List<string> columns = new List<string>() { "Email" };
    TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter).Select(columns);

    var entities = employeeTable.ExecuteQuery(employeeQuery);
    foreach (var e in entities)
    {
        Console.WriteLine("RowKey: {0}, EmployeeEmail: {1}", e.RowKey, e.Email);
    }  

通知方法、 **RowKey** で取得するプロパティの一覧に含まれていても、値が有効です。  

### エンティティを変更する  

ストレージ クライアント ライブラリを使えば、Table サービスに格納されたエンティティを、挿入、削除、更新の各操作によって変更できます。 また、EGT を使えば複数の挿入、更新、削除の操作を一括で行えるため、必要なラウンドトリップの回数が減り、ソリューションのパフォーマンスが高まります。  

ストレージ クライアント ライブラリが EGT を実行したときにスローされる例外には、通常、一括処理の失敗を招いたエンティティのインデックスが含まれます。 これは EGT を使うコードをデバッグする際に役立ちます。  

クライアント アプリケーションでの同時実行と更新操作の処理方法に設計が及ぼす影響についても考慮が必要です。  

#### 同時実行を管理する  

既定では、テーブル サービスを実装するオプティミスティック同時実行のチェックの個々 のエンティティのレベルで **挿入**, 、**マージ**, 、および **削除** 操作、これらのチェックをバイパスするテーブル サービスを強制するクライアントのことができますが。 テーブル サービスでの同時実行制御の管理方法の詳細については、次を参照してください。  [Microsoft Azure Storage での同時実行を管理する](storage-concurrency.md) Microsoft Azure の web サイトにします。  

#### マージまたは置換  

 **置換** のメソッド、 **TableOperation** クラスは、常に、テーブル サービスに完全なエンティティを置換します。 格納されたエンティティに存在するプロパティを要求に含めない場合、要求により、格納されたエンティティからそのプロパティが削除されます。 格納されたエンティティからプロパティを明示的に削除しない場合は、すべてのプロパティを要求に含める必要があります。  

使用することができます、 **マージ** のメソッド、 **TableOperation** クラス エンティティを更新するとき、テーブル サービスに送信するデータの量を削減します。  **マージ** メソッドは、要求に含まれるエンティティのプロパティ値と格納エンティティ内の任意のプロパティが置き換えられますが、要求に含まれていないプロパティが格納されたエンティティにはそのまま残ります。 ラージ エンティティがあり、要求で少数のプロパティのみを更新する必要があるときに便利な処理です。  

>[AZURE.NOTE]  **置換** と **マージ** エンティティが存在しない場合、メソッドが失敗します。 代わりに、使用することができます、 **InsertOrReplace** と **InsertOrMerge** が存在しない場合は、新しいエンティティを作成するメソッドです。  

### 異なる種類のエンティティを操作する  

Table サービスは、 *スキーマのない* テーブル ストア 1 つのテーブルが非常に柔軟にデザインを提供する複数の種類のエンティティを格納できることを意味します。 次の例は、従業員エンティティと部署エンティティの両方を格納したテーブルを示しています。  

<table>
<tr>
<th>PartitionKey</th>
<th>RowKey</th>
<th>タイムスタンプ</th>
<th></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>電子メール</th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>電子メール</th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>DepartmentName</th>
<th>EmployeeCount</th>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>電子メール</th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
</table>

各エンティティが所有している **PartitionKey**, 、**RowKey**, 、および **タイムスタンプ** 、値が、プロパティのセットを持つことがあります。 さらに、エンティティの種類を示すものがありません (エンティティの種類に関する情報を格納していない場合)。 エンティティの種類を識別する方法は 2 とおりあります。  

-   エンティティ型を追加、 **RowKey** (または場合によって、 **PartitionKey**)。 たとえば、 **EMPLOYEE_000123** または **DEPARTMENT_SALES** として **RowKey** 値。  
-   以下の表に示すように、個別のプロパティを使用してエンティティの種類を記録します。  

<table>
<tr>
<th>PartitionKey</th>
<th>RowKey</th>
<th>タイムスタンプ</th>
<th></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>電子メール</th>
</tr>
<tr>
<td>Employee</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>電子メール</th>
</tr>
<tr>
<td>Employee</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>DepartmentName</th>
<th>EmployeeCount</th>
</tr>
<tr>
<td>学科</td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>電子メール</th>
</tr>
<tr>
<td>Employee</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
</table>

最初のオプションは、エンティティを付加することで型を **RowKey**, 、さまざまな種類の 2 つのエンティティに同じキー値ある可能性がある場合に便利です。 この方法なら、パーティションに同じ種類のエンティティのグループ化もできます。  

説明したこのセクションで説明した手法は [継承関係](#inheritance-relationships) のセクションでは、本ガイドに前述 [リレーションシップをモデル化](#modelling-relationships)します。  

>[AZURE.NOTE] POCO オブジェクトを発展させは別のバージョンのクライアント アプリケーションを有効にするのには、エンティティ型の値にバージョン番号を追加する必要があります。  

このセクションの残りの部分では、同じテーブル内の異なる種類のエンティティを操作しやすくするストレージ クライアント ライブラリの機能について説明します。  

#### 異なる種類のエンティティを取得する  

ストレージ クライアント ライブラリを使えば、3 とおりの方法で複数の種類のエンティティを操作できます。  

特定と共に格納されているエンティティの型を確認するかどうかは **RowKey** と **PartitionKey** フィールドでは、エンティティ型を指定するには、型のエンティティを取得する前の 2 つの例のように、エンティティを取得するときに、 **従業員**: [ストレージ クライアント ライブラリを使用して 1 つのエンティティを取得する](#retrieving-a-single-entity-using-the-storage-client-library) と [LINQ を使用して複数のエンティティを取得する](#retrieving-multiple-entities-using-linq)です。  

2 番目のオプションは、使用する、 **DynamicTableEntity** (このオプションも向上させますパフォーマンスおよびエンティティを .NET の型に逆シリアル化する必要がないため)、具体的な POCO エンティティ型ではなく型 (プロパティ バッグ)。 次の c# コードは可能性のあるテーブル、さまざまな種類の複数のエンティティを取得しますが、すべてのエンティティとして返します **DynamicTableEntity** インスタンス。 次を使用して、 **EntityType** プロパティを各エンティティの種類を決定します。  

    string filter =     TableQuery.CombineFilters(
        TableQuery.GenerateFilterCondition("PartitionKey",
      QueryComparisons.Equal, "Sales"),
        TableOperators.And,
        TableQuery.CombineFilters(
        TableQuery.GenerateFilterCondition("RowKey",
                    QueryComparisons.GreaterThanOrEqual, "B"),
            TableOperators.And,
            TableQuery.GenerateFilterCondition("RowKey",
          QueryComparisons.LessThan, "F")
        )
    );
    TableQuery<DynamicTableEntity> entityQuery =
    new TableQuery<DynamicTableEntity>().Where(filter);
    var employees = employeeTable.ExecuteQuery(entityQuery);

    IEnumerable<DynamicTableEntity> entities = employeeTable.ExecuteQuery(entityQuery);
    foreach (var e in entities)
    {
    EntityProperty entityTypeProperty;
    if (e.Properties.TryGetValue("EntityType", out entityTypeProperty))
    {
        if (entityTypeProperty.StringValue == "Employee")
        {
            // Use entityTypeProperty, RowKey, PartitionKey, Etag, and Timestamp
          }
     }
    }  

その他のプロパティを使用する必要がありますを取得することに注意してください、 **TryGetValue** メソッドを **プロパティ** のプロパティ、 **DynamicTableEntity** クラスです。  

3 番目のオプションは、組み合わせの使用は、 **DynamicTableEntity** 型と **EntityResolver** インスタンス。 この方法なら、同じクエリで複数の POCO 型を解決できます。 この例では、 **EntityResolver** デリゲートを使用して、 **EntityType** プロパティをクエリによって返されるエンティティの 2 つの種類を区別します。  **を解決する** メソッドの使用方法、 **リゾルバー** 解決するのにはデリゲート **DynamicTableEntity** インスタンスを **TableEntity** インスタンス。  

    EntityResolver<TableEntity> resolver = (pk, rk, ts, props, etag) =>
    {

        TableEntity resolvedEntity = null;
        if (props["EntityType"].StringValue == "Department")
        {
            resolvedEntity = new DepartmentEntity();
        }
        else if (props["EntityType"].StringValue == "Employee")
        {
            resolvedEntity = new EmployeeEntity();
        }
        else throw new ArgumentException("Unrecognized entity", "props");

        resolvedEntity.PartitionKey = pk;
        resolvedEntity.RowKey = rk;
        resolvedEntity.Timestamp = ts;
        resolvedEntity.ETag = etag;
        resolvedEntity.ReadEntity(props, null);
        return resolvedEntity;
    };

    string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
    TableQuery<DynamicTableEntity> entityQuery =
        new TableQuery<DynamicTableEntity>().Where(filter);

    var entities = employeeTable.ExecuteQuery(entityQuery, resolver);
    foreach (var e in entities)
    {
        if (e is DepartmentEntity)
        {
        ...
        }
        if (e is EmployeeEntity)
        {
        ...
        }
    }  

#### 異なる種類のエンティティを変更する  

エンティティの種類がわからなくても削除はできますが、挿入はできません。 ただし、使用することができます **DynamicTableEntity** 、型を把握したり POCO エンティティ クラスを使用せずにエンティティを更新する型。 次のコード サンプルは、1 つのエンティティを取得し、チェック、 **EmployeeCount** プロパティを更新する前に存在します。  

    TableResult result =
        employeeTable.Execute(TableOperation.Retrieve(partitionKey, rowKey));
    DynamicTableEntity department = (DynamicTableEntity)result.Result;

    EntityProperty countProperty;

    if (!department.Properties.TryGetValue("EmployeeCount", out countProperty))
    {
        throw new
            InvalidOperationException("Invalid entity, EmployeeCount property not found.");
    }
    countProperty.Int32Value += 1;
    employeeTable.Execute(TableOperation.Merge(department));  

### Shared Access Signature を使ってアクセスを制御する  

Shared Access Signature (SAS) トークンを使うと、クライアント アプリケーションで、Table サービスに対して直接認証しなくてもテーブル エンティティを直接変更 (と照会) できるようになります。 通常、アプリケーションで SAS を使うと、次の 3 つのメリットが得られます。  

-   デバイスで Table サービスのエンティティにアクセスして変更できるようにするために、安全ではないプラットフォーム (モバイル デバイスなど) にストレージ アカウント キーを配布する必要がない。  
-   Web ロールまたは worker ロールがエンティティを管理する際に実行する処理の一部を、エンド ユーザー コンピューターやモバイル デバイスなどのクライアント デバイスにオフロードできる。  
-   制約と時間制限のあるアクセス許可のセットをクライアントに割り当てることができる (読み取り専用アクセスを特定のリソースに許可するなど)。  

テーブル サービスと SAS トークンの使用に関する詳細については、次を参照してください。 [共有アクセス署名、第 1 部: SAS モデルについて](../storage-dotnet-shared-access-signature-part-1/)します。  

ただし、Table サービスのエンティティへのアクセスをクライアント アプリケーションに付与する SAS トークンを生成する必要はあります。これは、ストレージ アカウント キーに安全にアクセスできる環境で行うようにしてください。 通常は、Web ロールまたは worker ロールを使って SAS トークンを生成し、エンティティへのアクセスを必要とするクライアント アプリケーションに配布します。 SAS トークンの生成とクライアントへの配布にもやはりオーバーヘッドが伴うため、特に大量に扱うシナリオでは、このオーバーヘッドを減らす最適な方法を検討する必要があります。  

テーブル内のエンティティのサブセットへのアクセスを付与する SAS トークンを生成できます。 既定では、テーブル全体に対し SAS トークンを作成しますが、SAS トークンがの範囲についてへのアクセスを許可しているかを指定することも **PartitionKey** 値、または一連の **PartitionKey** と **RowKey** 値。 システムの個々のユーザーに SAS トークンが生成されるようにすれば、各ユーザーの SAS トークンによってアクセスが許可されるのは、Table サービス内にあるユーザー独自のエンティティだけになります。  

### 非同期と並列操作  

要求を複数のパーティションに分散させている場合は、非同期または並列クエリを使ってスループットとクライアントの応答性を向上させることができます。
たとえば、テーブルに並列的にアクセスする複数の worker ロール インスタンスを使用する場合などです。 個別の worker ロールで特定のパーティション セットのみを処理することも可能であるほか、テーブル内のすべてのパーティションにアクセスできる worker ロール インスタンスを複数実装することも可能です。  

クライアント インスタンスでは、ストレージ操作を非同期的に実行することでスループットを高めることができます。 ストレージ クライアント ライブラリを使えば、非同期クエリと変更を簡単に記述できます。 たとえば、次の C# コードに示すように、パーティション内のすべてのエントリを取得する同期メソッドをベースとして利用できます。  

    private static void ManyEntitiesQuery(CloudTable employeeTable, string department)
    {
        string filter = TableQuery.GenerateFilterCondition(
            "PartitionKey", QueryComparisons.Equal, department);
        TableQuery<EmployeeEntity> employeeQuery =
            new TableQuery<EmployeeEntity>().Where(filter);

        TableContinuationToken continuationToken = null;

        do
        {
            var employees = employeeTable.ExecuteQuerySegmented(
                employeeQuery, continuationToken);
            foreach (var emp in employees)
        {
        ...
        }
            continuationToken = employees.ContinuationToken;
        } while (continuationToken != null);
    }  

このコードを次のように少し変更して、クエリが非同期的に実行されるようにします。  

    private static async Task ManyEntitiesQueryAsync(CloudTable employeeTable, string department)
    {
        string filter = TableQuery.GenerateFilterCondition(
            "PartitionKey", QueryComparisons.Equal, department);
        TableQuery<EmployeeEntity> employeeQuery =
            new TableQuery<EmployeeEntity>().Where(filter);
        TableContinuationToken continuationToken = null;

        do
        {
            var employees = await employeeTable.ExecuteQuerySegmentedAsync(
                employeeQuery, continuationToken);
            foreach (var emp in employees)
            {
             ...
            }
            continuationToken = employees.ContinuationToken;
            } while (continuationToken != null);
    }  

この非同期の例は、同期のバージョンに次の変更が加えられたものです。  

-   メソッドのシグネチャが今すぐに、 **async** 修飾子を返す、 **タスク** インスタンス。  
-   呼び出す代わりに、 **ExecuteSegmented** を今すぐメソッドの結果を取得するメソッドを呼び出す、 **ExecuteSegmentedAsync** メソッドを使用して、 **await** 修飾子を非同期的に結果を取得します。  

クライアント アプリケーションでも、このメソッドを複数回呼び出すことができます (異なる値を **部門** パラメーター)、各クエリは、別のスレッドで実行されます。  

非同期バージョンがないことに注意してください、 **Execute** メソッドで、 **TableQuery** クラスため、 **IEnumerable** インターフェイスは非同期列挙型をサポートしていません。  

エンティティを非同期的に挿入、更新、削除できます。 次の C# の例は、従業員エンティティを挿入または置換する単純な同期メソッドです。  

    private static void SimpleEmployeeUpsert(CloudTable employeeTable,
        EmployeeEntity employee)
    {
        TableResult result = employeeTable
            .Execute(TableOperation.InsertOrReplace(employee));
        Console.WriteLine("HTTP Status: {0}", result.HttpStatusCode);
    }  

このコードを次のように少し変更して、更新が非同期的に実行されるようにすることができます。  

    private static async Task SimpleEmployeeUpsertAsync(CloudTable employeeTable,
        EmployeeEntity employee)
    {
        TableResult result = await employeeTable
            .ExecuteAsync(TableOperation.InsertOrReplace(employee));
        Console.WriteLine("HTTP Status: {0}", result.HttpStatusCode);
    }  

この非同期の例は、同期のバージョンに次の変更が加えられたものです。  

-   メソッドのシグネチャが今すぐに、 **async** 修飾子を返す、 **タスク** インスタンス。  
-   呼び出す代わりに、 **Execute** メソッドを今すぐ、エンティティを更新するメソッドを呼び出す、 **ExecuteAsync** メソッドを使用して、 **await** 修飾子を非同期的に結果を取得します。  

クライアント アプリケーションは、これと同じように非同期メソッドを複数回呼び出すことができます。各メソッドの呼び出しは別々のスレッドで実行されます。  


### クレジット
次の Azure チームのメンバーに感謝しております。 Dominic Betts、Jason Hogg、Jean Ghanem、Jai Haridas、Jeff Irwin、Vamshidhar Kommineni、Vinay Shah、Serdar Ozler だけでなく Microsoft DX の Tom Hollander。 

以下の Microsoft MVP にもレビュー時に彼らの貴重なフィードバックを頂きました。感謝いたします: Igor Papirov と Edward Bakker



[1]: ./media/storage-table-design-guide/storage-table-design-IMAGE01.png
[2]: ./media/storage-table-design-guide/storage-table-design-IMAGE02.png
[3]: ./media/storage-table-design-guide/storage-table-design-IMAGE03.png
[4]: ./media/storage-table-design-guide/storage-table-design-IMAGE04.png
[5]: ./media/storage-table-design-guide/storage-table-design-IMAGE05.png
[6]: ./media/storage-table-design-guide/storage-table-design-IMAGE06.png
[7]: ./media/storage-table-design-guide/storage-table-design-IMAGE07.png
[8]: ./media/storage-table-design-guide/storage-table-design-IMAGE08.png
[9]: ./media/storage-table-design-guide/storage-table-design-IMAGE09.png
[10]: ./media/storage-table-design-guide/storage-table-design-IMAGE10.png
[11]: ./media/storage-table-design-guide/storage-table-design-IMAGE11.png
[12]: ./media/storage-table-design-guide/storage-table-design-IMAGE12.png
[13]: ./media/storage-table-design-guide/storage-table-design-IMAGE13.png
[14]: ./media/storage-table-design-guide/storage-table-design-IMAGE14.png
[15]: ./media/storage-table-design-guide/storage-table-design-IMAGE15.png
[16]: ./media/storage-table-design-guide/storage-table-design-IMAGE16.png
[17]: ./media/storage-table-design-guide/storage-table-design-IMAGE17.png
[18]: ./media/storage-table-design-guide/storage-table-design-IMAGE18.png
[19]: ./media/storage-table-design-guide/storage-table-design-IMAGE19.png
[20]: ./media/storage-table-design-guide/storage-table-design-IMAGE20.png
[21]: ./media/storage-table-design-guide/storage-table-design-IMAGE21.png
[22]: ./media/storage-table-design-guide/storage-table-design-IMAGE22.png
[23]: ./media/storage-table-design-guide/storage-table-design-IMAGE23.png
[24]: ./media/storage-table-design-guide/storage-table-design-IMAGE24.png
[25]: ./media/storage-table-design-guide/storage-table-design-IMAGE25.png
[26]: ./media/storage-table-design-guide/storage-table-design-IMAGE26.png
[27]: ./media/storage-table-design-guide/storage-table-design-IMAGE27.png
[28]: ./media/storage-table-design-guide/storage-table-design-IMAGE28.png
[29]: ./media/storage-table-design-guide/storage-table-design-IMAGE29.png
 

